<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25" zv="Cache for Windows (x86-64) 2017.2.1 (Build 801)" ts="2020-03-24 11:36:29">
<Class name="test.framework.CExecuteTests">
<Super>%RegisteredObject</Super>
<TimeChanged>65455,32453</TimeChanged>
<TimeCreated>63684,52123.001053</TimeCreated>

<Method name="RunTests">
<Description>
Note ACGendron : Fonctionnement hasardeux avant Caché 2014 mais devrait 
                 compiler quand même sans problème !
-----------------------------------------------------------------------------</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>bIsClass:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
   #dim strClassName As %String = ..%ClassName(1)
   set:('bIsClass) strClassName = ..%PackageName()
   do ##class(test.framework.InterSystems.CManager).RunTest(strClassName)
]]></Implementation>
</Method>

<Method name="EnableUnitTestFramework">
<Description>
See http://localhost:8972/csp/docbook/DocBook.UI.Page.cls?KEY=TUNT_ExampleTestPortal </Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
   #Dim strOldNS = $ZConvert($NAMESPACE, "L")
   ZNSpace "%SYS"
   set ^SYS("Security","CSP","AllowPrefix","/csp/"_strOldNS_"/","%UnitTest.") = 1
   ZNSpace strOldNS
]]></Implementation>
</Method>

<Method name="DeleteAllOlderTest">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[   do ##class(%UnitTest.Result.TestInstance).%DeleteExtent()
]]></Implementation>
</Method>
</Class>


<Class name="test.framework.CUnitTestBase">
<Description>
Supports : 
 $$$AssertEquals       Returns true if expressions are equal.           do $$$AssertEquals(x,y,"x equals y")
 $$$AssertNotEquals    Returns true if expressions are not equal.       do $$$AssertNotEquals(x,y,"x is not equal to y")
 $$$AssertStatusOK     Returns true if the returned status code is 1.   do $$$AssertStatusOK(sc,"Status is OK")
 $$$AssertStatusNotOK  Returns true if the returned status code is 0.   do $$$AssertStatusNotOK(sc,"Status is NotOK")
 $$$AssertTrue         Returns true if the expression is true.          do $$$AssertTrue(x=y,"Expression x=y is true")
 $$$AssertNotTrue      Returns true if the expression is not true.      do $$$AssertNotTrue(x=y,"Expression x=y is not true")
 $$$AssertFilesSame    Returns true if two files are identical.         do $$$AssertFilesSame(output.log,reference.log,"Comparing output.log to reference.log")
 $$$LogMessage         Writes a log message to the ^UnitTestLog global. do $$$LogMessage("My message")

This class is only a wrapper, to prevent having to inherit a "InterSystems" class in CHS classes.</Description>
<Super>test.framework.InterSystems.CUnitTest,test.framework.CExecuteTests,test.framework.Mock.CMockManager</Super>
<TimeChanged>65455,32453</TimeChanged>
<TimeCreated>62883,70697.280223</TimeCreated>

<Parameter name="bSQLTransactionEnabled">
<Type>%Boolean</Type>
<Default>1</Default>
</Parameter>

<Method name="RunTests">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[   do ##super(1)
]]></Implementation>
</Method>

<Method name="EnableSuccessfulAssert">
<FormalSpec><![CDATA[bEnable:%Boolean,&bPreviousValue:%Boolean]]></FormalSpec>
<Implementation><![CDATA[
   do ..LogMessage("Turning successful Assert " _ $case(bEnable, 1 :"ON", 0 : "OFF"))
   set bPreviousValue = ..Manager.bShowSuccessfulAssert
   set ..Manager.bShowSuccessfulAssert = bEnable
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
/*

TODO: Ambos os métodos abaixo são referentes a testes com instância Ensemble.

/// Extracts the data of a XData test section into a stream.
/// If the data is test encapsulated in <CDATA> nodes, they are
/// removed from the stream content.
Method GetXDataPayload(strXDataName As %String) As %Stream.Object
{
   set xDataContentStream = ##class(%Stream.TmpCharacter).%New()
   
   // If no class name is given, use the current one.
   set:(strXDataName '[ "||") strXDataName = ..%ClassName(1) _ "||" _ strXDataName
   
   set xData = ##class(%Dictionary.CompiledXData).%OpenId(strXDataName)
   
   if ($IsObject(xData))
   {
      #Dim line As %String = xData.Data.ReadLine()

      // If the first line starts by <CDATA>, it is removed, as well as the closing tag.
      if (line = "<CDATA></CDATA>")
      {
         do xDataContentStream.WriteLine("")
      }
      elseif (line = "<CDATA>")
      {
         while ('xData.Data.AtEnd)
         {
            set line = xData.Data.ReadLine()
            do:(line '= "</CDATA>") xDataContentStream.WriteLine(line)
         }
      }
      else
      {
         do xDataContentStream.CopyFrom(xData.Data)   
      }
   }

   do xDataContentStream.Rewind()
      
   quit xDataContentStream
}

/*Method GetHL7FromString(strHL7Message As %String, strMessageSchemaCategory As %String = "") As EnsLib.HL7.Message
{
   #Dim hl7Message As EnsLib.HL7.Message = ##class(EnsLib.HL7.Message).ImportFromString(strHL7Message)
   set srv = ##class(EnsLib.HL7.Service.FileService).%New("Name")
   set srv.MessageSchemaCategory = strMessageSchemaCategory
   set:(strMessageSchemaCategory = "") srv.MessageSchemaCategory = hl7Message.TypeVersion
   do hl7Message.PokeDocType(srv.resolveDocType(hl7Message))
   quit hl7Message
}

Method GetHL7FromXData(strXDataName As %String, strMessageSchemaCategory As %String = "") As EnsLib.HL7.Message
{
   quit ..GetHL7FromString(..GetXDataPayload(strXDataName).Read(1000000), strMessageSchemaCategory)
}*/
]]></Content>
</UDLText>
</Class>


<Class name="test.framework.InterSystems.CFormatter">
<Description>
*****************************************************

This class comes from InterSystens, provided at the
Global Summit 2015. It was not modified, except for 
the packages name.

*****************************************************
This is a Requirement Formatter. Given a requirement class name, it displays a nice page for it.</Description>
<Abstract>1</Abstract>
<IncludeCode>%occInclude</IncludeCode>
<TimeChanged>65455,32453</TimeChanged>
<TimeCreated>62883,70726.805754</TimeCreated>

<Method name="Run">
<Description>
This method is used to display a page.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClassName:%String</FormalSpec>
<PublicList>Result</PublicList>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   &html<<html>
      <head>>
   do ..DisplayStyles()
   do ..DisplayJS()
   set title=..GetTitle(pClassName)
   &html<<title>#(title)#</title>
      </head>
      <body>>
   if $d(%request.Data("run")) {
      w "<div class=""hidden"" id=""output"">"
      w "<pre>"
      w "To run this class it terminal with debug mode on, type:",!
      w "do ##class("_pClassName_").Run(""/debug"")"
      do $zobjclassmethod(pClassName,"Run")
      w "</pre>"
      w "</div>"
   }
   if $d(%request.Data("runRecursive")) {
      w "<div class=""hidden"" id=""output"">"
      w "<pre>"
      w "To run this test suite it terminal with debug mode on, type:",!
      w "do ##class("_pClassName_").RunRecursive(""/debug"")"
      do $zobjclassmethod(pClassName,"RunRecursive")
      w "</pre>"
      w "</div>"
   }
   do ..DisplayMenuBar(pClassName)
   do ..DisplayPath(pClassName)
   &html<<h1>#(title)#>
   &html<</h1>>
   set showLast=0
   set isRequirement=##class(%Dictionary.XDataDefinition).%ExistsId(pClassName_"||RequirementDefinition")
   if $d(%request.Data("run")) || $d(%request.Data("runRecursive")) || $d(%request.Data("results")) {
      set showLast=1
   }
   if isRequirement {
      if showLast {
         do ..DisplayLastResult(pClassName)
      } else {
         set Def=##class(%Dictionary.XDataDefinition).%OpenId(pClassName_"||RequirementDefinition")
         if Def set Stream=Def.Data
         if $get(Stream) do Stream.OutputToDevice()
      }
   } else {
      do ..DisplayAsPage(pClassName,showLast)
   }
   
   do ..DisplayChildren(pClassName)
   &html<</body></html>>
   Quit $$$OK
]]></Implementation>
</Method>

<Method name="DisplayLastResult">
<ClassMethod>1</ClassMethod>
<FormalSpec>pClassName</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   set result=$zobjclassmethod(pClassName,"GetLastResult",.dateTime,.status,.duration,.html)
   if result="" quit $$$OK
   w html,!
   quit $$$OK
]]></Implementation>
</Method>

<Method name="DisplayAsPage">
<ClassMethod>1</ClassMethod>
<FormalSpec>pClassName,pShowLast=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   write ##class(%Dictionary.CompiledClass).%OpenId(pClassName).Description
   if pShowLast set instance=$zobjclassmethod(pClassName,"GetLastResult",.dateTime,.status,.duration,.html,.suite)
   set method=""
   for  {
      set method=$$$comMemberNext(pClassName,$$$cCLASSmethod,method)
      quit:method=""
      if $e(method,1,4)'="Test" continue
      set result=""
      try {
         if pShowLast set result=##class(%UnitTest.Report).GetTestStatus($znspace, instance, suite, pClassName, method)
      } catch(e) {}
      set class=$s(result="":"Skipped",result=1:"Passed",1:"Failed")
      write "<div class=""status"_class_""">"
      write !,"<h2>",method,"</h2>"
      write ##class(%Dictionary.CompiledMethod).%OpenId(pClassName_"||"_method).Description
      if pShowLast && (instance'="") {
         write "<div>"
         set assert="",inDiv=0
         for {
            set assert=$o(^UnitTest.Result(instance,suite,pClassName,method,assert))
            quit:assert=""
            set result=$li(^UnitTest.Result(instance,suite,pClassName,method,assert),1)
            if result=1 {
               if 'inDiv {
                  write "<div class=""assertPassed"">"
                  set inDiv=1
               }
               write "* "
            }
            if result=0 {
               if inDiv {
                  write "</div>"
                  set inDiv=0
               }
               write "<div class=""assertFailed"">"
               write "FAILED: "_$zcvt($li(^UnitTest.Result(instance,suite,pClassName,method,assert),2),"O","HTML")
               write ": "_$zcvt($li(^UnitTest.Result(instance,suite,pClassName,method,assert),3),"O","HTML")
               write "</div>"
               
            }
         }
         if inDiv {
            write "</div>"
         }
         write "</div>"
      }
      write "</div>"
   }
]]></Implementation>
</Method>

<Method name="DisplayMenuBar">
<ClassMethod>1</ClassMethod>
<FormalSpec>pClassName</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   s result=$zobjclassmethod(pClassName,"GetLastResult",.dateTime,.status,.duration,.html)
   s class=$s(status="":"Skipped",status=1:"Passed",1:"Failed")
   w "<p class=""status"_class_""">"
   w "  Execution results:"
   w " <b>"_class_"</b>"
   i dateTime'="" {
      w "  at "_dateTime
      w "  duration "_duration_". "
   }
   i $d(%request.Data("run")) || $d(%request.Data("runRecursive")) {
      w " <a class=""abutton"" href=""#"" onclick=""return show('','output');"">CONSOLE</a>"
   }
   w " <a class=""abutton"" href=""?"">#</a>"
   w " <a class=""abutton"" href=""?run"">Run</a>"
   w " <a class=""abutton"" href=""?runRecursive"">Run Recursive</a>"
   w " <a class=""abutton"" target=""_blank"" href=""%25UnitTest.Report.cls?NS="_$znspace_"&INDEX="_result_""">Execution log</a>"
   w " <a class=""abutton"" href=""?results"">Show last result</a>"
   w "</p>",!
   q $$$OK
]]></Implementation>
</Method>

<Method name="DisplayPath">
<ClassMethod>1</ClassMethod>
<FormalSpec>pClassName</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   set path=""
   f i=1:1:$l(pClassName,".")-1 {
      s parentName=$p(pClassName,".",1,i)
      if ##class(%Dictionary.CompiledClass).%ExistsId(parentName) && $classmethod(parentName,"%IsA","UnitTest.Abstract") {
         s path=path_"| [<a href="""_parentName_".cls"">"_..GetTitle(parentName) _"</a>] "
      }
   }
   s $e(path)=""
   w path
   quit $$$OK
]]></Implementation>
</Method>

<Method name="GetTitle">
<ClassMethod>1</ClassMethod>
<FormalSpec>pClassName</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
   set title=##class(%Dictionary.CompiledParameter).%OpenId(pClassName_"||TITLE")
   if title set title=title.Default
   if title="" set title=pClassName
   quit title
]]></Implementation>
</Method>

<Method name="DisplayChildren">
<Description>
Display children</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClassName</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   set pointCount=$l(pClassName,".")
   set child=pClassName_"."
   set childStr=""
   for {
      s child=$o(^oddDEF(child))
      i child'[(pClassName_".") q
      i $l(child,".")'=(pointCount+1) continue
      s childStr=childStr_"<p><a href="""_child_".cls"">"_..GetTitle(child) _"</a></p> "
   }
   i childStr'="" w "<h2>More details: </h2>"_childStr
   quit $$$OK
]]></Implementation>
</Method>

<Method name="DisplayStyles">
<Description>
Output CSS stules for page</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   &html<
      <style type="text/css">
      body {
         padding: 32px;
      }
      pre {
         padding: 6px 28px 6px 28px;
         background-color: #E8EEF7;
      }
      pre, pre *, code, code *, kbd {
         font-family: Courier New, Courier;
         font-siz1e: 10pt;
      }
      h1, h1 * {
         font-siz1e: 24pt;
      }
      p, td, th, li, .breadcrumbs {
         font-siz1e: 10pt;
      }
      p, li {
         line-height: 140%;
      }
      table {
         border-collapse: collapse;
         empty-cells: show;
         margin: 8px 0px 8px 0px;
      }
      th, td {
         border: 1px solid black;
         padding: 3px;
      }
      td {
         background-color: white;
         vertical-align: top;
      }
      th {
         background-color: #C3D9FF;
      }
      li {
         margin-top: 6px;
         margin-bottom: 6px;
      }


      .example {
         padding: 2px 12px 6px 12px;
         border: 1px solid #C3D9FF;
         margin: 6px 0px 28px 0px;
         background-color: #F5F9FD;
      }
      .example h3 {
         margin-top: 8px;
         margin-bottom: 8px;
         font-siz1e: 12pt;
      }

      .special {
         font-style: italic;
      }

      .idea {
         font-siz1e: 9pt;
         color: #888;
         font-style: italic;
      }
      .tight li {
         margin-top: 1px;
         margin-bottom: 1px;
      }
      .commentary {
         float: right;
         width: 200px;
         background-color: #ffffd0;
         padding:8px;
         border: 3px solid #eeeeb0;
         margin: 10px 0px 10px 10px;
      }
      .commentary, .commentary * {
         font-siz1e: 8pt;
      }
      .ok {
         background-color: #d0ffd0;
      }
      .error {
         background-color: #ffd0d0;
      }
      
      .statusPassed {
         padding: 2px 12px;
         border: 1px solid #33CC33;
         margin: 0px 0px 18px 0px;
         background-color: #70DB70;
      }

      .statusFailed {
         padding: 2px 12px;
         border: 1px solid #FF0000;
         margin: 0px 0px 18px 0px;
         background-color: #E60000;
      }

      .statusSkipped {
         padding: 2px 12px;
         border: 1px solid #DDDDDD;
         margin: 0px 0px 18px 0px;
         background-color: #F3F3F3;
      }
      
      .assertPassed {
         color:black;
         font-family: Courier New, Courier;
      }

      .assertFailed {
         color:white;
         font-family: Courier New, Courier;
      }
      
      .hidden {
         display:none;
      }
      .abutton {
         padding: 0 0.2em;
         border: 1px solid #C0C0C0;
         margin: 0 0.2em;
         background-color: #E0E0E0;
      }
      </style>>
]]></Implementation>
</Method>

<Method name="DisplayJS">
<Description>
Output CSS stules for page</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   &html<
      <script language="JavaScript">
      function show(element,id) {
         if(element) element.className="hidden";
         document.getElementById(id).className="";
         return false;
      }
      </script>>
]]></Implementation>
</Method>

<Method name="WriteXmlReport">
<ClassMethod>1</ClassMethod>
<FormalSpec>pFileName:%String,pResultIndex:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   if $g(pResultIndex)="" s pResultIndex=$o(^UnitTest.Result(""),-1)
   set File=##class(%File).%New(pFileName)
   do File.Open("WSN")
   do File.WriteLine("<testsuites>")
   set suite=""
   for  {
      set suite=$o(^UnitTest.Result(pResultIndex,suite))
      quit:suite=""
      //do File.WriteLine("<testsuite name="""_suite_""" time="""_$fn($lg(^UnitTest.Result(pResultIndex,suite),2),"-")_""">")

      set case=""
      for  {
         set case=$o(^UnitTest.Result(pResultIndex,suite,case))
         quit:case=""
         set status=##class(%UnitTest.Report).GetTestStatus($znspace, pResultIndex,suite,case)
         do File.WriteLine("<testsuite name="""_case_""" time="""_$fn($lg(^UnitTest.Result(pResultIndex,suite,case),2),"-")_""">")
         do File.WriteLine("<testcase name=""TestRequirement"" time="""_$fn($lg($g(^UnitTest.Result(pResultIndex,suite,case,"TestRequirement")),2),"-")_""">")
         set method="TestRequirement"
         set index="",systemOut="",failure="",failureType=""
         for {
            set index=$o(^UnitTest.Result(pResultIndex,suite,case,method,index))
            quit:index=""
            if $lg(^UnitTest.Result(pResultIndex,suite,case,method,index),1)=0 {
               set failureType=$lg(^UnitTest.Result(pResultIndex,suite,case,method,index),2)
               set failure=failure_$lg(^UnitTest.Result(pResultIndex,suite,case,method,index),3)_$c(13,10)
            }
            if $lg(^UnitTest.Result(pResultIndex,suite,case,method,index),2)="LogMessage" {
               set systemOut=systemOut_$lg(^UnitTest.Result(pResultIndex,suite,case,method,index),3)
            }

         }
         if failure'="" {
            do File.WriteLine("<failure type="""_failureType_""">")
            do File.WriteLine(##class(%CSP.Page).EscapeHTML(failure))
            do File.WriteLine("</failure>")
            do File.WriteLine("<system-err>"_##class(%CSP.Page).EscapeHTML(failure)_"</system-err>")
         }
         do File.WriteLine("<system-out>"_##class(%CSP.Page).EscapeHTML(systemOut)_"</system-out>")
         do File.WriteLine("</testcase>")
         do File.WriteLine("</testsuite>")
      }
      //do File.WriteLine("</testsuite>")
   }
   do File.WriteLine("</testsuites>")
   quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="test.framework.InterSystems.CManager">
<Description>
*****************************************************

This class comes from InterSystens, provided at the
Global Summit 2015. It was not modified, except for 
the packages name.

*****************************************************
Sightly changed %UnitTest manager.
The main goal is to use use class definitions instead of filesystem for testing</Description>
<Super>%UnitTest.Manager</Super>
<TimeChanged>65455,32453</TimeChanged>
<TimeCreated>62883,71343.008696</TimeCreated>

<Property name="bSQLTransactionEnabled">
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<UDLText name="T">
<Content><![CDATA[
/*-------------------------------------------------------------------------------------------------------
// Modification to be able not to show the ASSERT that passed.
// The modification is simply to add the bShowSuccessfulAssert property, override LogAssert method 
// and change the last else into an Elseif (..bShowSuccessfulAssert = 1).
// The rest of the code was simply reformatted for better readability.
//-------------------------------------------------------------------------------------------------------*/
]]></Content>
</UDLText>

<Property name="bShowSuccessfulAssert">
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Method name="LogAssert">
<FormalSpec>success,action,description,extra</FormalSpec>
<Implementation><![CDATA[
   Set testsuite=i%TheStack(i%TheStack, "suite")
   Set testcase=i%TheStack(i%TheStack, "case")
   Set testmethod = i%TheStack(i%TheStack, "method")
   If testmethod = ""
   {
      Quit
   }
   Set next = $o(^||TempLog(i%TempLogIndex, testsuite, testcase, testmethod, ""), -1) + 1
   Set ^||TempLog(i%TempLogIndex, testsuite, testcase, testmethod, next) = $lb(success, action, description)
   Set line = action _ ":" _ description _ " (" _ ..GetTestState(success) _ ")"
   If 'success,..Display["error"
   {
      Do ..PrintErrorLine(line)
   }
   Elseif (..bShowSuccessfulAssert = 1)
   {
      Do ..PrintLine(line,4)
   }
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
/*-------------------------------------------------------------------------------------------------------
// End modification
//-------------------------------------------------------------------------------------------------------*/
]]></Content>
</UDLText>

<Method name="RunTestSuites">
<Description><![CDATA[
Same as <b>RunTest</b>, but requires three arguments.  These arguments can be null, as ("","","").]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>testspec:%String="",qspec:%String="",userparam:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   Set manager=..%New()
   If manager=$$$NULLOREF Quit %objlasterror
   
   Set sc=$$$qualifierParse("UnitTest",.qspec,.qstruct) q:$$$ISERR(sc) sc
   
   Set manager.Debug=$$$qualifierGetValue(qstruct,"debug")
   Set manager.Display=$s($$$qualifierGetValue(qstruct,"displaylog"):"log",1:"")_","_$s($$$qualifierGetValue(qstruct,"displayerror"):"error",1:"")
   Set manager.UserParam=userparam
   
   Set suite=$p(testspec,":",1)
   ; tests variable is divided by suites
   If $$$qualifierGetValue(qstruct,"recursive")=0 {
      Set tests(suite)=$lb(suite)
   } else {
      Set tests(suite)=$lb(suite)
      Set child=suite_"."
      Set pointCount=$l(child,".")
      For {
         Set child=$o(^oddDEF(child))
         If child'[(suite_".") q
         If '$$issubclassof^%occCompile(child,"%UnitTest.TestCase") Continue
                           
         Set tests($p(child,".",1,pointCount))=$g(tests($p(child,".",1,pointCount)))_$lb(child)
      }
   }
   
   Set zhBegin=$zh
   
   Set suite="" For  Set suite=$o(tests(suite)) Quit:suite=""  Do
   . Do manager.RunOneTestSuite(suite,tests(suite),testspec,.qstruct) 
   Do manager.SaveResult($zh-zhBegin)
   
   Set manager.Display="log,error"
   If $$$qualifierGetValue(qstruct,"run") Do manager.PrintURL()
   
   Quit $$$OK
]]></Implementation>
</Method>

<Method name="RunOneTestSuite">
<FormalSpec>suite:%String,tests:%String,testspec:%String,qstruct</FormalSpec>
<Implementation><![CDATA[
   Set testcase=$p(testspec,":",2)
   Set testmethod=$p(testspec,":",3)
   Do ..PrintLine("===============================================================================",0)
   Do ..PrintLine("Suite: "_suite,0)
   Do ..PrintLine("===============================================================================",0)
   
   Do ..LogStateBegin(suite) Do  Do ..LogStateEnd($zh-zhsBegin)
   . ;
   . Set zhsBegin=$zh
   . If tests="" Do ..PrintLine("No classes found for testsuite "_suite,1) Quit
   . ;
   . If $$$qualifierGetValue(qstruct,"run")=0 Do ..PrintLine("Skipping running testsuite "_suite,1)
   . Else  Do
   . . For i=1:1:$ll(tests) Do
   . . . Set class=$lg(tests,i)
   . . . If testcase'="",class'=testcase Quit
   . . . If '$$issubclassof^%occCompile(class,"%UnitTest.TestCase") Quit
   . . . Do ..RunOneTestCase(suite,class,testmethod)
   . ;
   . Set sc=$$$OK
   Do ..PrintLine("",0)
   
   Quit
]]></Implementation>
</Method>

<Method name="RunOneTestCase">
<FormalSpec>suite:%String,class:%String,test:%String=""</FormalSpec>
<Implementation><![CDATA[
   set ..bSQLTransactionEnabled = $Parameter(class, "bSQLTransactionEnabled")
   TStart:(..bSQLTransactionEnabled)
   do ##super(suite, class, test)
]]></Implementation>
</Method>

<Method name="Cleanup">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   TRollback:(..bSQLTransactionEnabled)
   quit ##super()
]]></Implementation>
</Method>

<Method name="OutputResultsXml">
<ClassMethod>1</ClassMethod>
<FormalSpec>pFileName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   set File=##class(%File).%New(pFileName)
   set i=$o(^UnitTest.Result(""),-1)
   if i="" quit $$$OK // no results
   
   kill ^||TMP ; results global


   set suite="" for {
      set suite=$o(^UnitTest.Result(i,suite))
      quit:suite=""

      set ^||TMP("S",suite,"time")=$lg(^UnitTest.Result(i,suite),2)
      
      set case="" for {
         set case=$o(^UnitTest.Result(i,suite,case))
         quit:case=""
         
         if $i(^||TMP("S",suite,"tests"))
         set ^||TMP("S",suite,"C",case,"time")=$lg(^UnitTest.Result(i,suite),2)

         set method="" for {
            set method=$o(^UnitTest.Result(i,suite,case,method))
            quit:method=""

            set ^||TMP("S",suite,"C",case,"M",method,"time")=$lg(^UnitTest.Result(i,suite,case,method),2)

            set assert="" for {
               set assert=$o(^UnitTest.Result(i,suite,case,method,assert))
               quit:assert=""
               if $i(^||TMP("S",suite,"assertions"))
               if $i(^||TMP("S",suite,"C",case,"assertions"))
               if $i(^||TMP("S",suite,"C",case,"M",method,"assertions"))
               if $lg(^UnitTest.Result(i,suite,case,method,assert))=0 {
                  if $i(^||TMP("S",suite,"failures"))
                  if $i(^||TMP("S",suite,"C",case,"failures"))
                  if $i(^||TMP("S",suite,"C",case,"M",method,"failures"))
                  set ^||TMP("S",suite,"C",case,"M",method,"failure")=$get(^||TMP("S",suite,"C",case,"M",method,"failure"))
                     _$lg(^UnitTest.Result(i,suite,case,method,assert),2)
                     _": "_$lg(^UnitTest.Result(i,suite,case,method,assert),3)
                     _$C(13,10)
               }
            }

            if ($lg(^UnitTest.Result(i,suite,case,method))=0)
            && ('$d(^||TMP("S",suite,"C",case,"M",method,"assertions"))) {
               if $i(^||TMP("S",suite,"failures"))
               if $i(^||TMP("S",suite,"C",case,"failures"))
               if $i(^||TMP("S",suite,"C",case,"M",method,"failures"))
               set ^||TMP("S",suite,"C",case,"M",method,"failure")=$get(^||TMP("S",suite,"C",case,"M",method,"failure"))
                  _$lg(^UnitTest.Result(i,suite,case,method),3)
                  _": "_$lg(^UnitTest.Result(i,suite,case,method),4)
                  _$C(13,10)
            }

         }
         
         if $lg(^UnitTest.Result(i,suite,case))=0
         && ('$d(^||TMP("S",suite,"C",case,"M"))) {
            if $i(^||TMP("S",suite,"failures"))
            if $i(^||TMP("S",suite,"C",case,"failures"))
            if $i(^||TMP("S",suite,"C",case,"M",case,"failures"))
            set ^||TMP("S",suite,"C",case,"M",case,"failure")=$get(^||TMP("S",suite,"C",case,"M",case,"failure"))
               _$lg(^UnitTest.Result(i,suite,case),3)
               _": "_$lg(^UnitTest.Result(i,suite,case),4)
               _$C(13,10)
         }

      }
   }
   
   do File.Open("WSN")
   do File.WriteLine("<?xml version=""1.0"" encoding=""UTF-8"" ?>")
   do File.WriteLine("<testsuites>")
   set suite="" for {
      set suite=$o(^||TMP("S",suite))
      quit:suite=""

      do File.Write("<testsuite")
      do File.Write(" name="""_$zcvt(suite,"O","XML")_"""")
      do File.Write(" assertions="""_$g(^||TMP("S",suite,"assertions"))_"""")
      do File.Write(" time="""_$g(^||TMP("S",suite,"time"))_"""")
      do File.Write(" tests="""_$g(^||TMP("S",suite,"tests"))_"""")
      do File.WriteLine(">")

      set case="" for {
         set case=$o(^||TMP("S",suite,"C",case))
         quit:case=""

         do File.Write("<testsuite")
         do File.Write(" name="""_$zcvt(case,"O","XML")_"""")
         do File.Write(" assertions="""_$g(^||TMP("S",suite,"C",case,"assertions"))_"""")
         do File.Write(" time="""_$g(^||TMP("S",suite,"C",case,"time"))_"""")
         do File.Write(" tests="""_$g(^||TMP("S",suite,"C",case,"tests"))_"""")
         do File.WriteLine(">")

         
         set method="" for {
            set method=$o(^||TMP("S",suite,"C",case,"M",method))
            quit:method=""

            do File.Write("<testcase")
            do File.Write(" name="""_$zcvt(method,"O","XML")_"""")
            do File.Write(" assertions="""_$g(^||TMP("S",suite,"C",case,"M",method,"assertions"))_"""")
            do File.Write(" time="""_$g(^||TMP("S",suite,"C",case,"M",method,"time"))_"""")
            do File.WriteLine(">")
            if $d(^||TMP("S",suite,"C",case,"M",method,"failure")) {
               do File.Write("<failure type=""cache-error"" message=""Cache Error"">")
               do File.Write($zcvt(^||TMP("S",suite,"C",case,"M",method,"failure"),"O","XML"))
               do File.WriteLine("</failure>")
            }
            do File.WriteLine("</testcase>")
         }
         do File.WriteLine("</testsuite>")
      }
      do File.WriteLine("</testsuite>")
   }
   do File.WriteLine("</testsuites>")

   do File.Close()
   kill ^||TMP
   quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="test.framework.InterSystems.CUnitTest">
<Description>
*****************************************************

This class comes from InterSystens, provided at the
Global Summit 2015. It was not modified, except for 
the packages name.

*****************************************************
This is an abstract Requirement class.
Requirement implement classic Cache's %UnitTest functionality.
Also it may be runned through web browser.
Each requirement may also be represented as a CSP page.
After execution, requirement results are stored in ^UnitTest.Result global.</Description>
<Super>%UnitTest.TestCase,%CSP.Page</Super>
<TimeChanged>65455,32450</TimeChanged>
<TimeCreated>62883,70697.280223</TimeCreated>

<Parameter name="SrcVer">
<Description>
This Parameter is updated by Perforce</Description>
<Default>$Id: //trak/main/projects/PATHWAY/internal/cls/UnitTest/Abstract.xml#6 $</Default>
</Parameter>

<Parameter name="TITLE">
<Description>
Your test title</Description>
<Type>%String</Type>
</Parameter>

<Parameter name="GlobalsMaxMethod">
<Description>
default maximum global accesses for a single row based method call
can overide per class or pur explicitly in each method call</Description>
<Default>100</Default>
</Parameter>

<Parameter name="GlobalsMaxQuery">
<Description>
default maximum global accesses for a query
can overide per class or pur explicitly in each method call</Description>
<Default>1000</Default>
</Parameter>

<Method name="OnPage">
<Description>
This method is used to display a test page.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
   // 2016.1 : We need to clear %session lock before running tests in a
   // "web page mode" without errors.
   lock
   do ##class(test.framework.InterSystems.CFormatter).Run(..%ClassName(1))
   Quit $$$OK
]]></Implementation>
</Method>

<Method name="Run">
<Description>
Run this specific test (in debug mode)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>qualifiers:%String=""</FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   set sc=##class(test.framework.InterSystems.CManager).RunTest(..%ClassName(1),"/recursive=0"_qualifiers)
   quit sc
]]></Implementation>
</Method>

<Method name="RunRecursive">
<Description>
Run this test and all its children</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>qualifiers:%String=""</FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   set sc=##class(test.framework.InterSystems.CManager).RunTest(..%ClassName(1),"/recursive=1"_qualifiers)
   quit sc
]]></Implementation>
</Method>

<Method name="Execute">
<Description>
Execute expression using current object's context</Description>
<FormalSpec>expr</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
   n %result
   x "s %result="_expr
   quit %result
]]></Implementation>
</Method>

<Method name="LogResult">
<Description>
Log execution HTML result. Now it is stored as a log message.</Description>
<FormalSpec>result</FormalSpec>
<Implementation><![CDATA[
   set oldDisplay=..Manager.Display
   set ..Manager.Display=""
   do ..LogMessage($g(result))
   set ..Manager.Display=oldDisplay
   quit
]]></Implementation>
</Method>

<Method name="GetLastResult">
<Description>
Get last test result instance id, dateTime, status, duration and HTML
All this information is stored in ^UnitTest.Result</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&dateTime,&status,&duration,&html,&suite]]></FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
   set (dateTime,status,duration,html,suite)=""
   set name=..%ClassName(1)
   &sql(select Duration, TestSuite->TestInstance, TestSuite->Name, TestSuite->TestInstance->DateTime
      into :qDuration, :qInstance, :qSuite, :qDateTime
      from %IGNOREINDICES %UnitTest_Result.TestCase.idxName %UnitTest_Result.TestCase
      where Name=:name
      order by TestSuite->TestInstance DESC)
   if SQLCODE quit ""
   set dateTime=qDateTime
   set duration=qDuration
   set status=##class(%UnitTest.Report).GetTestStatus($znspace, qInstance, qSuite, name)
   set htmlIndex=$o(^UnitTest.Result(qInstance, qSuite, name, "TestRequirement",""),-1)-1
   set html=$lg($g(^UnitTest.Result(qInstance, qSuite, name, "TestRequirement",htmlIndex)),3)
   set suite=qSuite
   quit qInstance
]]></Implementation>
</Method>

<Method name="AssertEqualsViaMacro">
<FormalSpec>autoquoted="",value1="",value2="",description=""</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
   Set manager=r%Manager
   Set description=$g(description)_": "_value1_"=="_value2_" in "_..ParseAutoQuoted(autoquoted,"equals")
   Set success=value1=value2
   Do manager.LogAssert(success,"AssertEquals",description)
   If 'success&&'..Debug Quit $$$ERROR(5001,description)
   If 'success Break
   Quit $$$OK
]]></Implementation>
</Method>

<Method name="AssertNotEqualsViaMacro">
<FormalSpec>autoquoted="",value1="",value2="",description=""</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
   s success=##super(autoquoted, value1, value2, description)
   i 'success quit $$$ERROR(5001,description_": "_value1_"=="_value2_" in "_autoquoted)
   q $$$OK
]]></Implementation>
</Method>

<Method name="AssertTrueViaMacro">
<FormalSpec>autoquoted="",value="",description=""</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
   s success=##super(autoquoted, value, description)
   i 'success quit $$$ERROR(5001,description_": "_value_"!=TRUE in "_autoquoted)
   q $$$OK
]]></Implementation>
</Method>

<Method name="AssertNotTrueViaMacro">
<FormalSpec>autoquoted="",value="",description=""</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
   s success=##super(autoquoted, value, description)
   i 'success quit $$$ERROR(5001,description_": "_value_"== TRUE in "_autoquoted)
   q $$$OK
]]></Implementation>
</Method>

<Method name="AssertStatusOKViaMacro">
<FormalSpec>autoquoted="",status="",description=""</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
   s success=##super(autoquoted, status, .description)
   i 'success quit $$$ERROR(5001,description_" in "_autoquoted)
   q $$$OK
]]></Implementation>
</Method>

<Method name="AssertStatusNotOKViaMacro">
<FormalSpec>autoquoted="",status="",description=""</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
   s success=##super(autoquoted, status, description)
   i 'success quit $$$ERROR(5001,description_" IS OK in "_autoquoted)
   q $$$OK
]]></Implementation>
</Method>

<Method name="AssertStatusEqualsViaMacro">
<FormalSpec>autoquoted="",value1="",value2="",description=""</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
   s success=##super(autoquoted, value1, value2, description)
   i 'success quit $$$ERROR(5001,description_": STATUS NOT EQUAL in "_autoquoted)
   q $$$OK
]]></Implementation>
</Method>

<Method name="AssertFilesSameViaMacro">
<FormalSpec>autoquoted,file1,file2,description</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
   s success=##super(autoquoted, file1, file2, description)
   i 'success quit $$$ERROR(5001,description_": "_file1_"!="_file2_" in "_autoquoted)
   q $$$OK
]]></Implementation>
</Method>

<Method name="StringEquals">
<Description>
Run a class method and:
1. compare the result against an expected value, this can be a single value "A" or a list $lb("A","B","C")
2. compare the global count against an expected maximum
itmid can uniquely identify a specific test in list within a test method e.g. #1.1,   #1.2  etc
output informative information about the code that was run, the actual value and the expected value</Description>
<Final>1</Final>
<FormalSpec>itmid,expectedvalue,globalsmax,classname,methodname,args...</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   If +$g(globalsmax)=0 set globalsmax=..#GlobalsMaxMethod
   Set tResult="-99999"
   
   try {
      Set pTime=$zh
      Set pLines=$zu(67,8,$j)
      Set pGlobals=$zu(67,9,$j)
      
      If $g(args)="" Set tResult=$classmethod(classname,methodname)
      If $g(args)=1 Set tResult=$classmethod(classname,methodname,args(1))
      If $g(args)=2 Set tResult=$classmethod(classname,methodname,args(1),args(2))
      If $g(args)=3 Set tResult=$classmethod(classname,methodname,args(1),args(2),args(3))
      If $g(args)=4 Set tResult=$classmethod(classname,methodname,args(1),args(2),args(3),args(4))
      If $g(args)=5 Set tResult=$classmethod(classname,methodname,args(1),args(2),args(3),args(4),args(5))
      If $g(args)=6 Set tResult=$classmethod(classname,methodname,args(1),args(2),args(3),args(4),args(5),args(6))
      If $g(args)=7 Set tResult=$classmethod(classname,methodname,args(1),args(2),args(3),args(4),args(5),args(6),args(7))
      If $g(args)=8 Set tResult=$classmethod(classname,methodname,args(1),args(2),args(3),args(4),args(5),args(6),args(7),args(8))
      //no reason this is limited to 8 - at the tme of writing this was more than enough for the ct classes

      Set pTime=$zh-pTime
      Set pLines=$zu(67,8,$j)-pLines
      Set pGlobals=$zu(67,9,$j)-pGlobals
   } catch(e) {
      //try and void the pain of hidden errors and put them
      Set tResult=e.Name_" "_e.Location

      Set pTime=""
      Set pLines=""
      Set pGlobals=""
   }
   

   //if both are lists should use $listsame... but for now format as strings
   if $listvalid(expectedvalue)&&(expectedvalue'="") set expectedvalue="["_$lts(expectedvalue,",")_"]"
   if $listvalid(tResult)&&(tResult'="") set tResult="["_$lts(tResult,",")_"]"

   set argsdisplay=""
   for j=1:1:$g(args) set argsdisplay=argsdisplay_$s(argsdisplay'="":",",1:"")_""""_args(j)_""""
   Do $$$AssertEquals(tResult,expectedvalue,"##Class("_classname_")."_methodname_"("_argsdisplay_") ["_itmid_"] Return Value: '"_tResult_"' Expected: '"_expectedvalue_"'")

   //less than or equals
   Do $$$AssertTrue(pGlobals'>globalsmax,"##Class("_classname_")."_methodname_"("_argsdisplay_") ["_itmid_"] Global Count: '"_pGlobals_"' Expected: '<="_globalsmax_"'")
]]></Implementation>
</Method>

<Method name="QueryEquals">
<Description>
Run a class query and:
1. compare the result against an expected value, this is a list of lists (one list per expected row)
  the comaprison will only check up to the first five rows returned
2. compare the global count against an expected maximum
itmid can uniquely identify a specific test in list within a test method e.g. #1.1,   #1.2  etc
output informative information about the code that was run, the actual value and the expected value</Description>
<Final>1</Final>
<FormalSpec>itmid,expectedvalue,globalsmax,classname,queryname,args...</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   If +$g(globalsmax)=0 set globalsmax=..#GlobalsMaxQuery
   Set tResult=$lb("-99999")
   try {
      Set pTime=$zh
      Set pLines=$zu(67,8,$j)
      Set pGlobals=$zu(67,9,$j)
      
      Set rs=##Class(%ResultSet).%New()
      Set rs.ClassName=classname
      Set rs.QueryName=queryname
      If $g(args)="" Set sc=rs.Execute()
      If $g(args)=1 Set sc=rs.Execute(args(1))
      If $g(args)=2 Set sc=rs.Execute(args(1),args(2))
      If $g(args)=3 Set sc=rs.Execute(args(1),args(2),args(3))
      If $g(args)=4 Set sc=rs.Execute(args(1),args(2),args(3),args(4))
      If $g(args)=5 Set sc=rs.Execute(args(1),args(2),args(3),args(4),args(5))
      If $g(args)=6 Set sc=rs.Execute(args(1),args(2),args(3),args(4),args(5),args(6))
      If $g(args)=7 Set sc=rs.Execute(args(1),args(2),args(3),args(4),args(5),args(6),args(7))
      If $g(args)=8 Set sc=rs.Execute(args(1),args(2),args(3),args(4),args(5),args(6),args(7),args(8))
      //no reason this is limited to 8 - at the tme of writing this was more than enough for the ct classes

      If $$$ISERR(sc) Do $system.OBJ.DisplayError(sc)
      Set colcount=rs.GetColumnCount()
      Set tResult=""
      //test only first 5 rows
      For j=1:1:5 {
         If 'rs.Next() Quit
         
         Set valx=""
         for jj=1:1:colcount Set valx=valx_$lb(rs.GetData(jj))
         Set tResult=tResult_$lb(valx)
      }
      Do rs.Close()

      Set pTime=$zh-pTime
      Set pLines=$zu(67,8,$j)-pLines
      Set pGlobals=$zu(67,9,$j)-pGlobals

   } catch(e) {
      //try and void the pain of hidden errors and put them
      Set tResult=e.Name_" "_e.Location

      Set pTime=""
      Set pLines=""
      Set pGlobals=""
   }
   

   set argsdisplay=""
   for j=1:1:$g(args) set argsdisplay=argsdisplay_$s(argsdisplay'="":",",1:"")_$s($d(args(j)):""""_args(j)_"""",1:"")

   Do $$$AssertTrue($listsame(tResult,expectedvalue),"##Class("_classname_")."_queryname_"("_argsdisplay_") ["_itmid_"] Return Value: '"_..ListOfListToDisplay(tResult)_"' Expected: '"_..ListOfListToDisplay(expectedvalue)_"'")

   //less than or equals
   Do $$$AssertTrue(pGlobals'>globalsmax,"##Class("_classname_")."_queryname_"("_argsdisplay_") ["_itmid_"] Global Count: '"_pGlobals_"' Expected: '<="_globalsmax_"'")
]]></Implementation>
</Method>

<Method name="ListOfListToDisplay">
<Description>
output formatter to display a List of lists</Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<FormalSpec>listoflist</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
   if '$listvalid(listoflist) Quit listoflist
   Set tResult=""
   for j=1:1:$ll(listoflist) {
      Set tResult=tResult_$s(tResult'="":",",1:"")_"$lb("""_$lts($lg(listoflist,j),""",""")_""")"
   }
   Quit $s(tResult'="":"$lb("_tResult_")",1:tResult)
]]></Implementation>
</Method>
</Class>


<Class name="test.framework.InterSystems.CUnitTestTransaction">
<Description>
*****************************************************

This class comes from InterSystens, provided at the
Global Summit 2015. It was not modified, except for 
the packages name.

*****************************************************
This is a class for tests that change transactional data.
It's run within a transaction which is rolled back at the end.</Description>
<Super>test.framework.InterSystems.CUnitTest</Super>
<TimeChanged>65455,32451</TimeChanged>
<TimeCreated>62883,71852.951342</TimeCreated>

<Method name="OnBeforeOneTest">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 TStart
 Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnAfterOneTest">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 TRollback
 Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="test.framework.Mock.CCustomFunctionParamValidator">
<Super>%RegisteredObject,test.framework.Mock.IMockParamValidator</Super>
<TimeChanged>65455,32451</TimeChanged>
<TimeCreated>63890,58067.960125</TimeCreated>

<Property name="objectReference">
<Type>%RegisteredObject</Type>
</Property>

<Property name="strFunctionName">
<Type>%String</Type>
</Property>

<Method name="%OnNew">
<Internal>1</Internal>
<FormalSpec>objectReference:%RegisteredObject,strFunctionName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   set ..objectReference = objectReference
   set ..strFunctionName = strFunctionName

   quit $$$OK
]]></Implementation>
</Method>

<Method name="Validate">
<Internal>1</Internal>
<FormalSpec>object</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   #dim status As %Status = $$$ERROR("Function or object not defined")
   
   if ($IsObject(..objectReference) && (..strFunctionName '= ""))
   {
      try
      {
         do $Method(..objectReference, ..strFunctionName, object)
         set status = $$$OK
      }
      catch
      {
         set status = $ZERROR
      }
   }
   
   quit status
]]></Implementation>
</Method>

<Method name="GetAssertDescription">
<Internal>1</Internal>
<FormalSpec>nIndex:%Integer,strMethodName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
   quit "Unable to invoke method """ _ ..strFunctionName _ "()"" on object " _ ..objectReference _
        " to validate parameter(" _ nIndex _ ") for method: " _ strMethodName
]]></Implementation>
</Method>
</Class>


<Class name="test.framework.Mock.CExpectation">
<Super>%RegisteredObject</Super>
<TimeChanged>65455,32451</TimeChanged>
<TimeCreated>63854,41673.909456</TimeCreated>

<Property name="instance">
<Type>%RegisteredObject</Type>
<Private>1</Private>
</Property>

<Property name="strMethodName">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="lstParameters">
<Type>%ListOfDataTypes</Type>
<Private>1</Private>
</Property>

<Property name="nTimes">
<Type>%Integer</Type>
<InitialExpression>1</InitialExpression>
<Private>1</Private>
</Property>

<Property name="returnValue">
<Description>
No As since it can be a DataType or an object which have no common base.</Description>
<Private>1</Private>
</Property>

<Property name="throwValue">
<Private>1</Private>
</Property>

<Method name="%OnNew">
<Internal>1</Internal>
<FormalSpec>instance:%RegisteredObject,strMethodName:%String,lstParameters:%ListOfDataTypes</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   set ..instance = instance
   set ..strMethodName = strMethodName
   set ..lstParameters = lstParameters
   
   quit $$$OK
]]></Implementation>
</Method>

<Method name="Times">
<Description>
Sets the number of time to expect this method in a row. Returns $THIS to enable chaining.
Usage example: do ..expect(mock.call(param1, param2, param3)).andReturn("return").times(1)
See also: test.framework.Mock.CMockManager</Description>
<FormalSpec>nTimes:%Integer</FormalSpec>
<ReturnType>test.framework.Mock.CExpectation</ReturnType>
<Implementation><![CDATA[
   set ..nTimes = nTimes
   
   quit $THIS
]]></Implementation>
</Method>

<Method name="AndReturn">
<Description>
Specifies the return value of this expectation. Returns $THIS to enable chaining.
Usage example: do ..expect(mock.call(param1, param2, param3)).andReturn("return").times(1)
See also: test.framework.Mock.CMockManager</Description>
<FormalSpec>returnValue</FormalSpec>
<ReturnType>test.framework.Mock.CExpectation</ReturnType>
<Implementation><![CDATA[
   set ..returnValue = returnValue
   quit $THIS
]]></Implementation>
</Method>

<Method name="AndThrow">
<Description>
Specifies the return value of this expectation. Returns $THIS to enable chaining.
Usage example: do ..expect(mock.call(param1, param2, param3)).andReturn("return").times(1)
See also: test.framework.Mock.CMockManager</Description>
<FormalSpec>returnValue</FormalSpec>
<ReturnType>test.framework.Mock.CExpectation</ReturnType>
<Implementation><![CDATA[
   set ..throwValue = returnValue
   quit $THIS
]]></Implementation>
</Method>

<Method name="GetInstance">
<Internal>1</Internal>
<ReturnType>%RegisteredObject</ReturnType>
<Implementation><![CDATA[   quit ..instance
]]></Implementation>
</Method>

<Method name="GetMethodName">
<Internal>1</Internal>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[   quit ..strMethodName
]]></Implementation>
</Method>

<Method name="GetLstParameters">
<Internal>1</Internal>
<ReturnType>%ListOfDataTypes</ReturnType>
<Implementation><![CDATA[   quit ..lstParameters
]]></Implementation>
</Method>

<Method name="GetTimes">
<Internal>1</Internal>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[   quit ..nTimes
]]></Implementation>
</Method>

<Method name="DecrementTimes">
<Internal>1</Internal>
<Implementation><![CDATA[   set ..nTimes = ..nTimes - 1
]]></Implementation>
</Method>

<Method name="GetReturnValue">
<Description>
Since the return type is unknown we cant't specify %RegisteredObject or %DataType as the return value.</Description>
<Internal>1</Internal>
<Implementation><![CDATA[   quit ..returnValue
]]></Implementation>
</Method>

<Method name="GetThrowValue">
<Description>
Since the return type is unknown we cant't specify %RegisteredObject or %DataType as the return value.</Description>
<Internal>1</Internal>
<Implementation><![CDATA[   quit ..throwValue
]]></Implementation>
</Method>
</Class>


<Class name="test.framework.Mock.CIsNotEqualParamValidator">
<Super>%RegisteredObject,test.framework.Mock.IMockParamValidator</Super>
<TimeChanged>65455,32451</TimeChanged>
<TimeCreated>63929,38500.116613</TimeCreated>

<Property name="itemToCompare">
</Property>

<Method name="%OnNew">
<Internal>1</Internal>
<FormalSpec>itemToCompare</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   set ..itemToCompare = itemToCompare

   quit $$$OK
]]></Implementation>
</Method>

<Method name="Validate">
<Internal>1</Internal>
<FormalSpec>item</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   #dim status As %Status = $$$ERROR("Equal")
   
   if ($data(item) && $IsObject(item) && $IsObject(..itemToCompare))
   {
      try
      {
         set status = 'item.IsEqual(..itemToCompare)
      }
      catch
      {
         if (item.%Extends("%Collection.AbstractList") && ..itemToCompare.%Extends("%Collection.AbstractList"))
         {
            set:('##class(chs.Fw.EnsExt.Lib.CClassTools).IsEqualList(item, ..itemToCompare)) status = $$$OK
         }
         elseif(..itemToCompare '= item)
         {
            set status = $$$OK
         }
         else
         {
            set status = $$$ERROR("Items are the same.")
         }
      }
   }
   // Else it is a datatype.
   elseif (..itemToCompare '= item)
   {
      set status = $$$OK
   }
   
   quit status
]]></Implementation>
</Method>

<Method name="GetAssertDescription">
<Internal>1</Internal>
<FormalSpec>nIndex:%Integer,strMethodName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  
   quit "Expected Parameter(" _ nIndex _ ") Not Equal for method: " _ strMethodName _ " Got equal"
]]></Implementation>
</Method>
</Class>


<Class name="test.framework.Mock.CMockBase">
<StorageStrategy/>
<Super>%RegisteredObject</Super>
<TimeChanged>65455,32451</TimeChanged>
<TimeCreated>63854,30397.336751</TimeCreated>

<Property name="mockManager">
<Type>test.framework.Mock.CMockManager</Type>
<Private>1</Private>
</Property>

<Method name="%OnNew">
<Internal>1</Internal>
<FormalSpec>mockManager:test.framework.Mock.CMockManager</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   set ..mockManager = mockManager
   
   quit $$$OK
]]></Implementation>
</Method>

<Method name="%DispatchMethod">
<Description>
Since the return type is unknown we cant't specify %RegisteredObject or %DataType as the return value.</Description>
<Internal>1</Internal>
<FormalSpec>strMethod:%String,args...</FormalSpec>
<Implementation><![CDATA[
   #dim returnValue
   #dim lstparams = ..TransformArgsToList(args...)
   if (..mockManager.IsInReplayMode())
   {
      set returnValue = ..mockManager.MethodCalled($THIS,
                                                   strMethod,
                                                  .lstparams)
                                                  
      #dim nIndex As %Integer = 0
      for nIndex = 1:1:$get(args, 0)
      {
         set args(nIndex) = lstparams.GetAt(nIndex)
      }
   }
   else
   {
      set returnValue = ..mockManager.CreateExpectation($THIS,
                                                        strMethod,
                                                        lstparams)
   }
   
   quit returnValue
]]></Implementation>
</Method>

<Method name="%DispatchGetProperty">
<Description>
Is used to get the value of an unknown property.</Description>
<FormalSpec>Property:%String</FormalSpec>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[   quit ..%DispatchMethod(Property_"Get")
]]></Implementation>
</Method>

<Method name="%DispatchSetProperty">
<Description>
is used to set the value of an unknown property.</Description>
<FormalSpec>Property:%String,Val</FormalSpec>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[   quit ..%DispatchMethod(Property_"Set", Val)
]]></Implementation>
</Method>

<Method name="TransformArgsToList">
<ClassMethod>1</ClassMethod>
<FormalSpec>args...</FormalSpec>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[
   // Create a %ListOfDataTypes even though it may contain objects. This has been tested and works.
   #dim listArgs = ##class(%ListOfDataTypes).%New()
   #dim i AS %Integer
   for i = 1 : 1 : $get(args, 0)
   {
      do listArgs.Insert($get(args(i)))
   }
   
   quit listArgs
]]></Implementation>
</Method>
</Class>


<Class name="test.framework.Mock.CMockByRefParam">
<Super>%RegisteredObject</Super>
<TimeChanged>65455,32451</TimeChanged>
<TimeCreated>63869,52284.137835</TimeCreated>

<Property name="expectedValue">
<Description>
No As ... on these properties so they can be a dataType or an object (which have no common base).</Description>
</Property>

<Property name="replaceByValue">
</Property>

<Method name="%OnNew">
<Internal>1</Internal>
<FormalSpec>expectedValue,replaceByValue</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   set ..expectedValue = expectedValue
   set ..replaceByValue = replaceByValue
   quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="test.framework.Mock.CMockManager">
<Description>
This is the main class for the mocking framework. Mocks are objects pre-programmed with expectations which
form a specification of the calls they are expected to receive. They are used to replace a class injected
dependencies when testing that class. Using mocks you can make sure the which methods are called on a
dependency, validate parameters passed to each method an control the return value.

Usage example :
In this example we'll test the method Test() from class A. Class A has 2 injected dependencies which are class B and C.
The Test method on class A calls the Name() method on class B followed by a Location() method on class C and returns the
concatenation of both returned value.

First create the mocks:
set mockB = ..CreateMock()
set mockC = ..CreateMock())

Now create the test object:
set objectA = ##class("Name.Of.Package.A").%New(mockB, mockC)

Now do the expectation:
do ..Expect(mockB.Name()).AndReturn("Name")
do ..Expect(mockC.Location("Name")).AndReturn("Location")

Now go in test mode:
do ..ReplayAllMocks()

Do the test
do $$$AssertEquals(objectA.Test(), "Name" _ "Location")

Finally verify the mocks:
do ..VerifyAllMocks()

For more example see UnitTestsMock.CMockTest or tests that use the ..
See also: test.framework.Mock.CExpectation</Description>
<Abstract>1</Abstract>
<IncludeCode>%outUnitTest</IncludeCode>
<TimeChanged>65455,32451</TimeChanged>
<TimeCreated>63854,41660.543052</TimeCreated>

<Property name="bInReplayMode">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Private>1</Private>
</Property>

<Property name="lstExpectation">
<Type>%ListOfObjects</Type>
<Private>1</Private>
</Property>

<Property name="lstOfCreatedClass">
<Type>%ListOfDataTypes</Type>
<Private>1</Private>
</Property>

<Method name="CreateMock">
<Description>
This methods creates a mock object extending CMockBase and the provided interface and returns it.
strInterfaceName: Name of the interface with the package information.
Usage example: set mock = ..CreateMock()</Description>
<FormalSpec>strInterfaceName:%String=""</FormalSpec>
<ReturnType>test.framework.Mock.CMockBase</ReturnType>
<Implementation><![CDATA[
   #dim returnClass = $$$NULLOREF
   if (strInterfaceName '= "")
   {
      #dim strNewClassName As %String = "UnitTests." _ strInterfaceName _ "Mock"

      #dim strExtends As %String = strInterfaceName _ ",test.framework.Mock.CMockBase"
      if ($$$ISOK(..CreateClass(strNewClassName, strExtends)))
      {
         do ..lstOfCreatedClass.Insert(strNewClassName)
         set returnClass = $ClassMethod(strNewClassName, "%New", $THIS)
      }
   }
   else
   {
      set returnClass = ##class(test.framework.Mock.CMockBase).%New($THIS)
   }
   quit returnClass
]]></Implementation>
</Method>

<Method name="Expect">
<Description>
Adds an expectation to the list. Return the parameter to enable chaining.
expectation: The expectation should not be created directly but by calling a method on the mock.
Usage example: do ..expect(mock.call(param1, param2, param3)).andReturn("return").times(1)
See also: test.framework.Mock.CExpectation.</Description>
<FormalSpec>expectation:test.framework.Mock.CExpectation</FormalSpec>
<ReturnType>test.framework.Mock.CExpectation</ReturnType>
<Implementation><![CDATA[
   do ..lstExpectation.Insert(expectation)
   quit expectation
]]></Implementation>
</Method>

<Method name="ReplayAllMocks">
<Description>
Sets the mockmanager in test mode. Must be called after the Expect but before doing the actual test.
Usage example: do ..ReplayAllMocks()</Description>
<Implementation><![CDATA[   set ..bInReplayMode = 1
]]></Implementation>
</Method>

<Method name="VerifyAllMocks">
<Description>
Verifies that all expected methods have been called.
Usage example: do ..VerifyAllMocks()</Description>
<Implementation><![CDATA[
   do $$$AssertEquals(..lstExpectation.Count(), 0, "Expectation list not empty")
   
   #Dim strFirstUnconsumedQuery As %String = ""
   do $$$AssertNotTrue(..IsUnconsumedResultSetLeft(.strFirstUnconsumedQuery), "Some defined ResultSet were not consumed (" _ strFirstUnconsumedQuery _ ")")
   
   set ..bInReplayMode = 0
   
   do ..CleanUp()
]]></Implementation>
</Method>

<Method name="NotNullObject">
<Description>
Creates a CNotNullObjectMockParamValidator. Use this during an expect when you don't know the specific
value of a parameter. This will validate it is the correct class and is not null.
strClassName: Name of the exected class with the package information.
Usage example: do ..expect(mock.call(..NotNullObject("%Stream.GlobalCharacter"), param2, param3))</Description>
<FormalSpec>strClassName:%String</FormalSpec>
<ReturnType>test.framework.Mock.IMockParamValidator</ReturnType>
<Implementation><![CDATA[   quit ##class(test.framework.Mock.CNotNullObjectMockParamValidator).%New(strClassName)
]]></Implementation>
</Method>

<Method name="IsEqualObject">
<Description>
Creates a CIsEqualObjectParamValidator. Use this to validate that two objects are equals. Note that
for this method to work you need to have a IsEqual(object) method on your object. This parameter validator
will simply call that method.</Description>
<FormalSpec>object:%RegisteredObject</FormalSpec>
<Implementation><![CDATA[   quit ##class(test.framework.Mock.CIsEqualObjectParamValidator).%New(object)
]]></Implementation>
</Method>

<Method name="IsNotEqual">
<Description>
Creates a CIsNotEqualParamValidator. Use this to validate that two datatypes objects are notequals. Note that
for this method to work on objects you need to have a IsEqual(object) method on your object.</Description>
<FormalSpec>objectorDatatype</FormalSpec>
<ReturnType>test.framework.Mock.CIsNotEqualParamValidator</ReturnType>
<Implementation><![CDATA[   quit ##class(test.framework.Mock.CIsNotEqualParamValidator).%New(objectorDatatype)
]]></Implementation>
</Method>

<Method name="UseCustomFunctionValidation">
<FormalSpec>object:%RegisteredObject,strMethodName:%String</FormalSpec>
<ReturnType>test.framework.Mock.CCustomFunctionParamValidator</ReturnType>
<Implementation><![CDATA[   quit ##class(test.framework.Mock.CCustomFunctionParamValidator).%New(object, strMethodName)
]]></Implementation>
</Method>

<Method name="ByRefParam">
<Description>
Creates a CMockByRefParam. Use this with ByRef parameters during an expect.
expectedValue: Expected value.
replaceByValue: Value to set in the parameter.
Usage example: do ..expect(mock.call(..ByRefParam("Expected", "ReplacedBy"), param2, param3))</Description>
<FormalSpec>expectedValue,replaceByValue</FormalSpec>
<ReturnType>test.framework.Mock.CMockByRefParam</ReturnType>
<Implementation><![CDATA[   quit ##class(test.framework.Mock.CMockByRefParam).%New(expectedValue, replaceByValue)
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
/**********************************************
      Internal methods do not call
***********************************************/
]]></Content>
</UDLText>

<Method name="CleanUp">
<Internal>1</Internal>
<Implementation><![CDATA[
   
   #dim i As %Integer = 0
   for i = 1:1:..lstOfCreatedClass.Count()
   {
      do ..DeleteClass(..lstOfCreatedClass.GetAt(i))
   }
   do ..lstOfCreatedClass.Clear()
   
   // Also cleanup every defined ResultSet Overrides
   kill ^||CResultSetTools
   kill ^CResultSetTools

   set ..bInReplayMode = 0
   
   do $$$AssertEquals(..lstExpectation.Count(), 0, "Expectation list not empty")
   do ..lstExpectation.Clear()
]]></Implementation>
</Method>

<Method name="CreateExpectation">
<Internal>1</Internal>
<FormalSpec>instance:test.framework.Mock.CMockBase,strMethodName:%String,lstParams:%ListOfDataTypes</FormalSpec>
<ReturnType>test.framework.Mock.CExpectation</ReturnType>
<Implementation><![CDATA[   quit ##class(test.framework.Mock.CExpectation).%New(instance, strMethodName, lstParams)
]]></Implementation>
</Method>

<Method name="MethodCalled">
<Description>
Since the return type is unknown we cant't specify %RegisteredObject or %DataType as the return value.</Description>
<Internal>1</Internal>
<FormalSpec><![CDATA[instance:test.framework.Mock.CMockBase,strMethodName:%String,&lstParams:%ListOfDataTypes]]></FormalSpec>
<Implementation><![CDATA[
   #dim returnValue = $$$NULLOREF
   
   #dim expectation As test.framework.Mock.CExpectation = ..GetNextExpectation(instance, strMethodName)
   if (expectation '= $$$NULLOREF)
   {
      if ($$$ISOK(..ValidateMethodCalled(expectation, instance, strMethodName, lstParams)))
      {
         do ..DecrementExpectationTimes(expectation)
         
         do ..ProcessParameters(expectation, .lstParams, strMethodName)

         set throwValue = expectation.GetThrowValue()
         
         if $ISOBJECT(throwValue) {
	         throw throwValue
         }
         
         set returnValue = expectation.GetReturnValue()            
      }
   }
   
   quit returnValue
]]></Implementation>
</Method>

<Method name="IsInReplayMode">
<Internal>1</Internal>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[   quit ..bInReplayMode
]]></Implementation>
</Method>

<Method name="SetMockResultSet">
<Description>
Used to retrieve a resultSet obtained by "%New". Used for Tests purpose.</Description>
<FormalSpec>strQueryName:%String,xDataResultSetName:%String,bPrivateProcessGlobal:%Boolean=1</FormalSpec>
<Implementation><![CDATA[
   #Dim nextUnusedIndex As %String = ""
   
   // NOTE : Using the ^|| global prefix creates a "process private global", 
   //        automatically deleted when the process execution ends.
   if (bPrivateProcessGlobal)
   {
      set nextUnusedIndex = ($Order(^||CResultSetTools("_" _ strQueryName, ""), -1) + 1)
      set ^||CResultSetTools("_" _ strQueryName, nextUnusedIndex) = xDataResultSetName
   }
   else
   {
      set nextUnusedIndex = ($Order(^CResultSetTools("_" _ strQueryName, ""), -1) + 1)
      set ^CResultSetTools("_" _ strQueryName, nextUnusedIndex) = xDataResultSetName
   }
]]></Implementation>
</Method>

<Method name="GetMockResultSet">
<ClassMethod>1</ClassMethod>
<FormalSpec>strQueryName:%String=""</FormalSpec>
<ReturnType>%ResultSet</ReturnType>
<Implementation><![CDATA[
   #Dim rs As %ResultSet = $$$NULLOREF
   
   try 
   {
      #Dim nextUnconsumedGlobal As %String = ""
      #Dim xDataResultSetName As %String = ""
      // First look at the private process globals
      if ($Data(^||CResultSetTools("_" _ strQueryName)))
      {
         // Get the first unconsumed XData and build a CMockResultSet, if any.
         set nextUnconsumedGlobal = $Order(^||CResultSetTools("_" _ strQueryName, ""))
         set xDataResultSetName = ^||CResultSetTools("_" _ strQueryName, nextUnconsumedGlobal)
         set:(xDataResultSetName '= "") rs = ##class(test.framework.Mock.CMockResultSet).CreateFromXData(xDataResultSetName)
         
         // This result set was used with success, mark it
         kill:($IsObject(rs)) ^||CResultSetTools("_" _ strQueryName, nextUnconsumedGlobal)
      }
      elseif ($Data(^CResultSetTools("_" _ strQueryName)))
      {
         // Get the first unconsumed XData and build a CMockResultSet, if any.
         set nextUnconsumedGlobal = $Order(^CResultSetTools("_" _ strQueryName, ""))
         set xDataResultSetName = ^CResultSetTools("_" _ strQueryName, nextUnconsumedGlobal)
         set:(xDataResultSetName '= "") rs = ##class(test.framework.Mock.CMockResultSet).CreateFromXData(xDataResultSetName)
         
         // This result set was used with success, mark it
         kill:($IsObject(rs)) ^CResultSetTools("_" _ strQueryName, nextUnconsumedGlobal)
      }
   }
   catch
   {
      // Trying to access an undefined global throws an error. Ignore it.
   }
   
   // If there are no defined CMockResultSet, create a standard one.
   set:('$IsObject(rs)) rs = ##class(%ResultSet).%New(strQueryName)   
   
   quit rs
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// --- Private methods ---

]]></Content>
</UDLText>

<Method name="GetNextExpectation">
<Internal>1</Internal>
<FormalSpec>instance:test.framework.Mock.CMockBase,strMethodName:%String</FormalSpec>
<Private>1</Private>
<ReturnType>test.framework.Mock.CExpectation</ReturnType>
<Implementation><![CDATA[
   #dim expectation As test.framework.Mock.CExpectation = $$$NULLOREF
   do $$$AssertTrue(..lstExpectation.Count() > 0, ..GetNoMoreMethodExpectedDescription(instance, strMethodName))
   if (..lstExpectation.Count() > 0)
   {
      set expectation = ..lstExpectation.GetAt(1)
   }
   
   quit expectation
]]></Implementation>
</Method>

<Method name="ValidateMethodCalled">
<Internal>1</Internal>
<FormalSpec>expectation:test.framework.Mock.CExpectation,instance:test.framework.Mock.CMockBase,strMethodName:%String,lstParams:%ListOfDataTypes</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   #dim status As %Status = $$$ERROR("")
   do $$$AssertEquals(expectation.GetInstance(), instance, ..GetUnexpectedMethodDescription(expectation, instance, strMethodName, lstParams))
   if (expectation.GetInstance() = instance)
   {
      do $$$AssertEquals(expectation.GetMethodName(), strMethodName, ..GetUnexpectedMethodDescription(expectation, instance, strMethodName, lstParams))
      if (expectation.GetMethodName() = strMethodName)
      {
         set status = $$$OK
      }
   }
   
   quit status
]]></Implementation>
</Method>

<Method name="ProcessParameters">
<Internal>1</Internal>
<FormalSpec><![CDATA[expectation:test.framework.Mock.CExpectation,&lstParams:%ListOfDataTypes,strMethodName:%String]]></FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
   do $$$AssertEquals(expectation.GetLstParameters().Count(), lstParams.Count(), ..GetParameterCountDescription(expectation, lstParams, strMethodName))
   
   if (expectation.GetLstParameters().Count() = lstParams.Count())
   {
      #dim i As %Integer = 1
      for i = 1:1:lstParams.Count()
      {
         do ..ProcessParameterAtIndex(i, expectation.GetLstParameters().GetAt(i), .lstParams, strMethodName)
      }
   }
]]></Implementation>
</Method>

<Method name="ProcessParameterAtIndex">
<Internal>1</Internal>
<FormalSpec><![CDATA[nIndex:%Integer,parameterExpected,&lstParams:%ListOfDataTypes,strMethodName:%String]]></FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
   if ($IsObject(parameterExpected) && 
       parameterExpected.%Extends(##class(test.framework.Mock.IMockParamValidator).%ClassName(1)))
   {
      do $$$AssertStatusOK(parameterExpected.Validate(lstParams.GetAt(nIndex)), parameterExpected.GetAssertDescription(nIndex, strMethodName))
   }
   elseif ($IsObject(parameterExpected) &&
           parameterExpected.%IsA(##class(test.framework.Mock.CMockByRefParam).%ClassName(1)))
   {
      do ..ProcessParameterAtIndex(nIndex, parameterExpected.expectedValue, .lstParams, strMethodName)
      do lstParams.SetAt(parameterExpected.replaceByValue, nIndex)
   }
   else
   {
      #dim strAssertDescription = ..GetParameterDescription(parameterExpected,
                                                            lstParams.GetAt(nIndex),
                                                            nIndex,
                                                            strMethodName)
      
      // %Status datatype need to be compared in a special way !
      try
      { 
         #Dim dummy As %Status = parameterExpected
         do $System.Status.AppendStatus(dummy, lstParams.GetAt(nIndex))
         do $$$AssertStatusEquals(parameterExpected, lstParams.GetAt(nIndex), strAssertDescription)
      }
      catch
      {
         do $$$AssertEquals(parameterExpected, lstParams.GetAt(nIndex), strAssertDescription)
      }
   }
]]></Implementation>
</Method>

<Method name="DecrementExpectationTimes">
<Internal>1</Internal>
<FormalSpec><![CDATA[&expectation:test.framework.Mock.CExpectation]]></FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
   do expectation.DecrementTimes()
   if (expectation.GetTimes() = 0)
   {
      do ..lstExpectation.RemoveAt(1)
   }
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// --- Private error helpers ---

]]></Content>
</UDLText>

<Method name="GetUnexpectedMethodDescription">
<Internal>1</Internal>
<FormalSpec>expectation:test.framework.Mock.CExpectation,instance:test.framework.Mock.CMockBase,strMethodNameReceived:%String,lstParamsReceived:%ListOfDataTypes</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
   #Dim strOutput As %String ="Expected Method: " _ expectation.GetInstance() _ "::" _ expectation.GetMethodName() _ " "
   set strOutput = strOutput _"Got: " _ instance _ "::" _strMethodNameReceived _ "("
   #Dim i As %Integer = 0
   for i=1:1:lstParamsReceived.Count()-1
   {  
      set strOutput = strOutput _ lstParamsReceived.GetAt(i)_", "
   }
   set strOutput = strOutput _ lstParamsReceived.GetAt(lstParamsReceived.Count())_") "
   
   quit strOutput
]]></Implementation>
</Method>

<Method name="GetParameterCountDescription">
<Internal>1</Internal>
<FormalSpec>expectation:test.framework.Mock.CExpectation,lstParamsReceived:%ListOfDataTypes,strMethodName:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
   quit "Expected Parameter count: " _ expectation.GetLstParameters().Count() _ " for method: " _ strMethodName _
        " Got: " _ lstParamsReceived.Count() _ " "
]]></Implementation>
</Method>

<Method name="GetParameterDescription">
<Internal>1</Internal>
<FormalSpec>expectedParameter,receivedParameter,nIndex:%Integer,strMethodName:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
   quit "Expected Parameter(" _ nIndex _ ") value: '" _ expectedParameter _ "' for method: " _ strMethodName _
        " Got: '" _ receivedParameter _ "' "
]]></Implementation>
</Method>

<Method name="GetNoMoreMethodExpectedDescription">
<Internal>1</Internal>
<FormalSpec>instance:test.framework.Mock.CMockBase,strMethodName:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
   quit "Expected no more methods " _
        "Got: " _ instance.%ClassName(1) _ "::" _strMethodName _ " "
]]></Implementation>
</Method>

<Method name="IsUnconsumedResultSetLeft">
<FormalSpec><![CDATA[&strFirstUnconsumedQuery:%String=""]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
   set strFirstUnconsumedQuery = $Order(^||CResultSetTools(""))
   set:(strFirstUnconsumedQuery="") strFirstUnconsumedQuery = $Order(^CResultSetTools(""))
   quit (strFirstUnconsumedQuery '= "")
]]></Implementation>
</Method>

<Method name="CreateClass">
<ClassMethod>1</ClassMethod>
<FormalSpec>strNewClassName:%String,strExtends:%String="",aParameters:%ArrayOfDataTypes=$$$NULLOREF</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   #dim classDef As %Dictionary.ClassDefinition = ##class(%Dictionary.ClassDefinition).%New(strNewClassName)
   if (strExtends '= "") 
   {
      set classDef.Super = strExtends
   }
   
   // Create/Override parameters in this class if required
   if ($IsObject(aParameters))
   {
      #Dim strParameterName As %String = ""
      #Dim strParameterValue As %String = aParameters.GetNext(.strParameterName)
      while (strParameterName '=  "")  
      {
         if (strParameterName '= "")
         {
            set parameter = ##class(%Dictionary.ParameterDefinition).%New(strNewClassName _ ":" _ strParameterName)
            set parameter.Default = strParameterValue
            do classDef.Parameters.Insert(parameter)
         }         
         set strParameterValue = aParameters.GetNext(.strParameterName)
      }   
   }
   
   do classDef.%Save()
   
   quit ##class(%SYSTEM.OBJ).Compile(strNewClassName)
]]></Implementation>
</Method>

<Method name="DeleteClass">
<ClassMethod>1</ClassMethod>
<FormalSpec>strClassName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[   quit ##class(%Dictionary.ClassDefinition).%DeleteId(strClassName)
]]></Implementation>
</Method>
</Class>


<Class name="test.framework.Mock.CMockResultSet">
<Super>%RegisteredObject,%XML.Adaptor</Super>
<TimeChanged>65455,32451</TimeChanged>
<TimeCreated>64030,49821.000032</TimeCreated>

<Parameter name="XMLNAME">
<Default>Query</Default>
</Parameter>

<Property name="strColumnNames">
<Type>%String</Type>
<Private>1</Private>
<Parameter name="MAXLEN" value="1000"/>
<Parameter name="XMLNAME" value="ColumnsNames"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="rows">
<Type>%String</Type>
<Collection>list</Collection>
<Private>1</Private>
<Parameter name="MAXLEN" value="5000"/>
<Parameter name="XMLNAME" value="Row"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="%ROWCOUNT">
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="XMLPROJECTION" value="NONE"/>
</Property>

<Method name="%OnNew">
<FormalSpec>lstRows:%ListOfDataTypes=##class(%ListOfDataTypes).%New()</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
   set ..rows = lstRows
   Quit $$$OK
]]></Implementation>
</Method>

<Method name="CreateFromXData">
<ClassMethod>1</ClassMethod>
<FormalSpec>xDataName:%String</FormalSpec>
<ReturnType>test.framework.Mock.CMockResultSet</ReturnType>
<Implementation><![CDATA[
   #Dim customResultSet As test.framework.Mock.CMockResultSet = $$$NULLOREF

   set xData = ##class(%Dictionary.CompiledXData).%OpenId(xDataName)
   set reader = ##class(%XML.Reader).%New()
   if $IsObject(xData) && $$$ISOK(reader.OpenStream(xData.Data))
   {
      do reader.Correlate(..#XMLNAME, ..%ClassName(1))
      do reader.Next(.customResultSet)
   }
   
   quit customResultSet
]]></Implementation>
</Method>

<Method name="Prepare">
<FormalSpec>args...</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   set ..%ROWCOUNT = 0
   quit $$$OK
]]></Implementation>
</Method>

<Method name="Execute">
<FormalSpec>args...</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   set ..%ROWCOUNT = 0
   quit $$$OK
]]></Implementation>
</Method>

<Method name="Next">
<Description>
Advance the result set cursor to the next row. Returns 0 if the cursor is at the end of the 
result set.</Description>
<FormalSpec><![CDATA[&sc:%Status]]></FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
  
   set ..%ROWCOUNT = ..%ROWCOUNT + 1
   
   quit (..%ROWCOUNT <= ..rows.Count())
]]></Implementation>
</Method>

<Method name="%Next">
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[	Return ..Next()
]]></Implementation>
</Method>

<Method name="%Get">
<FormalSpec>pProperty:%String</FormalSpec>
<Implementation><![CDATA[
   #Dim returnValue As %String = ""
   if ((..%ROWCOUNT > 0) && (..%ROWCOUNT <= ..rows.Count()))
   {
      set returnValue = ..GetData($ListFind(..GetColumnNamesList($ZConvert(..strColumnNames, "U")), $ZConvert(pProperty,"U")))
   }
   quit returnValue
]]></Implementation>
</Method>

<Method name="%DispatchGetProperty">
<FormalSpec>pProperty:%String</FormalSpec>
<Implementation><![CDATA[
   #Dim returnValue As %String = ""
   if ((..%ROWCOUNT > 0) && (..%ROWCOUNT <= ..rows.Count()))
   {
      set returnValue = ..GetData($ListFind(..GetColumnNamesList($ZConvert(..strColumnNames, "U")), $ZConvert(pProperty,"U")))
   }
   quit returnValue
]]></Implementation>
</Method>

<Method name="GetRowCount">
<Description>
Returns the number of rows in the result set.</Description>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[   quit ..rows.Count()
]]></Implementation>
</Method>

<Method name="GetColumnCount">
<Description>
Returns the number of columns in the result set.</Description>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[   quit $ListLength(..GetColumnNamesList(..strColumnNames))
]]></Implementation>
</Method>

<Method name="GetColumnName">
<Description><![CDATA[
Returns the name of column <var>nIndex</var> in the result set.]]></Description>
<FormalSpec>nIndex:%Integer</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
   #Dim strColumnName As %String = ""
   try 
   {
      set strColumnName = $List(..GetColumnNamesList(..strColumnNames), nIndex)
   }
   catch 
   {
      // $List throws an error if nIndex is 0 or when given an empty list, this is annoying.
   }
   quit strColumnName
]]></Implementation>
</Method>

<Method name="GetData">
<Description><![CDATA[
Returns the value of column <var>nIndex</var> in the current row of the result set.]]></Description>
<FormalSpec>nIndex:%Integer</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
   #Dim strData As %String = ""
   
   try
   {
      set strData = $List($ListFromString(..rows.GetAt(..%ROWCOUNT), ..GetSeparator()), nIndex)
      if (
      	($FIND($ZCONVERT(strData, "U"), "$LB(") > 0) ||
      	($FIND($ZCONVERT(strData, "U"), "$LISTBUILD(") > 0)){
	      	
		XECUTE ("(out) SET out="_strData, .strData)
      }
   }
   catch 
   {
      // $List throws an error if nIndex is 0 or when given an empty list, this is annoying.
   }
   
   quit strData
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// -- Helper --

]]></Content>
</UDLText>

<Method name="GetSeparator">
<Private>1</Private>
<ReturnType>%Char</ReturnType>
<Implementation><![CDATA[   quit $Extract(..strColumnNames, 1, 1)
]]></Implementation>
</Method>

<Method name="GetColumnNamesList">
<FormalSpec>strColumnNames:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[   quit $ListFromString($Extract(strColumnNames, 2, *), ..GetSeparator())
]]></Implementation>
</Method>
</Class>


<Class name="test.framework.Mock.CNotNullObjectMockParamValidator">
<Super>%RegisteredObject,test.framework.Mock.IMockParamValidator</Super>
<TimeChanged>65455,32451</TimeChanged>
<TimeCreated>63860,44927.361891</TimeCreated>

<Property name="strExpectedClassName">
<Type>%String</Type>
</Property>

<Method name="%OnNew">
<Internal>1</Internal>
<FormalSpec>strExpectedClassName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   set ..strExpectedClassName = strExpectedClassName
   
   quit $$$OK
]]></Implementation>
</Method>

<Method name="Validate">
<Internal>1</Internal>
<FormalSpec>object</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   #dim status As %Status = $$$ERROR("Wrong class or null")
   if ($data(object) && (object '= $$$NULLOREF) && $IsObject(object) && object.%IsA(..strExpectedClassName))
   {
      set status = $$$OK
   }
   
   quit status
]]></Implementation>
</Method>

<Method name="GetAssertDescription">
<Internal>1</Internal>
<FormalSpec>nIndex:%Integer,strMethodName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[   quit "Expected Parameter(" _ nIndex _ ") not null  for method: " _ strMethodName _ " Got either a null, not an object or a wrong object"
]]></Implementation>
</Method>
</Class>


<Class name="test.framework.Mock.IMockParamValidator">
<Description>
Base interface for mock parameter validator. These are used when a simple "=" is not enough or connot be used
to validate a parameter value.</Description>
<Abstract>1</Abstract>
<TimeChanged>65455,32451</TimeChanged>
<TimeCreated>63860,44201.980741</TimeCreated>

<Method name="Validate">
<Description>
Validates that the parameter is as expected.</Description>
<Abstract>1</Abstract>
<FormalSpec>objectOrDataType</FormalSpec>
<ReturnType>%Status</ReturnType>
</Method>

<Method name="GetAssertDescription">
<Description>
Returns the assert description.</Description>
<Abstract>1</Abstract>
<FormalSpec>nIndex:%Integer,strMethodName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
</Method>
</Class>


<Class name="test.framework.Shift.CManager">
<Description>
Customização do Framework de mock para pular testes que não devem ser executados</Description>
<Super>test.framework.InterSystems.CManager</Super>
<TimeChanged>65455,32451</TimeChanged>
<TimeCreated>62883,71343.008696</TimeCreated>

<Method name="RunTestSuites">
<ClassMethod>1</ClassMethod>
<FormalSpec>testspec:%String="",qspec:%String="",userparam:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 
   Set manager=..%New()
   If manager=$$$NULLOREF Quit %objlasterror
   
   Set sc=$$$qualifierParse("UnitTest",.qspec,.qstruct) q:$$$ISERR(sc) sc
   
   Set manager.Debug=$$$qualifierGetValue(qstruct,"debug")
   Set manager.Display=$s($$$qualifierGetValue(qstruct,"displaylog"):"log",1:"")_","_$s($$$qualifierGetValue(qstruct,"displayerror"):"error",1:"")
   Set manager.UserParam=userparam
   
   Set suite=$p(testspec,":",1)
   ; tests variable is divided by suites
   If $$$qualifierGetValue(qstruct,"recursive")=0 {
      Set tests(suite)=$lb(suite)
   } else {
      Set tests(suite)=$lb(suite)
      Set child=suite_"."
      Set pointCount=$l(child,".")
      For {
         Set child=$o(^oddDEF(child))
         If child'[(suite_".") q
         If '$$issubclassof^%occCompile(child,"%UnitTest.TestCase") Continue
         
         //Shift implementation for skiping tests
         Continue:(..ShouldSkipTest(child))
                           
         Set tests($p(child,".",1,pointCount))=$g(tests($p(child,".",1,pointCount)))_$lb(child)
      }
   }
   
   Set zhBegin=$zh
   
   Set suite="" For  Set suite=$o(tests(suite)) Quit:suite=""  Do
   . Do manager.RunOneTestSuite(suite,tests(suite),testspec,.qstruct) 
   Do manager.SaveResult($zh-zhBegin)
   
   Set manager.Display="log,error"
   If $$$qualifierGetValue(qstruct,"run") Do manager.PrintURL()
   
   Quit $$$OK
]]></Implementation>
</Method>

<Method name="ShouldSkipTest">
<Description>
A verificaão é feita diretamnete nas definições da classe a fim de evitar instanciação de objetos para mitigação de problemas de perforamance na execução dos testes.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pChild:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	Return $GET(^oddCOM(pChild,"v","SkipTest",21),0)
]]></Implementation>
</Method>
</Class>




<Class name="test.testcoverage.Data.Aggregate.Base">
<Abstract>1</Abstract>
<Super>%Persistent</Super>
<TimeChanged>65455,32451</TimeChanged>
<TimeCreated>65108,62301.339197</TimeCreated>
<NoExtent>1</NoExtent>

<Property name="ExecutableLines">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="CoveredLines">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="ExecutableMethods">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="CoveredMethods">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="RtnLine">
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Time">
<Type>test.testcoverage.DataType.Timing</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="TotalTime">
<Type>test.testcoverage.DataType.Timing</Type>
<InitialExpression>0</InitialExpression>
</Property>
</Class>


<Class name="test.testcoverage.Data.Aggregate.ByCodeUnit">
<Super>test.testcoverage.Data.Aggregate.Base</Super>
<TimeChanged>65455,32457.014164</TimeChanged>
<TimeCreated>65108,62301.310251</TimeCreated>

<Index name="RunCodeUnit">
<Properties>Run,CodeUnit</Properties>
<Unique>1</Unique>
</Index>

<Property name="Run">
<Type>test.testcoverage.Data.Run</Type>
<Required>1</Required>
</Property>

<ForeignKey name="RunFK">
<OnDelete>cascade</OnDelete>
<Properties>Run</Properties>
<ReferencedClass>test.testcoverage.Data.Run</ReferencedClass>
</ForeignKey>

<Property name="CodeUnit">
<Type>test.testcoverage.Data.CodeUnit</Type>
<Required>1</Required>
</Property>

<ForeignKey name="CodeUnitFK">
<OnDelete>cascade</OnDelete>
<Properties>CodeUnit</Properties>
<ReferencedClass>test.testcoverage.Data.CodeUnit</ReferencedClass>
<ReferencedKey>Hash</ReferencedKey>
</ForeignKey>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^test.testcovera1C7B.ByCodeUnitD</DataLocation>
<DefaultData>ByCodeUnitDefaultData</DefaultData>
<IdLocation>^test.testcovera1C7B.ByCodeUnitD</IdLocation>
<IndexLocation>^test.testcovera1C7B.ByCodeUnitI</IndexLocation>
<StreamLocation>^test.testcovera1C7B.ByCodeUnitS</StreamLocation>
<Data name="ByCodeUnitDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>ExecutableLines</Value>
</Value>
<Value name="3">
<Value>CoveredLines</Value>
</Value>
<Value name="4">
<Value>ExecutableMethods</Value>
</Value>
<Value name="5">
<Value>CodeUnit</Value>
</Value>
<Value name="6">
<Value>RtnLine</Value>
</Value>
<Value name="7">
<Value>Time</Value>
</Value>
<Value name="8">
<Value>TotalTime</Value>
</Value>
<Value name="9">
<Value>CoveredMethods</Value>
</Value>
<Value name="10">
<Value>Run</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="test.testcoverage.Data.Aggregate.ByRun">
<Super>test.testcoverage.Data.Aggregate.Base</Super>
<TimeChanged>65455,32457.005855</TimeChanged>
<TimeCreated>65108,62301.318226</TimeCreated>

<Index name="Run">
<Properties>Run</Properties>
<Unique>1</Unique>
</Index>

<Property name="Run">
<Type>test.testcoverage.Data.Run</Type>
<Required>1</Required>
</Property>

<ForeignKey name="RunFK">
<OnDelete>cascade</OnDelete>
<Properties>Run</Properties>
<ReferencedClass>test.testcoverage.Data.Run</ReferencedClass>
</ForeignKey>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^test.testcoverage.Da1C7B.ByRunD</DataLocation>
<DefaultData>ByRunDefaultData</DefaultData>
<IdLocation>^test.testcoverage.Da1C7B.ByRunD</IdLocation>
<IndexLocation>^test.testcoverage.Da1C7B.ByRunI</IndexLocation>
<StreamLocation>^test.testcoverage.Da1C7B.ByRunS</StreamLocation>
<Data name="ByRunDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>ExecutableLines</Value>
</Value>
<Value name="3">
<Value>CoveredLines</Value>
</Value>
<Value name="4">
<Value>ExecutableMethods</Value>
</Value>
<Value name="5">
<Value>CoveredMethods</Value>
</Value>
<Value name="6">
<Value>RtnLine</Value>
</Value>
<Value name="7">
<Value>Time</Value>
</Value>
<Value name="8">
<Value>TotalTime</Value>
</Value>
<Value name="9">
<Value>Run</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="test.testcoverage.Data.CodeSubUnit.Method">
<Super>test.testcoverage.Data.CodeSubUnit</Super>
<TimeChanged>65455,32457.115411</TimeChanged>
<TimeCreated>65108,62301.336464</TimeCreated>

<Property name="Name">
<Type>%Dictionary.CacheIdentifier</Type>
<Required>1</Required>
</Property>

<Property name="DisplaySignature">
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Method name="UpdateComplexity">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		// Get int lines mapped to this method's mask.
		// As an optimization, find start/end of mask
		Set tMaskStart = $BitFind(..Mask,1,0,1)
		Set tMaskEnd = $BitFind(..Mask,1,0,-1)
		
		// Get lines mapped to this method's mask
		// Get unique by map.ToLine to avoid issues with mapping of embedded SQL
		// (all lines of the generated query map back to the class line defining it)
		Set tResult = ##class(%SQL.Statement).%ExecDirect(,
			"select distinct by (map.ToLine) element_key ""Line"", Lines ""Code"" from test_testcoverage_Data.CodeUnit_Lines intcode "_
			"join test_testcoverage_Data.CodeUnitMap map "_
			"	on map.FromHash = intcode.CodeUnit "_
			"	and map.FromLine = intcode.element_key "_
			"where intcode.CodeUnit->Type = 'INT' "_
			"	and map.ToHash = ? "_
			"	and map.ToLine >= ? and map.ToLine <= ? "_
			"order by map.FromLine",..Parent.Hash,tMaskStart,tMaskEnd)
		If (tResult.%SQLCODE < 0) {
			Throw ##class(%Exception.SQL).CreateFromSQLCODE(tResult.%SQLCODE,tResult.%Message)
		}
		Set tCodeStream = ##class(%Stream.TmpCharacter).%New()
		While tResult.%Next(.tSC) {
			$$$ThrowOnError(tSC)
			$$$ThrowOnError(tCodeStream.WriteLine(tResult.%Get("Code")))
		}
		$$$ThrowOnError(tSC)
		
		Set ..Complexity = ##class(test.testcoverage.Utils.ComplexityParser).%New(tCodeStream).GetComplexity()
		$$$ThrowOnError(..%Save(0))
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>MethodDefaultData</DefaultData>
<Data name="MethodDefaultData">
<Structure>listnode</Structure>
<Subscript>"Method"</Subscript>
<Value name="1">
<Value>Name</Value>
</Value>
<Value name="2">
<Value>DisplaySignature</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="test.testcoverage.Data.CodeSubUnit">
<Abstract>1</Abstract>
<Super>%Persistent</Super>
<TimeChanged>65455,32456.972323</TimeChanged>
<TimeCreated>65108,62301.003676</TimeCreated>

<Property name="Parent">
<Type>test.testcoverage.Data.CodeUnit</Type>
<Cardinality>parent</Cardinality>
<Inverse>SubUnits</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Mask">
<Description>
Bitstring representing which lines are part of this section (method, branch, etc.) of the code</Description>
<Type>test.testcoverage.DataType.Bitstring</Type>
</Property>

<Property name="Complexity">
<Description>
Cyclomatic complexity of the code subunit</Description>
<Type>%Integer</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Method name="UpdateComplexity">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>{%%PARENT}("SubUnits")</DataLocation>
<DefaultData>CodeSubUnitDefaultData</DefaultData>
<IdLocation>^test.testcoverage6450.CodeUnitC("SubUnits")</IdLocation>
<IndexLocation>^test.testcover6450.CodeSubUnitI</IndexLocation>
<StreamLocation>^test.testcover6450.CodeSubUnitS</StreamLocation>
<Data name="CodeSubUnitDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Mask</Value>
</Value>
<Value name="3">
<Value>Complexity</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="test.testcoverage.Data.CodeUnit">
<Description>
Represents a single unit of code (class, routine), which may be generated or user-written.
TODO: Create subclasses representing classes, routines, and intermediate code.</Description>
<IncludeCode>%syGluedef</IncludeCode>
<Super>%Persistent</Super>
<TimeChanged>65455,32451</TimeChanged>
<TimeCreated>65108,62301.079543</TimeCreated>

<Index name="Hash">
<Description>
Hash had better be unique...</Description>
<IdKey>1</IdKey>
<Properties>Hash</Properties>
</Index>

<Index name="NameTypeHash">
<Description>
Uniquely identifies a unit of code by name, type, and hash.</Description>
<Data>ExecutableLines</Data>
<Properties>Name,Type,Hash</Properties>
<Unique>1</Unique>
</Index>

<Property name="Name">
<Description>
Name of the code unit</Description>
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="255"/>
</Property>

<Property name="Type">
<Description>
Type (3-letter extension) of the code unit</Description>
<Type>test.testcoverage.DataType.RoutineType</Type>
<Required>1</Required>
</Property>

<Property name="Hash">
<Description><![CDATA[
Hash of the code unit; for methods for determining this, see <method>GetCurrentHash</method>]]></Description>
<Type>%String</Type>
<Required>1</Required>
</Property>

<Property name="Lines">
<Description>
Lines (with position in list corresponding to line number)</Description>
<Type>%String</Type>
<Collection>list</Collection>
<Parameter name="MAXLEN"/>
<Parameter name="STORAGEDEFAULT" value="array"/>
</Property>

<Property name="ExecutableLines">
<Description>
Bitstring of (line # is executable)</Description>
<Type>test.testcoverage.DataType.Bitstring</Type>
</Property>

<Property name="MethodMap">
<Description>
For classes, map of method names in the code to their associated line numbers
For routines, map of labels to associated line numbers</Description>
<Type>%Integer</Type>
<Collection>array</Collection>
</Property>

<Property name="LineToMethodMap">
<Description>
For classes, map of line numbers in code to associated method names
For routines, map of labels to associated line numbers</Description>
<Type>%String</Type>
<Collection>array</Collection>
<Private>1</Private>
<Parameter name="MAXLEN"/>
</Property>

<Property name="Generated">
<Description>
Set to true if this class/routine is generated</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="SubUnits">
<Description>
Methods, branches, etc. within this unit of code.</Description>
<Type>test.testcoverage.Data.CodeSubUnit</Type>
<Cardinality>children</Cardinality>
<Inverse>Parent</Inverse>
<Relationship>1</Relationship>
</Property>

<Method name="GetCurrentByName">
<Description>
Gets the current instance of a unit of code by its internal name (e.g., SomePackage.ClassName.CLS or SomePackage.ClassName.1.INT)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pInternalName:%String,pSourceNamespace:%String=$Namespace,*pCodeUnit:test.testcoverage.Data.CodeUnit,&pCache]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set tOriginalNamespace = $Namespace
	Set tInitTLevel = $TLevel
	Try {
		Set pCodeUnit = $$$NULLOREF
		
		New $Namespace
		Set $Namespace = pSourceNamespace
		
		// Figure out the hash.
		Set pInternalName = ##class(%Studio.SourceControl.Interface).normalizeName(pInternalName)
		Set tName = $Piece(pInternalName,".",1,*-1)
		Set tType = $Piece(pInternalName,".",*)
		
		TSTART
		// GetCurrentHash may store the current version of the routine,
		// so start the transaction before calling it.
		$$$ThrowOnError(..GetCurrentHash(tName,tType,.tHash,.tCodeArray,.pCache))
			
		// Ensure mappings from the specified name/type/hash are up to date.
		#dim tMapToResult As %SQL.StatementResult
		Set tMapToResult = ##class(%SQL.Statement).%ExecDirect(,
			"select distinct ToHash from test_testcoverage_Data.CodeUnitMap where FromHash = ?",tHash)
		If (tMapToResult.%SQLCODE < 0) {
			Throw ##class(%Exception.SQL).CreateFromSQLCODE(tMapToResult.%SQLCODE,tMapToResult.%Message)
		}
		Set tNeedsUpdate = 0
		While tMapToResult.%Next(.tSC) {
			$$$ThrowOnError(tSC)
			Set tKnownHash = tMapToResult.%GetData(1)
			Set tMapToUnit = ..HashOpen(tKnownHash,,.tSC)
			$$$ThrowOnError(tSC)
			$$$ThrowOnError(..GetCurrentByName(tMapToUnit.Name_"."_tMapToUnit.Type,pSourceNamespace,.tUpdatedUnit,.pCache))
			If (tUpdatedUnit.Hash '= tKnownHash) {
				//Clear out old data and flag the need for an update.
				Set tNeedsUpdate = 1
				&sql(delete from test_testcoverage_Data.CodeUnitMap where ToHash = :tKnownHash)
				If (SQLCODE < 0) {
					Throw ##class(%Exception.SQL).CreateFromSQLCODE(SQLCODE,%msg)
				}
			}
		}
		
		Set $Namespace = tOriginalNamespace
		If ..NameTypeHashExists(tName,tType,tHash,.tID) {
			Set pCodeUnit = ..%OpenId(tID,,.tSC)
			$$$ThrowOnError(tSC)
			If tNeedsUpdate {
				$$$ThrowOnError(pCodeUnit.UpdateSourceMap(pSourceNamespace,.pCache))
			}
			TCOMMIT
			Quit
		}
		
		Set $Namespace = pSourceNamespace
		If (tType = "CLS") {
			Do ##class(test.testcoverage.Utils).GetClassLineExecutableFlags(tName,.tCodeArray,.tExecutableFlags)
		} Else {
			Do ##class(test.testcoverage.Utils).GetRoutineLineExecutableFlags(.tCodeArray,.tExecutableFlags)
		}
		
		Set $Namespace = tOriginalNamespace
		Set pCodeUnit = ..%New()
		Set pCodeUnit.Name = tName
		Set pCodeUnit.Type = tType
		Set pCodeUnit.Hash = tHash
		
		Set tBitString = ""
		For tLine=1:1:$Get(tCodeArray,0) {
			Set $Bit(tBitString,tLine) = $Get(tExecutableFlags(tLine),0)
		}
		Set pCodeUnit.ExecutableLines = tBitString
		
		If (tType = "CLS") {
			Set pCodeUnit.Generated = ($$$comClassKeyGet(tName,$$$cCLASSgeneratedby) '= "")
		}
		
		Set tMethod = ""
		Set tMethodSignature = ""
		Set tMethodMask = ""
		For tLineNumber=1:1:$Get(tCodeArray,0) {
			Set tLine = tCodeArray(tLineNumber)
			Do pCodeUnit.Lines.Insert(tLine)
			
			If (tType = "CLS") {
				// Extract line offset of methods in classes
				Set tStart = $Piece(tLine," ")
				If (tStart = "ClassMethod") || (tStart = "Method") {
					Set tMethod = $Piece($Piece(tLine,"(")," ",2)
					Set tMethodSignature = tLine
					Do pCodeUnit.MethodMap.SetAt(tLineNumber,tMethod)
					Do pCodeUnit.LineToMethodMap.SetAt(tMethod,tLineNumber)
				} ElseIf ($Extract(tStart) = "{") {
					// Ignore the opening bracket for a method.
				} ElseIf ($Extract(tStart) = "}") && (tMethod '= "") {
					// End of method. Add method subunit to class.
					Set tSubUnit = ##class(test.testcoverage.Data.CodeSubUnit.Method).%New()
					Set tSubUnit.Name = tMethod
					Set tSubUnit.DisplaySignature = tMethodSignature
					Set tSubUnit.Mask = tMethodMask
					Do pCodeUnit.SubUnits.Insert(tSubUnit)
					Set tMethod = ""
					Set tMethodSignature = ""
					Set tMethodMask = ""
				} ElseIf (tMethod '= "") {
					Set $Bit(tMethodMask,tLineNumber) = 1
				}
			} Else {
				// Extract line offset of labels in routines
				If ($ZStrip($Extract(tLine),"*PWC") '= "") {
					Set tLabel = $Piece($Piece(tLine," "),"(")
					Do pCodeUnit.MethodMap.SetAt(tLineNumber,tLabel)
					Do pCodeUnit.LineToMethodMap.SetAt(tLabel,tLineNumber)
				}
			}
		}
		
		$$$ThrowOnError(pCodeUnit.%Save())
		
		// For non-class (e.g., .MAC/.INT) code, it's possible that something else generated it,
		// so update the mappings between generated and the thing that generated it.
		If (tType '= "CLS") {
			$$$ThrowOnError(pCodeUnit.UpdateSourceMap(pSourceNamespace,.pCache))
		}
		TCOMMIT
	} Catch e {
		Set pCodeUnit = $$$NULLOREF
		Set tSC = e.AsStatus()
	}
	While ($TLevel > tInitTLevel) {
		TROLLBACK 1
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="UpdateSourceMap">
<FormalSpec><![CDATA[pSourceNamespace:%String,&pCache]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		// First, build local array (tMap) of all maps from the .INT file to other files.
		If (..Type = "INT") {
			For tLineNumber=1:1:..Lines.Count() {
				Set tLine = ..Lines.GetAt(tLineNumber)
				Set tSC = ##class(%Studio.Debugger).SourceLine(..Name, tLineNumber, 1, tLineNumber,	$Length(tLine), pSourceNamespace, .tMap)
				$$$ThrowOnError(tSC)
				
				If $Data(tMap("CLS",1),tData1) && $Data(tMap("CLS",2),tData2) {
					Set $ListBuild(tClass,tMethod,tLine1) = tData1
					Set tLine2 = $List(tData2,3)
					
					// Skip stub classes
					If $$$defClassKeyGet(tClass,$$$cCLASShidden) && ($$$defClassKeyGet(tClass,$$$cCLASSdeployed) = 2) {
						Continue
					}
					
					// Generated method lines are not correctly mapped to the generator method's lines.
					// Therefore, skip mapping generator methods directly from INT to CLS.
					// Instead, these are mapped from INT to MAC and MAC to CLS (transitively).
					If '$Data(tCodeModeCache(tClass,tMethod),tCodeMode) {
						Set tCodeMode = $$$comMemberKeyGet(tClass,$$$cCLASSmethod,tMethod,$$$cMETHcodemode)
						Set tCodeModeCache(tClass,tMethod) = tCodeMode
					}
					If (tCodeMode = $$$cMETHCODEMODEGENERATOR) || (tCodeMode = $$$cMETHCODEMODEOBJECTGENERATOR) {
						Continue
					}
					
					Set tFullMap(tLineNumber) = $ListBuild("CLS",tClass,tMethod,tLine1,tLine2)
					Set tSourceUnits(tClass_".CLS") = ""
				} ElseIf $Data(tMap("MAC",1),tData1) && $Data(tMap("MAC",2),tData2) {
					Set tRoutine = $ListGet(tData1)
					Set tLine1 = $ListGet(tData1,3)
					Set tLine2 = $ListGet(tData2,3)
					Set tFullMap(tLineNumber) = $ListBuild("MAC",tRoutine,"",tLine1,tLine2)
					Set tSourceUnits(tRoutine_".MAC") = ""
				}
			}
		}
		
		// If we are a generator .INT file, ensure that we have source for the original class populated.
		// In such files, the second line looks like (for example):
		// ;(C)InterSystems, method generator for class %ZHSLIB.PackageManager.Developer.AbstractSettings.  Do NOT edit.
		Set tIsGenerator = 0
		Set tCommentLine = ..Lines.GetAt(2)
		If (tCommentLine [ "method generator for class ") {
			Set tClass = $Piece($Piece(tCommentLine,"method generator for class ",2),". ")
			Set tIsGenerator = 1
			Set tSourceUnits(tClass_".CLS") = ""
			
			If (..Type = "MAC") {
				Set ..Generated = 1
				$$$ThrowOnError(..%Save())
				Set tMethod = ""
				Set tLastOffset = 0
				For tLineNumber=1:1:..Lines.Count() {
					Set tLine = ..Lines.GetAt(tLineNumber)
					If ($Piece(tLine," ") = "#classmethod") {
						Set tMethod = $Piece(tLine," ",2)
						Set tMethodGenerators(tLineNumber) = tMethod
						Set tLastOffset = tLineNumber
					} ElseIf (tLine = "#generator") {
						Set tMethod = ""
					} ElseIf (tLineNumber - tLastOffset > 1) && (tMethod '= "") {
						Set tMethodOffset = tLineNumber-tLastOffset-1
						Set tFullMap(tLineNumber) = $ListBuild("CLS",tClass,tMethod,tMethodOffset,tMethodOffset)
					}
				}
			}
		}
		
		// Ensure we have up-to-date code stashed for originating code (MAC/CLS)
		Set tSourceKey = ""
		For {
			Set tSourceKey = $Order(tSourceUnits(tSourceKey))
			If (tSourceKey = "") {
				Quit
			}
			
			Set tSC = ..GetCurrentByName(tSourceKey,pSourceNamespace,.tCodeUnit,.pCache)
			$$$ThrowOnError(tSC)
			Set tCodeUnits(tCodeUnit.Type,tCodeUnit.Name) = tCodeUnit
		}
		
		// Create CodeUnitMap data based on .INT->.CLS mapping.
		Set tFromHash = ..Hash
		Set tLineNumber = ""
		For {
			Set tLineNumber = $Order(tFullMap(tLineNumber),1,tData)
			If (tLineNumber = "") {
				Quit
			}
			
			Set tType = $ListGet(tData,1)
			Set tName = $ListGet(tData,2)
			Set tMethod = $ListGet(tData,3)
			Set tLine1 = $ListGet(tData,4)
			Set tLine2 = $ListGet(tData,5)
			
			Set tToHash = tCodeUnits(tType,tName).Hash
			If (tType = "CLS") {
				Set tOffset = 1 + tCodeUnits(tType,tName).MethodMap.GetAt(tMethod)
			} ElseIf (tType = "MAC") {
				Set tOffset = 0
			}
			
			$$$ThrowOnError(##class(test.testcoverage.Data.CodeUnitMap).Create(tFromHash,tLineNumber,tToHash,tLine1 + tOffset,tLine2 + tOffset))
		}
		
		// Fill in missing details from .CLS->.INT debug mapping.
		// In some cases .CLS->.INT is more accurate; it is possible to have a many-to-many relationship in line mappings.
		// Embedded SQL, in particular, seems to throw a wrench in the works.
		If (..Type = "INT") {
			#dim tClassCodeUnit As test.testcoverage.Data.CodeUnit
			Set tClass = $Order(tCodeUnits("CLS",""),1,tClassCodeUnit)
			If $IsObject($Get(tClassCodeUnit)) {
				Set tLine = 0
				For {
					Set tLine = $BitFind(tClassCodeUnit.ExecutableLines,1,tLine+1)
					If (tLine = 0) {
						Quit
					}
					
					// Find method offset of line
					Set tMethodOffset = tLine
					Set tMethodName = tClassCodeUnit.LineToMethodMap.GetPrevious(.tMethodOffset)
					If (tMethodName '= "") {
						If '$Data(tCodeModeCache(tClass,tMethodName),tCodeMode) {
							Set tCodeMode = $$$comMemberKeyGet(tClass,$$$cCLASSmethod,tMethodName,$$$cMETHcodemode)
							Set tCodeModeCache(tClass,tMethodName) = tCodeMode
						}
						If (tCodeMode = $$$cMETHCODEMODEGENERATOR) || (tCodeMode = $$$cMETHCODEMODEOBJECTGENERATOR) {
							Continue
						}
						Set tOffset = tLine - tMethodOffset - 1
						Set tSC = ##class(%Studio.Debugger).INTLine(tClass_".CLS",tMethodName,tOffset,.tIntName,.tIntLine,.tMissing,pSourceNamespace)
						$$$ThrowOnError(tSC)
						If 'tMissing && (tIntName = ..Name) {
							$$$ThrowOnError(##class(test.testcoverage.Data.CodeUnitMap).Create(..Hash,tIntLine,tClassCodeUnit.Hash,tLine,tLine))
						}
					}
				}
			}
		}
		
		// Update cyclomatic complexity for methods in the linked class
		Set tClass = $Order(tCodeUnits("CLS",""),1,tClassCodeUnit)
		If $IsObject($Get(tClassCodeUnit)) {
			$$$ThrowOnError(tClassCodeUnit.UpdateComplexity())
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="UpdateComplexity">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		If (..Type '= "CLS") {
			Quit
		}
		
		Set tKey = ""
		For {
			Set tSubUnit = ..SubUnits.GetNext(.tKey)
			If (tKey = "") {
				Quit
			}
			$$$ThrowOnError(tSubUnit.UpdateComplexity())
		}
		
		$$$ThrowOnError(..%Save())
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetMethodOffset">
<FormalSpec>pAbsoluteLine:%Integer,*pMethod:%String,*pOffset:%Integer</FormalSpec>
</Method>

<Method name="GetCurrentHash">
<ClassMethod>1</ClassMethod>
<FormalSpec>pName:%String,pType:%String,*pHash:%String,*pCodeArray:%String,*pCache</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		If '$Data(pCache(pName,pType),pHash) {
			If (pType = "CLS") {
				Set pHash = $$$comClassKeyGet(pName,$$$cCLASShash)
				If (pHash '= "") {
					// Get the code too.
					Set pHash = pHash_"|"_$zcrc(pName,7) // In case multiple class definitions are the same!
					$$$ThrowOnError(##class(%Compiler.UDL.TextServices).GetTextAsArray($Namespace,pName,.pCodeArray))
					Set pCodeArray = $Order(pCodeArray(""),-1) //Set top level node to # of lines.
				}
			} ElseIf (pType = "MAC") {
				Merge pCodeArray = ^rMAC(pName,0)
				Merge tSizeHint = ^rMAC(pName,0,"SIZE")
				Set pCodeArray = $Get(pCodeArray(0),0)
				Set pHash = ..HashArrayRange(.pCodeArray,,pName_"."_pType,.tSizeHint)
			} ElseIf (pType = "INT") {
				Merge pCodeArray = ^ROUTINE(pName,0)
				Merge tSizeHint = ^ROUTINE(pName,0,"SIZE")
				Set pCodeArray = $Get(pCodeArray(0),0)
				
				// Skip header (lines 1-4) which, for .INT routines generated from classes,
				// includes the class compilation signature.
				Set pHash = ..HashArrayRange(.pCodeArray,5,pName_"."_pType,.tSizeHint)
			} Else {
				// Give standard descriptive error about the type being invalid.
				$$$ThrowStatus(..TypeIsValid(pType))
			}
			Set pCache(pName,pType) = pHash
		}
		If (pHash = "") {
			Set tSC = $$$ERROR($$$GeneralError,"Source code not available for "_pName_"."_pType)
		}
	} Catch e {
		Set pHash = ""
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="HashArrayRange">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pArray,pStart:%Integer=1,pInitValue:%String,pSizeHint:%Integer=0]]></FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
	Set tHash = ""
	Set tSC = $$$OK
	If (pSizeHint > $$$MaxLocalLength) {
		// If we would exceed the max string length, use a stream instead.
		Set tTmpStream = ##class(%Stream.TmpCharacter).%New()
		Set tString = pInitValue
		For tIndex = pStart:1:$Get(pArray) {
			Do tTmpStream.Write(pArray(tIndex))
		}
		Set tHash = $Case(tTmpStream.Size,0:"",:$System.Encryption.Base64Encode($System.Encryption.SHA1HashStream(tTmpStream,.tSC)))
		$$$ThrowOnError(tSC)
	} Else {
		Set tString = pInitValue
		For tIndex = pStart:1:$Get(pArray) {
			Set tString = tString_$Get(pArray(tIndex))
		}
		// This is fast enough; overhead is only ~3x that of $zcrc(tString,7)
		Set tHash = $Case(tString,"":"",:$System.Encryption.Base64Encode($System.Encryption.SHA1Hash(tString)))
	}
	Quit tHash
]]></Implementation>
</Method>

<Method name="ExportToStream">
<FormalSpec>pStream:%Stream.Object</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		For tLineNumber = 1:1:..Lines.Count() {
			Do pStream.WriteLine(..Lines.GetAt(tLineNumber))
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^test.testcoverage6450.CodeUnitD</DataLocation>
<DefaultData>CodeUnitDefaultData</DefaultData>
<IdLocation>^test.testcoverage6450.CodeUnitD</IdLocation>
<IndexLocation>^test.testcoverage6450.CodeUnitI</IndexLocation>
<StreamLocation>^test.testcoverage6450.CodeUnitS</StreamLocation>
<Data name="CodeUnitDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Name</Value>
</Value>
<Value name="3">
<Value>Type</Value>
</Value>
<Value name="4">
<Value>ExecutableLines</Value>
</Value>
<Value name="5">
<Value>Generated</Value>
</Value>
</Data>
<Data name="LineToMethodMap">
<Attribute>LineToMethodMap</Attribute>
<Structure>subnode</Structure>
<Subscript>"LineToMethodMap"</Subscript>
</Data>
<Data name="Lines">
<Attribute>Lines</Attribute>
<Structure>subnode</Structure>
<Subscript>"Lines"</Subscript>
</Data>
<Data name="MethodMap">
<Attribute>MethodMap</Attribute>
<Structure>subnode</Structure>
<Subscript>"MethodMap"</Subscript>
</Data>
</Storage>
</Class>


<Class name="test.testcoverage.Data.CodeUnitMap">
<Super>%Persistent</Super>
<TimeChanged>65455,32457.026018</TimeChanged>
<TimeCreated>65108,62301.075472</TimeCreated>

<Index name="Key">
<IdKey>1</IdKey>
<Properties>FromHash,FromLine,ToHash,ToLine</Properties>
</Index>

<Property name="FromHash">
<Type>test.testcoverage.Data.CodeUnit</Type>
<Required>1</Required>
</Property>

<Property name="FromLine">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="ToHash">
<Type>test.testcoverage.Data.CodeUnit</Type>
<Required>1</Required>
</Property>

<Property name="ToLine">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Index name="Reverse">
<Properties>ToHash,ToLine,FromHash,FromLine</Properties>
<Unique>1</Unique>
</Index>

<Index name="HashForward">
<Properties>FromHash,ToHash</Properties>
</Index>

<Index name="HashReverse">
<Properties>ToHash,FromHash</Properties>
</Index>

<ForeignKey name="FromCodeUnitFK">
<OnDelete>cascade</OnDelete>
<Properties>FromHash</Properties>
<ReferencedClass>test.testcoverage.Data.CodeUnit</ReferencedClass>
<ReferencedKey>Hash</ReferencedKey>
</ForeignKey>

<ForeignKey name="ToCodeUnitFK">
<OnDelete>cascade</OnDelete>
<Properties>ToHash</Properties>
<ReferencedClass>test.testcoverage.Data.CodeUnit</ReferencedClass>
<ReferencedKey>Hash</ReferencedKey>
</ForeignKey>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>pFromHash:%String,pFromLine:%Integer,pToHash:%String,pToLineStart:%Integer,pToLineEnd:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		&sql(insert or update %NOLOCK %NOCHECK into test_testcoverage_Data.CodeUnitMap
			(FromHash, FromLine, ToHash, ToLine)
			select :pFromHash, :pFromLine, :pToHash, Counter
			from test_testcoverage.Sequence(:pToLineStart,:pToLineEnd))
		If (SQLCODE < 0) {
			Throw ##class(%Exception.SQL).CreateFromSQLCODE(SQLCODE,%msg)
		}

		// Insert/update transitive data (e.g., .INT -> .MAC (generator) -> .CLS)
		&sql(
			/* Lines that map to the "from" line also map to the "to" line */
			insert or update %NOLOCK %NOCHECK into test_testcoverage_Data.CodeUnitMap
			(FromHash, FromLine, ToHash, ToLine)
			select FromHash, FromLine, :pToHash, Counter
			from test_testcoverage.Sequence(:pToLineStart,:pToLineEnd),test_testcoverage_Data.CodeUnitMap
				where ToHash = :pFromHash and ToLine = :pFromLine
			union
			/* The "from" line also maps to lines that the "to" line maps to */
			select :pFromHash, :pFromLine, ToHash, ToLine
			from test_testcoverage.Sequence(:pToLineStart,:pToLineEnd)
				join test_testcoverage_Data.CodeUnitMap
				on FromHash = :pToHash and FromLine = Counter)
		If (SQLCODE < 0) {
			Throw ##class(%Exception.SQL).CreateFromSQLCODE(SQLCODE,%msg)
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="IsLineMappedTo">
<ClassMethod>1</ClassMethod>
<FormalSpec>pToHash:%String,pToLine:%Integer</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	If (pToHash = "") || (pToLine = "") {
		Quit 0
	}
	
	// In theory, the query would be really really fast and just have a single global reference.
	// In practice, the generated code loops over subscripts in the "Reverse" index.
	/*
	&sql(select top 1 1 from test_testcoverage_Data.CodeUnitMap where ToHash = :pToHash and ToLine = :pToLine)
	Quit (SQLCODE = 0)
	*/
	
	// Therefore, as an optimization, just check the global of interest.
	Quit ($Data(^test.testcoverage.Data.CodeUnitMapI("Reverse",pToHash,pToLine)) > 0)
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^test.testcover6450.CodeUnitMapD</DataLocation>
<DefaultData>CodeUnitMapDefaultData</DefaultData>
<IdLocation>^test.testcover6450.CodeUnitMapD</IdLocation>
<IndexLocation>^test.testcover6450.CodeUnitMapI</IndexLocation>
<StreamLocation>^test.testcover6450.CodeUnitMapS</StreamLocation>
<Data name="CodeUnitMapDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="test.testcoverage.Data.Coverage">
<IncludeGenerator>TestCoverage</IncludeGenerator>
<Super>%Persistent</Super>
<TimeChanged>65455,32456.57265</TimeChanged>
<TimeCreated>65108,62301.00419</TimeCreated>

<Index name="UniqueCoverageData">
<Properties>Run,Hash,TestPath</Properties>
<Unique>1</Unique>
</Index>

<Index name="MeaningfulCoverageData">
<Data>CoveredLines</Data>
<Properties>Run,Calculated,Ignore,Hash,TestPath</Properties>
<Unique>1</Unique>
</Index>

<Property name="Run">
<Description>
Reference to the test coverage tracking run for which this coverage data was collected.</Description>
<Type>test.testcoverage.Data.Run</Type>
<Required>1</Required>
</Property>

<Property name="TestPath">
<Description>
Path through test cases/suites</Description>
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="300"/>
<Parameter name="TRUNCATE" value="1"/>
</Property>

<Property name="Hash">
<Description>
Target code unit, uniquely identified by hash.</Description>
<Type>test.testcoverage.Data.CodeUnit</Type>
<Required>1</Required>
</Property>

<Property name="Ignore">
<Description>
If set to 1, this coverage data should be ignored in reports/aggregates.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Calculated">
<Description>
If set to 1, this coverage data was calculated as a rollup based on underlying data.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Index name="Run">
<Type>bitmap</Type>
<Properties>Run</Properties>
</Index>

<Index name="TestPath">
<Type>bitmap</Type>
<Properties>TestPath</Properties>
</Index>

<Index name="Hash">
<Type>bitmap</Type>
<Properties>Hash</Properties>
</Index>

<Index name="Ignore">
<Type>bitmap</Type>
<Properties>Ignore</Properties>
</Index>

<Index name="Calculated">
<Type>bitmap</Type>
<Properties>Calculated</Properties>
</Index>

<ForeignKey name="RunFK">
<OnDelete>cascade</OnDelete>
<Properties>Run</Properties>
<ReferencedClass>test.testcoverage.Data.Run</ReferencedClass>
</ForeignKey>

<ForeignKey name="HashFK">
<Properties>Hash</Properties>
<ReferencedClass>test.testcoverage.Data.CodeUnit</ReferencedClass>
<ReferencedKey>Hash</ReferencedKey>
</ForeignKey>

<UDLText name="T">
<Content><![CDATA[
// METRICS

]]></Content>
</UDLText>

<Property name="CoveredLines">
<Description>
Bitstring of "Line Covered" flags</Description>
<Type>test.testcoverage.DataType.Bitstring</Type>
</Property>

<Property name="RtnLine">
<Description>
List of "RtnLine" counts subscripted by line number</Description>
<Type>%Integer</Type>
<Collection>array</Collection>
</Property>

<Property name="Time">
<Description>
List of "Time" measurements from line-by-line monitor, subscripted by line number</Description>
<Type>test.testcoverage.DataType.Timing</Type>
<Collection>array</Collection>
</Property>

<Property name="TotalTime">
<Description>
List of "TotalTime" measurements from line-by-line monitor, subscripted by line number</Description>
<Type>test.testcoverage.DataType.Timing</Type>
<Collection>array</Collection>
</Property>

<Method name="StoreIntCoverage">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pRun:%Integer,pTestPath:%String,pRoutineName:%String,&pCache]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		#dim tResult As %SQL.StatementResult
		Set tSC = ##class(test.testcoverage.Data.CodeUnit).GetCurrentByName(pRoutineName_".INT",,.tCodeUnit,.pCache)
		$$$ThrowOnError(tSC)
		
		If ..UniqueCoverageDataExists(pRun,tCodeUnit.Hash,pTestPath,.tID) {
			Set tInstance = ..%OpenId(tID,,.tSC)
			$$$ThrowOnError(tSC)
		} Else {
			Set tInstance = ..%New()
			Set tSC = tInstance.RunSetObjectId(pRun)
			$$$ThrowOnError(tSC)
			Set tInstance.TestPath = pTestPath
			Set tInstance.Hash = tCodeUnit
		}
		
		Set tCoveredLines = tInstance.CoveredLines
		
		Set tAvailableMetrics = ..GetAvailableMetrics()
		Set tPointer = 0
		While $ListNext(tAvailableMetrics,tPointer,tMetricKey) {
			If tInstance.Run.Metrics.Find(tMetricKey) {
				Set tMetrics(tMetricKey) = $Property(tInstance,tMetricKey)
			}
		}
		
		// ROWSPEC = "LineNumber:%Integer,LineCovered:%Boolean,RtnLine:%Integer,Time:%Numeric,TotalTime:%Numeric"
		Set tResult = ##class(test.testcoverage.Utils).LineByLineMonitorResultFunc(pRoutineName)
		While tResult.%Next(.tSC) {
			$$$ThrowOnError(tSC)
			Set tLineNumber = tResult.%Get("LineNumber")
			If tResult.%Get("LineCovered") {
				Set $Bit(tCoveredLines,tLineNumber) = 1
			}
			Set tMetricKey = ""
			For {
				Set tMetricKey = $Order(tMetrics(tMetricKey),1,tMetric)
				If (tMetricKey = "") {
					Quit
				}
				Do tMetric.SetAt(tResult.%Get(tMetricKey) + tMetric.GetAt(tLineNumber),tLineNumber)
			}
		}
		$$$ThrowOnError(tSC)
		
		Set tInstance.CoveredLines = $BitLogic(tInstance.CoveredLines|tCoveredLines)
		
		Set tSC = tInstance.%Save()
		$$$ThrowOnError(tSC)
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetAvailableMetrics">
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[
	// Note: this is implemented as a generator method to avoid referencing an include file in a persistent class.
	// Doing so makes shipping this tool as a deployed Studio project difficult, because include files cannot be deployed,
	// and dynamic queries against this class will end up referencing the include file.
	#define QuotedMetrics ##quote($$$METRICS)
	Do %code.WriteLine(" Quit $ListBuild("_$$$QuotedMetrics_")")
	Quit $$$OK
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^test.testcoverage6450.CoverageD</DataLocation>
<DefaultData>CoverageDefaultData</DefaultData>
<IdLocation>^test.testcoverage6450.CoverageD</IdLocation>
<IndexLocation>^test.testcoverage6450.CoverageI</IndexLocation>
<StreamLocation>^test.testcoverage6450.CoverageS</StreamLocation>
<Data name="CoverageDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Run</Value>
</Value>
<Value name="3">
<Value>TestPath</Value>
</Value>
<Value name="4">
<Value>Hash</Value>
</Value>
<Value name="5">
<Value>Ignore</Value>
</Value>
<Value name="6">
<Value>Calculated</Value>
</Value>
<Value name="7">
<Value>CoveredLines</Value>
</Value>
</Data>
<Data name="RtnLine">
<Attribute>RtnLine</Attribute>
<Structure>subnode</Structure>
<Subscript>"RtnLine"</Subscript>
</Data>
<Data name="Time">
<Attribute>Time</Attribute>
<Structure>subnode</Structure>
<Subscript>"Time"</Subscript>
</Data>
<Data name="TotalTime">
<Attribute>TotalTime</Attribute>
<Structure>subnode</Structure>
<Subscript>"TotalTime"</Subscript>
</Data>
</Storage>
</Class>


<Class name="test.testcoverage.Data.Run">
<Super>%Persistent</Super>
<TimeChanged>65455,32456.447748</TimeChanged>
<TimeCreated>65108,62301.33757</TimeCreated>

<Property name="TestPaths">
<Description>
Test paths included in this run</Description>
<Type>%String</Type>
<Collection>list</Collection>
<Parameter name="MAXLEN"/>
<Parameter name="STORAGEDEFAULT" value="array"/>
</Property>

<Property name="TestResults">
<Description>
Unit test results associated with this coverage report</Description>
<Type>%UnitTest.Result.TestInstance</Type>
</Property>

<Property name="Metrics">
<Description>
List of metrics measured during test coverage (see datatype class for options)</Description>
<Type>test.testcoverage.DataType.Metric</Type>
<Collection>list</Collection>
<Parameter name="STORAGEDEFAULT" value="array"/>
</Property>

<Property name="Subject">
<Description>
Subject of test coverage.
For example, an application or module name.</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="255"/>
</Property>

<Property name="Ordering">
<Description>
Changelist, timestamp, or other identifier at which these coverage results were obtained.
Any metric used for this should order changes in ascending order by point in time.</Description>
<Type>%String</Type>
</Property>

<Property name="IsCommitted">
<Description>
Set to true if the test coverage data is for committed code (rather than pending/in-review changes)</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Index name="ComparisonIndex">
<Description>
Index to easily find the first coverage run before/after a given point in time.</Description>
<Properties>Subject,IsCommitted,Ordering</Properties>
</Index>

<Property name="Detail">
<Description>
Level of detail of the test coverage run</Description>
<Type>test.testcoverage.DataType.Detail</Type>
</Property>

<Method name="MapRunCoverage">
<Description>
Given .INT code coverage for a test run, maps it to .CLS/.MAC.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pRunIndex:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tRun = ##class(test.testcoverage.Data.Run).%OpenId(pRunIndex,,.tSC)
		$$$ThrowOnError(tSC)
		
		// It would be wonderful if there was support for something along the lines of (with a few made up non-functions):
		/*
			INSERT OR UPDATE INTO test_testcoverage_Data.Coverage
				(Run,Hash,TestPath,CoveredLines,Ignore)
			SELECT :pRunIndex,map.ToHash,TestPath,$BITLOGIC(%BITLIST(CASE $BIT(source.CoveredLines,map.FromLine)
				WHEN 1 THEN map.ToLine ELSE NULL END)|oldCoverage.CoveredLines),
				source.Hash->Generated
			FROM test_testcoverage_Data.Coverage source
			JOIN test_testcoverage_Data.CodeUnitMap map
				ON source.Hash = map.FromHash
			LEFT JOIN test_testcoverage_Data.Coverage oldCoverage
				ON oldCoverage.Run = source.Run
				AND oldCoverage.Hash = map.ToHash
				AND oldCoverage.TestPath = source.TestPath
			WHERE source.Run = :pRunIndex
				AND source.Ignore = 0
				AND source.Calculated = 0
			GROUP BY map.ToHash,source.TestPath
		*/
		
		// Here's a worse-performing approach with some extrinsic calls that ideally wouldn't be necessary:
		&SQL(
			INSERT OR UPDATE %NOLOCK %NOCHECK INTO test_testcoverage_Data.Coverage
				(Run,Hash,TestPath,CoveredLines,Ignore)
			SELECT :pRunIndex,map.ToHash,%exact source.TestPath,test_testcoverage.BITWISE_OR(
				test_testcoverage.LIST_TO_BIT(%DLIST(
					CASE test_testcoverage.BIT_VALUE(source.CoveredLines,map.FromLine)
					WHEN 1 THEN map.ToLine
					ELSE NULL END)),oldCoverage.CoveredLines),
				map.ToHash->Generated
			FROM test_testcoverage_Data.Coverage source
			JOIN test_testcoverage_Data.CodeUnitMap map
				ON source.Hash = map.FromHash
			LEFT JOIN test_testcoverage_Data.Coverage oldCoverage
				ON oldCoverage.Run = source.Run
				AND oldCoverage.Hash = map.ToHash
				AND oldCoverage.TestPath = source.TestPath
			WHERE source.Run = :pRunIndex
				AND source.Ignore = 0
				AND source.Calculated = 0
			GROUP BY map.ToHash,source.TestPath)
		If (SQLCODE < 0) {
			Throw ##class(%Exception.SQL).CreateFromSQLCODE(SQLCODE,%msg)
		}
		
		// Copy any other metrics captured/requested as well.
		For i=1:1:tRun.Metrics.Count() {
			Set tMetric = tRun.Metrics.GetAt(i)
			Set tSQLStatement = "INSERT OR UPDATE %NOLOCK %NOCHECK INTO test_testcoverage_Data.""Coverage_"_tMetric_""" "_
				"(Coverage,element_key,"""_tMetric_""") "_
				"SELECT target.ID,map.ToLine,NVL(oldMetric."""_tMetric_""",0) + metric."""_tMetric_""" "_
				"FROM test_testcoverage_Data.Coverage source "_
				"JOIN test_testcoverage_Data.CodeUnitMap map "_
				"	ON source.Hash = map.FromHash "_
				"JOIN test_testcoverage_Data.""Coverage_"_tMetric_""" metric "_
				"	ON metric.Coverage = source.ID "_
				"	AND metric.element_key = map.FromLine "_
				"JOIN test_testcoverage_Data.Coverage target "_
				"	ON target.Run = source.Run "_
				"	AND target.Hash = map.ToHash "_
				"	AND target.TestPath = source.TestPath "_
				"LEFT JOIN test_testcoverage_Data.""Coverage_"_tMetric_""" oldMetric "_
				"	ON oldMetric.ID = target.ID "_
				"	AND oldMetric.element_key = map.ToLine "_
				"WHERE source.Run = ? "_
				"	AND source.Ignore = 0"_
				"	AND source.Calculated = 0"
			
			#dim tResult As %SQL.StatementResult
			Set tResult = ##class(%SQL.Statement).%ExecDirect(,tSQLStatement,pRunIndex)
			If (tResult.%SQLCODE < 0) {
				Throw ##class(%Exception.SQL).CreateFromSQLCODE(tResult.%SQLCODE,tResult.%Message)
			}
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^test.testcoverage.Data.RunD</DataLocation>
<DefaultData>RunDefaultData</DefaultData>
<IdLocation>^test.testcoverage.Data.RunD</IdLocation>
<IndexLocation>^test.testcoverage.Data.RunI</IndexLocation>
<StreamLocation>^test.testcoverage.Data.RunS</StreamLocation>
<Data name="Metrics">
<Attribute>Metrics</Attribute>
<Structure>subnode</Structure>
<Subscript>"Metrics"</Subscript>
</Data>
<Data name="RunDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>TestResults</Value>
</Value>
<Value name="3">
<Value>Subject</Value>
</Value>
<Value name="4">
<Value>Ordering</Value>
</Value>
<Value name="5">
<Value>IsCommitted</Value>
</Value>
<Value name="6">
<Value>Detail</Value>
</Value>
</Data>
<Data name="TestPaths">
<Attribute>TestPaths</Attribute>
<Structure>subnode</Structure>
<Subscript>"TestPaths"</Subscript>
</Data>
</Storage>
</Class>


<Class name="test.testcoverage.DataType.Bitstring">
<Description><![CDATA[
Overrides aggregates for bitstrings: <br />
MAX is the bitwise OR of all values considered in aggregation <br />
MIN is the bitwise AND of all values considered in aggregation <br />
Note that this only works for aggregates operating on properties of this type - not for arbitrary expressions]]></Description>
<ClassType>datatype</ClassType>
<Super>%Binary</Super>
<TimeChanged>65455,32451</TimeChanged>
<TimeCreated>65108,62301.328025</TimeCreated>

<Parameter name="MAXLEN">
<Type>INTEGER</Type>
</Parameter>

<Method name="SQLmax">
<ClassMethod>1</ClassMethod>
<FormalSpec>pAccumulated:test.testcoverage.DataType.Bitstring,pValue:test.testcoverage.DataType.Bitstring</FormalSpec>
<ReturnType>test.testcoverage.DataType.Bitstring</ReturnType>
<Implementation><![CDATA[	Quit $BitLogic(pAccumulated|pValue)
]]></Implementation>
</Method>

<Method name="SQLmin">
<ClassMethod>1</ClassMethod>
<FormalSpec>pAccumulated:test.testcoverage.DataType.Bitstring,pValue:test.testcoverage.DataType.Bitstring</FormalSpec>
<ReturnType>test.testcoverage.DataType.Bitstring</ReturnType>
<Implementation><![CDATA[	Quit $BitLogic(pAccumulated&pValue)
]]></Implementation>
</Method>
</Class>


<Class name="test.testcoverage.DataType.Detail">
<ClassType>datatype</ClassType>
<Super>%String</Super>
<TimeChanged>65455,32451</TimeChanged>
<TimeCreated>65108,62301.313565</TimeCreated>

<Parameter name="DISPLAYLIST">
<Default>,Overall,Suite,Class,Method</Default>
</Parameter>

<Parameter name="VALUELIST">
<Default>,0,1,2,3</Default>
</Parameter>
</Class>


<Class name="test.testcoverage.DataType.Metric">
<Description>
Valid metric names in %SYS.MONLBL</Description>
<ClassType>datatype</ClassType>
<Super>%String</Super>
<TimeChanged>65455,32451</TimeChanged>
<TimeCreated>65108,62301.315989</TimeCreated>

<Parameter name="VALUELIST">
<Default>,RtnLine,Time,TotalTime</Default>
</Parameter>
</Class>


<Class name="test.testcoverage.DataType.RoutineType">
<ClassType>datatype</ClassType>
<Super>%String</Super>
<TimeChanged>65455,32452</TimeChanged>
<TimeCreated>65108,62301.450493</TimeCreated>

<Parameter name="MAXLEN">
<Default>3</Default>
</Parameter>

<Parameter name="VALUELIST">
<Default>,CLS,MAC,INT</Default>
</Parameter>
</Class>


<Class name="test.testcoverage.DataType.Timing">
<Super>%Numeric</Super>
<TimeChanged>65455,32452</TimeChanged>
<TimeCreated>65108,62301.483751</TimeCreated>

<Parameter name="SCALE">
<Description>
The scale value (number of digits following the decimal point) for this data type.  The logical value will be rounded to the specified number of decimal places.</Description>
<Type>INTEGER</Type>
<Default>6</Default>
</Parameter>
</Class>


<Class name="test.testcoverage.Manager">
<Description><![CDATA[
To run a usual set of unit tests with code coverage, simply call <method>RunTest</method>() the same way as you would for %UnitTest.Manager. <br />
To run with higher/lower coverage detail, use (for a valid logical value of <property>CoverageDetail</property>): <br />
<example>
Set tCoverageParams("CoverageDetail") = 3 // Log details at the test method level.
Do ##class(test.testcoverage.Manager).RunTest(,,.tCoverageParams)
</example>
<br />
For use in code based on a known (pre-loaded) unit test package, see documentation for <method>RunAllTests</method>. This also serves as a useful example for how to pass other related user parameters.]]></Description>
<IncludeCode>%occErrors,%syPidtab,TestCoverage</IncludeCode>
<Super>test.testcoverage.ManagerBase</Super>
<TimeChanged>65455,32452</TimeChanged>
<TimeCreated>65108,62301.076718</TimeCreated>

<Property name="CoverageDetail">
<Description><![CDATA[
Level of detail at which test coverage is tracked.
<ol start="0">
<li>Overall</li>
<li>Suite</li>
<li>Class</li>
<li>Method</li>
</ol>]]></Description>
<Type>test.testcoverage.DataType.Detail</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="Timing">
<Description>
If set to true, timing data is tracked as well as code coverage.</Description>
<Type>%Boolean</Type>
<Internal>1</Internal>
<InitialExpression>0</InitialExpression>
<Private>1</Private>
</Property>

<Property name="DynamicTargets">
<Description>
Set to true (1) if coverage targets should be loaded dynamically from the unit test root.</Description>
<Type>%Boolean</Type>
<Internal>1</Internal>
<InitialExpression>1</InitialExpression>
<Private>1</Private>
</Property>

<Property name="CoverageTargets">
<Description>
Current list of targets (routines, classes, .int code, etc.) for line-by-line monitoring</Description>
<Type>%List</Type>
<Internal>1</Internal>
<Private>1</Private>
</Property>

<Property name="CoverageClasses">
<Description>
All classes considered at any point during this unit test run
Top-level node has $ListBuild list; also has subscripts with individual class names for a quicker lookup</Description>
<Type>%List</Type>
<Internal>1</Internal>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Property name="CoverageRoutines">
<Description>
All routines considered at any point during this unit test run
Top-level node has $ListBuild list; also has subscripts with individual routine names for a quicker lookup</Description>
<Type>%List</Type>
<Internal>1</Internal>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Property name="LastCoverageListFile">
<Description>
Last known coverage.list file</Description>
<Type>%String</Type>
<Internal>1</Internal>
<Private>1</Private>
<Parameter name="MAXLEN"/>
</Property>

<Property name="CurrentTestSuite">
<Type>%String</Type>
<Internal>1</Internal>
<Private>1</Private>
<Parameter name="MAXLEN" value="255"/>
</Property>

<Property name="CurrentTestClass">
<Type>%String</Type>
<Internal>1</Internal>
<Private>1</Private>
<Parameter name="MAXLEN" value="255"/>
</Property>

<Property name="CurrentTestMethod">
<Type>%String</Type>
<Internal>1</Internal>
<Private>1</Private>
<Parameter name="MAXLEN" value="255"/>
</Property>

<Property name="SourceNamespace">
<Type>%String</Type>
<Internal>1</Internal>
<Private>1</Private>
<Parameter name="MAXLEN" value="255"/>
</Property>

<Property name="ProcessIDs">
<Type>%List</Type>
<Internal>1</Internal>
<Private>1</Private>
</Property>

<Property name="Run">
<Type>test.testcoverage.Data.Run</Type>
</Property>

<Property name="KnownCoverageTargets">
<Description>
Known coverage targets (already snapshotted)</Description>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Property name="Hashes">
<Description><![CDATA[
Cache of (name, type) -> hash]]></Description>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="Monitor">
<Type>test.testcoverage.Utils.LineByLineMonitor</Type>
<InitialExpression>##class(test.testcoverage.Utils.LineByLineMonitor).%New()</InitialExpression>
<Private>1</Private>
</Property>

<Method name="RunAllTests">
<Description><![CDATA[
Runs unit tests that have been loaded, with code coverage enabled. <br />
Note that if coverage is to be tracked for lots of code, it may be necessary to increase the "gmheap" setting
(under Configuration - Additional Settings - Advanced Memory in the Management Portal). <br />
<ul>
<li><var>pPackage</var> has the top-level package containing all the unit test classes to run. These must already be loaded.</li>
<li><var>pLogFile</var> (optional) may specify a file to log all output to.</li>
<li><var>pCoverageClasses</var> (optional) has a $ListBuild list of class names within which to track code coverage. By default, none are tracked.</li>
<li><var>pCoverageRoutines</var> (optional) has a $ListBuild list of routine names within which to track code coverage. By default, none are tracked.</li>
<li><var>pCoverageLevel</var> (optional) is 0 to track code coverage overall; 1 to track it per test suite (the default); 2 to track it per test class; 3 to track it per test method.
Note that overall tracking is always available; more granular tracking requires more time and disk space.</li>
<li><var>pLogIndex</var> (optional) allows for aggregation of code coverage results across unit test runs. To use this, get it back as output from the first test run, then pass it to the next.</li>
<li><var>pSourceNamespace</var> (optional) specifies the namespace in which classes were compiled, defaulting to the current namespace. This may be required to retrieve some metadata.</li>
<li><var>pPIDList</var> (optional) has a $ListBuild list of process IDs to monitor. If this is empty, all processes are monitored. By default, this is just the current process.</li>
<li><var>pTiming</var> (optional) may be set to 1 to also collect timing information per line.</li>
</ul>
Granular data is stored in <class>test.testcoverage.Data.Coverage</class>; aggregated data is stored per class in <class>test.testcoverage.Data.Aggregate.ByCodeUnit</class> and for the whole run in <class>test.testcoverage.Data.Aggregate.ByRun</class>.
@API.Method]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pPackage:%String="",pLogFile:%String="",pCoverageClasses:%List="",pCoverageRoutines:%List="",pCoverageLevel:%Integer=1,&pLogIndex:%Integer,pSourceNamespace:%String=$Namespace,pPIDList=$ListBuild($Job),pTiming:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tUnitTestManager As test.testcoverage.Manager
	Set tSuccess = 1
	Try {
		Set tLogFileOpen = 0
		Set tOldIO = $io
		If (pLogFile '= "") {
			Open pLogFile:"WNS":10
			Set tLogFileOpen = 1
			Use pLogFile
		}
		
		Set tTestSuite = $Replace(pPackage,"/",".")
		Set tSpec = "/noload/nodelete"
		Merge tCoverageParams("LogIndex") = pLogIndex // Set only if defined.
		Set tCoverageParams("CoverageClasses") = pCoverageClasses
		Set tCoverageParams("CoverageRoutines") = pCoverageRoutines
		Set tCoverageParams("CoverageDetail") = pCoverageLevel
		Set tCoverageParams("SourceNamespace") = pSourceNamespace
		Set tCoverageParams("ProcessIDs") = pPIDList
		Set tCoverageParams("Timing") = pTiming
		Do ..RunTest(tTestSuite,tSpec,.tCoverageParams)
		
		Set tFailed = 0
		&sql(select top 1 1
					into :tFailed
			   from %UnitTest_Result.TestSuite s
			   join %UnitTest_Result.TestCase c
			     on s.Id = c.TestSuite
			  where s.TestInstance = :tCoverageParams("UseLogIndex") and c.Status = 0)
		If (SQLCODE < 0) {
			Throw ##class(%Exception.SQL).CreateFromSQLCODE(SQLCODE,%msg)
		}
		If (SQLCODE = 100) {
			// No results.
			Set tFailed = 0
		}

		If (tFailed '= 0) {
			Set tSuccess = 0
		}
	} Catch e {
		Set tSuccess = 0
		Write e.DisplayString(),!
	}
	Use tOldIO
	Close:tLogFileOpen pLogFile
	Quit $Select(tSuccess:1,1:$$$ERROR($$$GeneralError,"One or more errors occurred in unit tests."))
]]></Implementation>
</Method>

<Method name="SetCoverageTargets">
<FormalSpec>pClasses:%List="",pRoutines:%List="",pInit:%Boolean=0</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
	Set tList = "", tPtr = 0
	While $ListNext(pClasses,tPtr,tClass) {
		// Use a wildcard to include all .int files associated with the class.
		Set tList = tList_$ListBuild(tClass_".CLS")
		Do ..AddCoverageClass(tClass)
	}
	While $ListNext(pRoutines,tPtr,tRoutine) {
		Set tList = tList_$ListBuild(tRoutine_".MAC")
		Do ..AddCoverageRoutine(tRoutine)
	}
	Set ..CoverageTargets = ..GetObjectCodeForSourceNames(tList)
	If pInit {
		// Set flag to determine code coverage dynamically.
		Set ..DynamicTargets = (tList = "")
	}
]]></Implementation>
</Method>

<Method name="CoverageTargetsSet">
<Internal>1</Internal>
<FormalSpec>%value</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If (%value '= $Get(i%CoverageTargets)) {
		If ##class(test.testcoverage.Utils.LineByLineMonitor).IsRunning() {
			For tLevel=1:1:..CoverageDetail {
				Set tContext($Increment(tContext)) = $Case(tLevel,
					1:..CurrentTestSuite,
					2:..CurrentTestClass,
					3:..CurrentTestMethod)
			}
			$$$ThrowOnError(..EndCoverageTracking(tContext...))
		}
		Set i%CoverageTargets = %value
		$$$ThrowOnError(..StartCoverageTracking())
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="StartCoverageTracking">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	New $Namespace
	Try {
		If (..CoverageTargets '= "") {
			Set $Namespace = ..SourceNamespace
		
			Set tNewTargets = ""
			Set tPointer = 0
			While $ListNext(..CoverageTargets,tPointer,tCoverageTarget) {
				If '$Data(..KnownCoverageTargets(tCoverageTarget)) {
					Set tNewTargets = tNewTargets_$ListBuild(tCoverageTarget)
				}
			}
			
			If (tNewTargets '= "") {
				$$$StartTimer("Taking snapshot of code and CLS/MAC/INT mappings")
				Do ##class(test.testcoverage.Utils).Snapshot(tNewTargets)
				$$$StopTimer
			
				Set tPointer = 0
				While $ListNext(tNewTargets,tPointer,tNewTarget) {
					Set ..KnownCoverageTargets(tNewTarget) = ""
				}
			}
			
			// If we are to monitor all process IDs, actually use all except for the SuperServer (Routine = '%SYS.SERVER')
			// Workaround for versions without RFD1682
			Set tProcessIDs = ..ProcessIDs
			If (tProcessIDs = "") {
				&sql(select %DLIST(Pid) into :tProcessIDs from %SYS.ProcessQuery where Routine <> '%SYS.SERVER')
				If (SQLCODE < 0) {
					Throw ##class(%Exception.SQL).CreateFromSQLCODE(SQLCODE,%msg)
				}
			
				// Extra check to make sure that monitor is stopped (another chance to get problem processes to unmap from shared memory)
				// Sometimes the monitor does not stop right away if there are other processes that are being monitored.
				// The root cause of this is unknown and could use further investigation at some point.
				Set tMaxAttempts = 5
				For {
					Set tUnmappedAll = $zu(84,0,0)
					Hang 1
					If (tUnmappedAll) {
						Quit
					}
					If ($Increment(tUnmapCounter) > tMaxAttempts) {
						Set tMsg = $$$FormatText("Some process(es) still holding on to shared memory for line by line monitor after %1 attempts to release. See console log or cstat -p-1 for details.",tMaxAttempts)
						$$$ThrowStatus($$$ERROR($$$GeneralError,tMsg))
					}
				}
			}
			Set tMetrics = $ListBuild("RtnLine") _ $Select(..Timing:$ListBuild("Time","TotalTime"),1:"")
			$$$ThrowOnError(..Monitor.StartWithScope(..CoverageTargets,tMetrics,tProcessIDs))
		}
	} Catch e { 
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="UpdateCoverageTargetsForTestDirectory">
<FormalSpec>pDirectory:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		// Look for a file named "coverage.list" in pDirectory and its ancestors.
		Set tDir = pDirectory
		Set tParent = ""
		Set tListFile = ""
		For {
			If (tDir = tParent) {
				// When we get to the root, the parent is the same as the directory itself.
				Quit
			} ElseIf (tParent '= "") {
				Set tDir = tParent
			}
			
			// Does a file exist there?
			Set tFile = tDir _ "coverage.list"
			If ##class(%File).Exists(tFile) {
				Set tListFile = tFile
				Quit
			}
			Set tParent = ##class(%File).ParentDirectoryName(tDir)
		}
		
		// If this is the last file we checked, quit here.
		If (tListFile = ..LastCoverageListFile) {
			Quit
		}
		Set ..LastCoverageListFile = tListFile
		
		// If we found it, read in coverage list from there.
		Set tCoverageTargetList = ""
		If (tListFile '= "") {
			Do ..PrintLine("Tracking code coverage on resources listed in "_tListFile)
			Do ..GetCoverageTargetsForFile(tListFile, .tCoverageTargets)
			
			For tType = "CLS","MAC" {
				Set tCoverageTargetKey = ""
				For {
					Set tCoverageTargetKey = $Order(tCoverageTargets(tType,tCoverageTargetKey))
					If (tCoverageTargetKey = "") {
						Quit
					}
					Set tCoverageTargetList = tCoverageTargetList _ $ListBuild(tCoverageTargetKey_"."_tType)
					
					If (tType = "CLS") {
						Do ..AddCoverageClass(tCoverageTargetKey)
					} Else {
						Do ..AddCoverageRoutine(tCoverageTargetKey)
					}
				}
			}
		}
		
		Set tObjectCodeList = ..GetObjectCodeForSourceNames(tCoverageTargetList)
		// Check the available memory before trying to capture coverage, so the user can remediate without waiting a really long time
		$$$ThrowOnError(##class(test.testcoverage.Utils.LineByLineMonitor).CheckAvailableMemory($ListLength(..ProcessIDs),$ListLength(tObjectCodeList)))
		Set ..CoverageTargets = tObjectCodeList // Also restarts the monitor if it is running and updates data on covered routines/classes
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="AddCoverageClass">
<FormalSpec>pClassName:%Dictionary.CacheClassname</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
	If '$Data(..CoverageClasses(pClassName)) {
		Set ..CoverageClasses = $Get(..CoverageClasses) _ $ListBuild(pClassName)
		Set ..CoverageClasses(pClassName) = ""
	}
]]></Implementation>
</Method>

<Method name="AddCoverageRoutine">
<FormalSpec>pRoutineName:%String</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
	If '$Data(..CoverageRoutines(pRoutineName)) {
		Set ..CoverageRoutines = $Get(..CoverageRoutines) _ $ListBuild(pRoutineName)
		Set ..CoverageRoutines(pRoutineName) = ""
	}
]]></Implementation>
</Method>

<Method name="GetCoverageTargetsForFile">
<ClassMethod>1</ClassMethod>
<FormalSpec>pFileName:%String,*pTargetArray</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
	Kill pTargetArray
	
	Set tFileStream = ##class(%Stream.FileCharacter).%New()
	Do tFileStream.LinkToFile(pFileName)
	While 'tFileStream.AtEnd {
		Set tFileLines($Increment(tFileLines)) = tFileStream.ReadLine()
	}
	
	For tLineIndex=1:1:$Get(tFileLines) {
		Set tLine = tFileLines(tLineIndex)
		
		// Skip blank lines
		If (tLine = "") {
			Continue
		}
		
		// Skip comment lines
		Set tFirstChar = $Extract(tLine)
		If (tFirstChar = "/") || (tFirstChar = ";") || (tFirstChar = "#") {
			Continue
		}
		
		Set tExclude = 0
		If (tFirstChar = "-") {
			// "-" at the beginning of a line indicates that the following class/routine/package
			// should be *excluded* from coverage tracking
			Set tExclude = 1
			Set tLine = $Extract(tLine,2,*)
		}
		
		Set tName = $Piece(tLine,".",1,*-1)
		Set tExtension = $ZConvert($Piece(tLine,".",*),"U")
		
		Kill tNames
		If (tExtension = "MAC") {
			If (tName [ "*") {
				Do ..SearchRoutines(tLine,.tNames)
			} Else {
				Set tNames(tName) = ""
			}
		} ElseIf (tExtension = "PKG") {
			Set tSC = $System.OBJ.GetPackageList(.tNames,tName)
			$$$ThrowOnError(tSC)
			Set tExtension = "CLS"
		} ElseIf (tExtension = "CLS") {
			If (tName = "*") {
				// TODO: support special case of *.CLS
			} Else {
				Set tNames(tName) = ""
			}
		}
		
		If $Data(tNames) {
			Set tNameKey = ""
			For {
				Set tNameKey = $Order(tNames(tNameKey))
				If (tNameKey = "") {
					Quit
				}
				If (tExclude) {
					Kill pTargetArray(tExtension,tNameKey)
				} Else {
					Set pTargetArray(tExtension,tNameKey) = ""
				}
			}
		}
	}
]]></Implementation>
</Method>

<Method name="SearchRoutines">
<ClassMethod>1</ClassMethod>
<FormalSpec>pSearchExpr:%String,*pRoutines</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
	// %Monitor.System.LineByLine:Start uses this, so why not?
	// Probably better than using a Studio list API in terms of what is/isn't hidden,
	// especially working with system routines.
	Do {
		Set tData = ""
		Set tAtEnd = '$$LIST^%R(pSearchExpr,32767,0,.tData,.tContext)
		Set tPointer = 0
		While $ListNext(tData,tPointer,tRoutine) {
			Set pRoutines($Piece(tRoutine,".",1,*-1)) = ""
		}
	} While 'tAtEnd
]]></Implementation>
</Method>

<Method name="GetObjectCodeForSourceNames">
<FormalSpec>pSourceNameList:%List</FormalSpec>
<Private>1</Private>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[
	New $Namespace
	Set $Namespace = ..SourceNamespace
	Set tOutputNameList = ""
	Set tPointer = 0
	While $ListNext(pSourceNameList,tPointer,tSourceName) {
		Set tName = $Piece(tSourceName,".",1,*-1)
		Set tType = $Piece(tSourceName,".",*)
		Set tOthers = $ListFromString(##class(%Library.RoutineMgr).GetOther(tName,tType,1))
		Set tOtherPointer = 0
		While $ListNext(tOthers,tOtherPointer,tOtherName) {
			Set tOutputNameList = tOutputNameList_$ListBuild($Piece(tOtherName,".",1,*-1))
		}
	}
	Quit tOutputNameList
]]></Implementation>
</Method>

<Method name="EndCoverageTracking">
<FormalSpec>pTestSuite:%String="",pTestClass:%String="",pTestMethod:%String=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		If (..CoverageTargets '= "") {
			// Pause the monitor.
			Set tSC = ..Monitor.Pause()
			If $$$ISERR(tSC) {
				If $System.Status.GetErrorCodes(tSC) = $$$MonitorNotRunning {
					// Not really an error, and nothing to do in this case.
					Set tSC = $$$OK
					Quit
				} Else {
					$$$ThrowStatus(tSC)
				}
			}
			
			Set tTarget = $ListBuild($$$TestPathAllTests) // detail = 0
			If (pTestSuite '= "") {
				Set tTarget = $ListBuild(pTestSuite) // detail > 0
			}
			If (pTestClass '= "") {
				Set tTarget = tTarget_$ListBuild(pTestClass)
			}
			If (pTestMethod '= "") {
				Set tTarget = tTarget_$ListBuild(pTestMethod)
			}
			Set tTarget = $ListToString(tTarget,":")
			Do ..Run.TestPaths.Insert(tTarget)
			$$$ThrowOnError(..Run.%Save())
			Set tTestIndex = ..Run.%Id()
			
			$$$StartTimer("Collecting coverage data for "_tTarget)
			Merge tCache = ..Hashes
			Set tRtnCount = ..Monitor.GetRoutineCount()
			For i=1:1:tRtnCount {
				Set tRtnName = ..Monitor.GetRoutineName(i)
				Set tSC = ##class(test.testcoverage.Data.Coverage).StoreIntCoverage(tTestIndex,tTarget,tRtnName,.tCache)
				$$$ThrowOnError(tSC)
			}
			Merge ..Hashes = tCache
			$$$StopTimer
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnAfterSaveResult">
<Description>
Called at the end of SaveResult() to perform any result aggregation tasks required by subtasks.</Description>
<FormalSpec><![CDATA[&userparam]]></FormalSpec>
<Implementation><![CDATA[
	Try {
		// Associate to unit test results.
		Do ..Run.TestResultsSetObjectId(..LogIndex)
		$$$ThrowOnError(..Run.%Save())
		
		Set tRunIndex = ..Run.%Id()
		If (tRunIndex '= "") {
			Set userparam("LogIndex") = tRunIndex
			
			$$$StartTimer("Mapping to class/routine coverage")
			Set tSC = ##class(test.testcoverage.Data.Run).MapRunCoverage(tRunIndex)
			$$$ThrowOnError(tSC)
			$$$StopTimer
			
			$$$StartTimer("Aggregating coverage data")
			Set tSC = ##class(test.testcoverage.Utils).AggregateCoverage(tRunIndex)
			$$$ThrowOnError(tSC)
			$$$StopTimer
			
			Do ##class(test.testcoverage.Utils).ShowAggregateCoverage(tRunIndex)
		}
	} Catch e {
		// Swallow exceptions.
		Write !,$System.Status.GetErrorText(e.AsStatus())
	}
	Quit
]]></Implementation>
</Method>

<Method name="OnBeforeAllTests">
<Description>
Called before any unit tests are run.
If an error status is returned, no unit tests are run.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[manager:test.testcoverage.Manager,dir:%String,&qstruct,&userparam]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tCoverageClasses = $Get(userparam("CoverageClasses"))
		Set tCoverageRoutines = $Get(userparam("CoverageRoutines"))
		Set tCoverageDetail = $Get(userparam("CoverageDetail"))
		Set tSourceNamespace = $Get(userparam("SourceNamespace"),$Namespace)
		Set tProcessIDs = $Get(userparam("ProcessIDs"),$ListBuild($Job))
		If (tProcessIDs = "*") {
			Set tProcessIDs = ""
		} ElseIf (tProcessIDs = "") || '$ListValid(tProcessIDs) {
			Set tProcessIDs = $ListBuild($Job)
		}
		Set tTiming = $Get(userparam("Timing"),0)
		Set tSubject = $Get(userparam("Subject"))
		Set tIsCommitted = $Get(userparam("IsCommitted"),0)
		Set tOrdering = $Get(userparam("Ordering"))
		
		Set manager.SourceNamespace = tSourceNamespace
		Set manager.ProcessIDs = tProcessIDs
		Set manager.Timing = tTiming
		Do manager.SetCoverageTargets(tCoverageClasses,tCoverageRoutines,1)
		If (tCoverageDetail '= "") {
			If (tCoverageDetail '= +tCoverageDetail) {
				// If we were passed a display value...
				Set tCoverageDetail = ..CoverageDetailDisplayToLogical(tCoverageDetail)
			}
			If '..CoverageDetailIsValid(tCoverageDetail) {
				// Invalid coverage detail.
				Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("Invalid code coverage detail level: %1",userparam("CoverageDetail")))
				Quit
			}
			Set manager.CoverageDetail = tCoverageDetail
		}
		If $Data(userparam("LogIndex"),tRunIndex) {
			Set manager.Run = ##class(test.testcoverage.Data.Run).%OpenId(tRunIndex,,.tSC)
			$$$ThrowOnError(tSC)
		} Else {
			Set manager.Run = ##class(test.testcoverage.Data.Run).%New()
			Do manager.Run.Metrics.Insert("RtnLine")
			If manager.Timing {
				Do manager.Run.Metrics.Insert("Time")
				Do manager.Run.Metrics.Insert("TotalTime")
			}
		}
		Set manager.Run.Detail = manager.CoverageDetail
		Set manager.Run.Subject = tSubject
		Set manager.Run.IsCommitted = tIsCommitted
		Set manager.Run.Ordering = tOrdering
		
		If manager.DynamicTargets && (dir '= "") {
			// Determine coverage targets based on directory contents (looking for coverage.list in that directory or the nearest ancestor containing it).
			Set tSC = manager.UpdateCoverageTargetsForTestDirectory(dir)
			$$$ThrowOnError(tSC)
		}
		
		If (manager.CoverageDetail = 0) {
			Set tSC = manager.StartCoverageTracking()
			$$$ThrowOnError(tSC)
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnAfterAllTests">
<Description><![CDATA[
Called after all unit tests are run.
If an error status is returned, it is logged.
<var>manager</var> is an instance of this class.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[manager:test.testcoverage.Manager,dir:%String,&qstruct,&userparam]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		If (manager.CoverageDetail = 0) {
			Set tSC = manager.EndCoverageTracking()
		}
		Do manager.Monitor.Stop()
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnBeforeAutoLoad">
<Description>
Called before autoload, which occurs before each test suite is run.
If an error status is returned, it is logged and the test suite is not run.</Description>
<FormalSpec><![CDATA[dir:%String,suite:%String,testspec:%String,&qstruct]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		// TODO: Flag to capture code coverage of compiling autoload classes? (e.g., to cover generators?)
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnBeforeTestSuite">
<Description>
Called before a test suite is run.
If an error status is returned, it is logged and the test suite is not run.
This is called after autoload.</Description>
<FormalSpec><![CDATA[dir:%String,suite:%String,testspec:%String,&qstruct]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		If ..DynamicTargets && (dir '= "") {
			// Determine coverage targets based on directory contents (looking for coverage.list in that directory or the nearest ancestor containing it).
			Set tSC = ..UpdateCoverageTargetsForTestDirectory(dir)
			$$$ThrowOnError(tSC)
		}
		Set ..CurrentTestSuite = $Case(suite,"":"(root)",:suite)
		Set ..CurrentTestClass = ""
		Set ..CurrentTestMethod = ""
		If (..CoverageDetail = 1) {
			Set tSC = ..StartCoverageTracking()
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnAfterTestSuite">
<Description>
Called after a test suite is run.
If an error status is returned, it is logged.</Description>
<FormalSpec><![CDATA[dir:%String,suite:%String,testspec:%String,&qstruct]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		If (..CoverageDetail = 1) {
			Set tSC = ..EndCoverageTracking($Case(suite,"":"(root)",:suite))
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnBeforeTestCase">
<Description><![CDATA[
Called before a test case (class extending <class>%UnitTest.TestCase</class>) is run.
If an error status is returned, it is logged and the test case is not run.]]></Description>
<FormalSpec>suite:%String,class:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set ..CurrentTestClass = class
		Set ..CurrentTestMethod = ""
		If (..CoverageDetail = 2) {
			Set tSC = ..StartCoverageTracking()
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnAfterTestCase">
<Description><![CDATA[
Called after a test case (class extending <class>%UnitTest.TestCase</class>) is run.
If an error status is returned, it is logged.]]></Description>
<FormalSpec>suite:%String,class:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		If (..CoverageDetail = 2) {
			Set tSC = ..EndCoverageTracking(suite, class)
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnBeforeOneTest">
<Description><![CDATA[
Called before a test (method starting with "Test" in a class extending <class>%UnitTest.TestCase</class>) is run.
If an error status is returned, it is logged and the test is not run.]]></Description>
<FormalSpec>suite:%String,class:%String,method:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set ..CurrentTestMethod = method
		If (..CoverageDetail = 3) {
			Set tSC = ..StartCoverageTracking()
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnAfterOneTest">
<Description><![CDATA[
Called after a test (method starting with "Test" in a class extending <class>%UnitTest.TestCase</class>) is run.
If an error status is returned, it is logged.]]></Description>
<FormalSpec>suite:%String,class:%String,method:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		If (..CoverageDetail = 3) {
			Set tSC = ..EndCoverageTracking(suite, class, method)
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="PrintURL">
<Implementation><![CDATA[
	Do ##super()
	
	Do ..PrintLine("Use the following URL to view test coverage data:")
	Do ..PrintLine(..GetURL(..Run.%Id()))
	Quit
]]></Implementation>
</Method>

<Method name="GetURL">
<ClassMethod>1</ClassMethod>
<FormalSpec>pRunID:%String,*pHost:%String,*pPath:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tSC = ##class(%RoutineMgr).GetWebServerPort(.tPort,.tServer,.tURLPrefix)
	$$$ThrowOnError(tSC)
	Set pHost = $Case(tPort,443:"https",:"http")_"://"_$Get(^%SYS("HealthShare","NetworkHostName"),tServer)
	Set pHost = pHost _ $Case(tPort,80:"",:":"_tPort)
	Set pPath = $Case(tURLPrefix,"":"",:"/"_tURLPrefix)
	Set pPath = pPath _ $$getDefaultApp^%SYS.cspServer2($Namespace)
	Set pPath = pPath _ "/test.testcoverage.UI.AggregateResultViewer.cls?Index="_$ZConvert(pRunID,"O","URL")
	Quit pHost_pPath
]]></Implementation>
</Method>
</Class>


<Class name="test.testcoverage.ManagerBase">
<Description><![CDATA[
Launches tests using any of the following methods:<br><br>
<b>RunTest</b>: Runs a set of tests and deletes all test classes afterwards.<br><br> 
<b>RunTestSuites</b>: Same as <b>RunTest</b>, but requires 3 arguments, all of which can be null.<br><br>
<b>DebugRunTestCase</b>: Can be used after <b>DebugLoadTestSuite</b>.  It runs tests and does not delete the test classes afterwards, like <b>RunTest</b> does.<br><br> 

Setup: Set the global variable <b>^UnitTestRoot</b> to a root directory that contains your test suites.  
This must point to a valid directory.  Example: <b>Set ^UnitTestRoot="C:\MyUnittests"</b> (adding a final slash is optional).<br><br>

Specifically, the <b>RunTest</b> method does the following:<br>
<ol type=1>
<li>Loads and compiles any test files in the directory specified by the first argument, <i>testspec</i>.
If the loadxml qualifier is on, all <b>.xml</b> or <b>.XML</b> files will be loaded.<br>
If the loadudl qualifier is on, all udl files will be loaded.
<br><br>
<li>For each class that is a subclass of <b>%UnitTest.TestCase</b>, <b>RunTest</b><br><br>
<ol type=A>
<li>Runs the <b>OnBeforeAllTests()</b> method<br><br>
<li>For each method named <b>Test*</b>, such as <b>TestXyz</b>, <b>RunTest</b><br><br>
<ol type=i>
<li>Runs the method <b>OnBeforeOneTest()</b> <br>
<li>Runs the method <b>TestXyz()</b><br>
<li>Runs the method <b>OnAfterOneTest()</b> <br><br>
</ol>
<li>Repeats steps i through iii for all the other methods named <b>Test*</b><br><br>
<li>Runs <b>OnAfterAllTests()</b> method<br><br>
</ol>
<li>Repeats steps A through D for each class that is a subclass of <b>%UnitTest.TestCase</b>.<br><br>
<li>Deletes all the classes loaded during execution.<br><br>
<li>Repeats step 1 through 4 recursively (for all sub-directories) through the specified directory (assuming that the /<b>recursive</b> qualifier is on and skipping any directory whose name begins with an underscore).<br>
</ol>
The loading, running and deletion actions each can be skipped by specifying /noload, /norun and /nodelete qualifiers.<br>
Unit test logs testcase output to the global <b>^UnitTest.Result.</b> Results displayed on CSP pages come from this global.<br><br>
Note: This reference material draws from the article <b>Unit Testing in Cache</b></a> by Ramon Jimenez.]]></Description>
<Super>%RegisteredObject</Super>
<System>3</System>
<TimeChanged>65455,32452</TimeChanged>
<TimeCreated>65108,62300.947611</TimeCreated>

<Property name="LogIndex">
</Property>

<Property name="Debug">
<Description><![CDATA[
Set to true if the <b>/debug</b> qualifier is on.]]></Description>
</Property>

<Property name="Display">
<Description><![CDATA[
Set to true if the <b>/display=all</b> qualifier is set.]]></Description>
</Property>

<Property name="ReportVariableLeaks">
<Description>
Set to true if unexpected public variables should trigger an error.</Description>
</Property>

<Property name="LoadXML">
<Description><![CDATA[
Set to true if the <b>/loadxml</b> qualifier is set.]]></Description>
</Property>

<Property name="LoadUDL">
<Description><![CDATA[
Set to true if the <b>/loadudl</b> qualifier is set. UDL files are .cls, .mac,
.int, .inc, or the upper case extensions.]]></Description>
</Property>

<Property name="CurrentDir">
<Description>
The directory that contains the current test.</Description>
</Property>

<Property name="UserParam">
<Description><![CDATA[
Set by the third argument, <i>userparam</i>, of the <b>RunTest</b> method, if specified.]]></Description>
<Type>%String</Type>
</Property>

<Property name="UserFields">
<Description><![CDATA[
Allow users to store additional information, like platform, product version, etc. for each test.
This information can be later cross-referenced in the result.
This array is populated from the first level subscripts of the <i>userparam</i> argument.]]></Description>
<Type>%String</Type>
<Collection>array</Collection>
</Property>

<Property name="TheStack">
<Description>
Private property for internal use only</Description>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Property name="TempLogIndex">
<Description>
Private property for internal use only</Description>
<Private>1</Private>
</Property>

<Property name="NSInfo">
<Description>
Private property to hold information about this namespace so we can cleanup</Description>
<Internal>1</Internal>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Property name="Environment">
<Description>
Private property to hold information about the environment we need to reset when exiting</Description>
<Internal>1</Internal>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Method name="RunTest">
<Description><![CDATA[
Runs classes that extend <b>%UnitTest.TestCase</b> that contain test methods.  Creates a log on each run, stored in <b>^UnitTest.Result</b>.<br> 
<dl>
<dt><i>testspec</i> 
<dd><i>testspec</i> takes the form of <i>testsuite [ :testcase [ :testmethod ] ]</i>. 
<br><br><i>testsuite</i> is a directory (and optionally, subdirectories) that contains tests. By default <b>RunTest</b> runs all tests found here recursively. <i>testspec</i> must be a child directory of the directory named by the global <b>^UnitTestRoot</b>.  
 <b>^UnitTestRoot</b> must specify a valid directory because <b>RunTest</b> checks for its existence before running tests.  If <i>testspec</i> is not specified, then the <b>^UnitTestRoot</b> directory is used.  Any subdirectory whose name begins with an underscore ( _ ) is skipped.
<br><br><i>testcase</i> is a class that extends <b>%UnitTest.TestCase</b> (contains tests) in the form <i>package.class</i> and is an optional argument. 
<br><br><i>testmethod</i> is a method name and is an optional argument.
<br><br><i>testspec</i> can also be an array of testsuite, or if you pass in a global name the global is an array of testsuites. In addition it also supports a comma separated set of values.
<br><br>
<dt><i>qualifiers</i> 
<dd>Any of the following command-line arguments can be combined as a single string, such as <b>/noload/norecursive</b>. All are optional.<br><br>
The first four (<b>debug</b>, <b>load</b>, <b>run</b>, and <b>recursive</b>) are negatable Booleans.  They can be turned on with <i>/arg</i> or off by adding <b>no</b> in the front, as <b>/noload</b> or adding <b>=0</b> to the end, as <b>/load=0</b>.<br><br> 

<b>/debug</b>: Run in debug mode, which causes a break if a test fails. Default is <b>/nodebug</b>. <br><br>
<b>/load</b>: Load use cases from the specified <i>testspec</i>. Default is <b>/load</b>. If <b>/load</b> and <b>/run</b> are both on, then all loaded classes, routines, and CSP files are deleted after the tests are run. To prevent them from being deleted at the end, load them with <b>DebugLoadTestSuite</b> and run them with <b>DebugRunTestCase</b>.<br><br>
<b>/run</b>: Run the test suite.  Use <b>/norun</b> if you only want to load, but not run, a suite into a namespace. Default is <b>/run</b>.<br><br>
<b>/recursive</b>: Recurse the specified directory when loading test classes. Default is <b>/recursive</b>.<br><br>
<b>/display=all</b>: Display extended information when loading exported test class definitions. <b>/display=none</b> displays limited information. Default is <b>/display=all</b>. <br><br>
<b>/autoload</b>: Automatically load sub-directories with the given name when loading test classes.
Default is <b>/autoload=_autoload</b>.
When this qualifier is set, classes are loaded from the given sub-directory of the current directory and its ancestors.
This makes it possible to use a class in multiple test suites without copying it to each of their directories.<br><br>
<b>/nodelete</b>: Do not delete loaded classes when the test is complete.<br><br>

<dt><i>userparam</i> 
<dd>An arbitrary argument passed in by the caller of the <b>UnitTest</b>.  The top node of this variable becomes the value for the <b>UserParam</b> property of the <b>Manager</b>.
The first level subscripts and their values are used to populate the <b>UserFields</b> array.
</dl>
<br><br>
Example of RunTest:<br>
<pre>
 set ^UnitTestRoot = "c:\test"
 do ##class(test.testcoverage.ManagerBase).RunTest("sql\sqlprocs")
 do ##class(test.testcoverage.ManagerBase).RunTest("sql\sqlprocs","/debug/recursive=0")
</pre>
Note: If any of your code needs to run in the <b>%SYS</b> namespace, <b>zn</b> to the <b>%SYS</b> namespace, run the code, then return to another namespace. 
@API.Method]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[testspec:%String,qspec:%String,&userparam]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc=..RunTestSuites($g(testspec),.qspec,.userparam)
	If $$$ISERR(sc) Do $system.Status.DisplayError(sc)
	Quit sc
]]></Implementation>
</Method>

<Method name="DebugLoadTestSuite">
<Description><![CDATA[
Loads, but does not run tests in the <i>testsuite</i>. You can use <b>DebugLoadTestSuite</b> to load tests and then use <b>DebugRunTestCase</b> to run a test over and over again, without having to reload the tests. If you are a developer, use <b>DebugLoadTestSuite</b> with <b>DebugRunTestCase</b> to load once and then run your test many times as you debug your code. ]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>testsuite:%String="",qspec:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit ..RunTest(testsuite,"/norecursive"_qspec_"/load/norun/nodelete")
]]></Implementation>
</Method>

<Method name="DebugRunTestCase">
<Description><![CDATA[
Runs a test case, but does not load.
<i>testsuite</i> and <i>testcase</i> are required.
<i>testcase</i> is in the form <i>package.class.</i>
<i>testmethod</i> is a method within the class.
See <b>DebugLoadTestSuite</b> for use to test code during development.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[testsuite:%String="",testcase:%String="",qspec:%String="",testmethod:%String="",&userparam]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit ..RunTest(testsuite_":"_testcase_":"_testmethod,"/norecursive"_qspec_"/noload/run/nodelete",.userparam)
]]></Implementation>
</Method>

<Method name="PurgeLog">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit ..PurgeResult()
]]></Implementation>
</Method>

<Method name="PurgeResult">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Lock +^UnitTest.Result
	Kill ^UnitTest.Result
	Lock -^UnitTest.Result
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="WipeNamespace">
<Description>
Wipe all data from this namespace and all PPG information also. Useful in cleaning a namespace
before running unit tests. Never do this on a production system!</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	If $namespace="%SYS" Write "Not in %SYS namespace",! Quit
	#; Free any locks we have
	Lock
	Set manager=..%New()
	#; Call Cleanup to make sure we do not have any $tlevel etc
	Do manager.Cleanup()
	Set manager.Display="log,error"
	Set manager.NSInfo("$zs")=$zs
	Set manager.NSInfo("gbl","UnitTestRoot")="", manager.NSInfo("gbl","UnitTest.Result")="",manager.NSInfo("gbl","UnitTest.ResultI")=""
	Set sc=manager.CleanNamespace() If $$$ISERR(sc) Do DisplayError^%apiOBJ(sc)
	Write !,"Rebuilding Extent Index...",!
	Set sc=$SYSTEM.OBJ.RebuildExtentIndex()  If $$$ISERR(sc) Do DisplayError^%apiOBJ(sc)
]]></Implementation>
</Method>

<Method name="RunTestSuites">
<Description><![CDATA[
Same as <b>RunTest</b>, but requires three arguments.  These arguments can be null, as ("","","").]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[testspec:%String,qspec,&userparam]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set manager=..%New()
	If manager=$$$NULLOREF Quit %objlasterror
	;
	Set sc=$$$qualifierParseAlterDefault("UnitTest","/keepsource",.qspec,.qstruct) q:$$$ISERR(sc) sc
	;
	Kill ^CacheTemp.UnitState
	Set cleanup=0
	Set manager.Debug=$$$qualifierGetValue(qstruct,"debug")
	Set manager.Display=$s($$$qualifierGetValue(qstruct,"displaylog"):"log",1:"")_","_$s($$$qualifierGetValue(qstruct,"displayerror"):"error",1:"")
	Set manager.ReportVariableLeaks=$$$qualifierGetValue(qstruct,"findleakedvariables")
	Set manager.LoadUDL=$$$qualifierGetValue(qstruct,"loadudl")
	Set manager.LoadXML=$$$qualifierGetValue(qstruct,"loadxml")
	Set manager.UserParam=$g(userparam)
	Set key="" For  Set key=$o(userparam(key)) Quit:key=""  do manager.UserFields.SetAt($g(userparam(key)),key)
	If $$$qualifierGetValue(qstruct,"cleanup"),$$$qualifierGetValue(qstruct,"run"),'manager.Debug,$$$qualifierGetValue(qstruct,"delete") {
		Set sc=manager.RecordNamespace() If $$$ISERR(sc) Quit sc
		Set cleanup=1
	}
	;
	Set root=..Root()
	;
	If $get(testspec)'="" {
		If $extract(testspec)="^" {
			Merge testspec=@testspec
		} Else {
			For i=1:1:$length(testspec,",") {
				Set test=$zstrip($piece(testspec,",",i),"<>W")
				Set:test'="" testspec(test)=""
			}
		}
	} ElseIf $data(testspec)\10=0 {
		Set testspec(" ")=""
	}
	If $data(testspec)\10=0 {
		Do manager.PrintLine("Nothing passed in to test or global empty")
		Quit $$$ERROR($$$GeneralError,"Nothing to test")
	}
	;
	Set zhBegin=$zh
	Set suite=""
	Set sc = ..OnBeforeAllTests(manager,root,.qstruct,.userparam)
	If $$$ISERR(sc) {
		Set tDummySuite = $classname()_":OnBeforeAllTests"
		Do manager.LogStateBegin(tDummySuite)
		Do manager.LogStateStatus(sc,tDummySuite)
		Do manager.LogStateEnd(0)
	} Else {
		For {
			Set suite=$order(testspec(suite)) Quit:suite=""
			Kill subdirs
			Set testsuite=$p(suite,":",1)
			Set testsuite=$tr(testsuite,"/.","\\")
			If testsuite=" " Set testsuite=""
			Set dir=..AddSubDirectoryNames(root,testsuite)
			Set sc=$$$OK
			If $$$qualifierGetValue(qstruct,"recursive")=0 {
				If ##class(%File).DirectoryExists(dir)=0 {
					Set sc=$$$ERROR($$$DirectoryNameInvalid,dir)
				} Else {
					Set subdirs(dir)=$lb(dir,testsuite)
				}
			} Else {
			 	Set sc=..GetSubDirectories(root,dir,1,testsuite,.subdirs,.qstruct)
			}
			If $$$ISERR(sc) {
				Do manager.LogStateBegin(testsuite)
				Do manager.LogStateStatus(sc,"Finding directories")
				Set status(" "_testsuite)=""
				Set status=manager.LogStateEnd(0)
				Continue
			}
			;
			Set dir=""
			For {
				Set dir=$o(subdirs(dir)) Quit:dir=""
				#; If we have already run this directory no need to do it again
				If $data(haverun(dir)) Continue
				Set haverun(dir)=""
				Set status=manager.RunOneTestSuite($li(subdirs(dir),1),$li(subdirs(dir),2),suite,.qstruct)
				If status=0 {
					Set status(" "_$tr($li(subdirs(dir),2),"\","/"))=""
				}
			}
			If cleanup {
				Do manager.CleanNamespace()
			}
		}
	}
	
	Set sc = ..OnAfterAllTests(manager,root,.qstruct,.userparam)
	If $$$ISERR(sc) {
		Set tDummySuite = $classname()_":OnAfterAllTests"
		Do manager.LogStateBegin(tDummySuite)
		Do manager.LogStateStatus(sc,tDummySuite)
		Do manager.LogStateEnd(0)
	}
	;
	#; Need to make a list of suites that failed and report these at the end. Is this logged under suite or testsuite from the loop above?
	If $$$qualifierGetValue(qstruct,"run") {
		Do manager.SaveResult($zh-zhBegin,.userparam)
		Set manager.Display="log,error"
		Do manager.PrintURL()
	}
	If $data(status)\10 {
		Do manager.PrintLine("Some tests FAILED in suites:")
		Set status="",list=""
		For {
			Set status=$order(status(status)) Quit:status=""
			Set list=list_$extract(status,2,*)_","
			If $length(list)>10000 {
				Do manager.PrintLine("  "_$extract(list,1,*-1))
				Set list=""
			}
		}
		If list'="" Do manager.PrintLine("  "_$extract(list,1,*-1))
	} Else {
		Do manager.PrintLine("All PASSED")
	}
	;
	Kill ^CacheTemp.UnitState
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="AddSubDirectoryNames">
<ClassMethod>1</ClassMethod>
<FormalSpec>root:%String,testsuite:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set dir=root
	For i=1:1:$l(testsuite,"\") Set test=$Piece(testsuite,"\",i),dir=##Class(%File).SubDirectoryName(dir,test)
	set dir=##class(%File).NormalizeDirectory(dir)
	Quit dir
]]></Implementation>
</Method>

<Method name="LastSubDirectoryName">
<ClassMethod>1</ClassMethod>
<FormalSpec>dir:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set rs=##class(%ResultSet).%New("%File:ParseDirectory")
	Set sc=rs.Execute(dir)
	If $$$ISERR(sc) Quit sc
	Set lastdir=""
	while rs.Next() {
		Set lastdir=rs.GetData(1)
	}
	Quit lastdir
]]></Implementation>
</Method>

<Method name="GetSubDirectories">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[root,topdir:%String,level:%Integer,suite:%String,&subdirs:%String,qspec:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc=$$$qualifierParse("UnitTest",.qspec,.qstruct) q:$$$ISERR(sc) sc
	Set topdir=##Class(%File).NormalizeDirectory(topdir)
	If ##class(%File).DirectoryExists(topdir)=0 Quit $$$ERROR($$$DirectoryNameInvalid,topdir)
	;
	Set rs=##class(%ResultSet).%New("%File:FileSet")
	Set fileset="",sep=""
	If $$$qualifierGetValue(qstruct,"loadxml") Set fileset="*.xml;*.XML",sep=";"
	If $$$qualifierGetValue(qstruct,"loadudl") Set fileset=fileset_sep_"*.cls;*.mac;*.int;*.inc;*.CLS;*.MAC;*.INT;*.INC"
	Set sc=rs.Execute(topdir,fileset,"")
	If $$$ISOK(sc),rs.Next() Set subdirs(topdir)=$lb(topdir,suite)
	Kill rs
	;
	Set rs=##class(%ResultSet).%New("%File:FileSet")
	Set sc=rs.Execute(topdir,"*.*","",1)
	If $$$ISERR(sc) Quit sc
	;
	While rs.Next() {
		If rs.Data("Type")'="D" Continue
		set dir=##Class(%File).NormalizeDirectory(rs.Data("Name"))
		Set lastsub=..LastSubDirectoryName(dir)
		If lastsub="."||(lastsub="..")||($extract(lastsub)="_") Continue  ; skip any subdirectory start with "_"
		Set newsuite=$select(suite="":"",1:suite_"\")_lastsub
		Set sc=..GetSubDirectories(root,dir,level+1,newsuite,.subdirs,.qstruct)
		If $$$ISERR(sc) Quit
	}
	Quit sc
]]></Implementation>
</Method>

<Method name="RunOneTestSuite">
<FormalSpec>dir:%String,suite:%String,testspec:%String,qstruct</FormalSpec>
<Implementation><![CDATA[
	Do $zu(115,5,0) // reset runtime mode between each test
	Set ..CurrentDir=##Class(%Library.File).NormalizeDirectory(dir)
	Set testcase=$p(testspec,":",2)
	Set testmethod=$p(testspec,":",3)
	Do ..PrintLine("===============================================================================",0)
	Do ..PrintLine("Directory: "_dir,0)
	Do ..PrintLine("===============================================================================",0)
	;
	Set zhsBegin=$zh
	Do ..LogStateBegin(suite)
	Set ^CacheTemp.UnitState=$lb(dir)
	; Check internal ISC naming conventions if ^ISC.CheckUnitNames is true
	If $g(^ISC.CheckUnitNames),$$$qualifierGetValue(qstruct,"load") {
		Do ..CheckNameStructure(dir)
	}
	;
	Set flags="c/nodisplay"
	If ..Display["log" Set flags=flags_"/display=log"
	If ..Display["error" Set flags=flags_"/display=error"
	If $$$qualifierAmend("Compiler",.qstruct,flags,.qstructLoad)
	Set sc=$$$OK
	;
	Set fileset="",sep=""
	If ..LoadXML Set fileset="*.xml;*.XML",sep=";"
	If ..LoadUDL Set fileset=fileset_sep_"*.cls;*.mac;*.int;*.inc;*.CLS;*.MAC;*.INT;*.INC"
	;
	Set sc = ..OnBeforeAutoLoad(dir, suite, testspec, .qstruct)
	If $$$ISERR(sc) Do ..LogStateStatus(sc,$classname()_":OnBeforeAutoLoad") Goto exit
	If $$$qualifierGetValue(qstruct,"load") {
		If $$$qualifierGetValue(qstruct,"autoload")]"" {
			Set sc=..AutoLoad(..CurrentDir,$$$qualifierGetValue(qstruct,"autoload"),.autoloadArray,.qstructLoad)
			If $$$ISERR(sc) Do ..LogStateStatus(sc,"$system.OBJ.ImportDir") Goto exit
		}
		Set sc=$system.OBJ.ImportDir(dir,fileset,.qstructLoad,,0,.classLoaded,0)
	} Else {
		If testcase="" {
			Set sc=$system.OBJ.ImportDir(dir,fileset,.qstructLoad,,0,.classLoaded,1)
		} Else {
			Set classLoaded(testcase_".cls")=""
		}
	}
	If $$$ISERR(sc) Do ..LogStateStatus(sc,"$system.OBJ.ImportDir") Goto exit
	;
	Set key="" For {
		Set key=$o(classLoaded(key)) Quit:key=""
		If ($p(key,".",*)="cls") Set classArray($p(key,".",1,*-1))=""
	}
	;
	If $d(classArray)=0 Do ..PrintLine("No classes found for testsuite "_suite,1) Goto exit
	If testcase'="" {
		If $d(classArray(testcase))=0 {
			Do ..LogStateStatus($$$ERROR($$$GeneralError,"TestCase '"_testcase_"' does not exist in TestSuite"),"RunOneTest")
		} ElseIf $$$comClassDefined(testcase)=0 {
			Do ..LogStateStatus($$$ERROR($$$CompiledClassDoesNotExist,testcase),"RunOneTest")
		}
	}
	;
	Set sc=..OnBeforeTestSuite(dir, suite, testspec, .qstruct)
	If $$$ISERR(sc) Do ..LogStateStatus(sc,$classname()_":OnBeforeTestSuite") Goto exit
	If $$$qualifierGetValue(qstruct,"run")=0 {
		Do ..PrintLine("Skipping running testsuite "_suite,1)
	} Else {
		#If $$$comMemberDefined("%SYSTEM.Context.SQL",$$$cCLASSmethod,"ClearStats")
		#; Clear SQL stats
		Do $system.Context.SQL().ClearStats()
		#EndIf
		Set class="" For {
			Set class=$o(classArray(class)) Quit:class=""
			If testcase'="",class'=testcase Continue
			If $system.CLS.IsMthd(class,"%Extends") && $classmethod(class,"%Extends","%UnitTest.TestCase") && '$$$comClassKeyGet(class,$$$cCLASSabstract) {
				Do ..RunOneTestCase(suite,class,testmethod)
			}
		}
	}
	;
	Set ^CacheTemp.UnitState=$lb(dir)
	Set sc=$$$OK
	
	If $$$qualifierGetValue(qstruct,"delete")=0 {
		Do ..PrintLine("Skipping deleting classes ",1)
	} Else {
		Merge classLoaded=autoloadArray
		Set key="" For {
			Set key=$order(classLoaded(key)) Quit:key=""
			If $piece(key,".",*)'="cls" Continue
			s class=$piece(key,".",1,*-1)
			; Invoke the %DeleteExtent method now...
			If $system.CLS.IsMthd(class,"%DeleteExtent") {
				If $parameter(class,"CONNECTION")'="",($$$EXTtype($$$pEXT,class)="%Library.CacheSQLStorage") Continue  // Class is linked, won't delete extent.
				Try {
					Set sc2=$classmethod(class,"%DeleteExtent")
				} Catch exception {
					Set sc2=exception.AsStatus()
				}
				If $$$ISOK(sc2) {
					Set sc2=##class(%ExtentMgr.Util).DeleteExtentDefinitionIfExists(class)
				}
				If $$$ISERR(sc2) {
					Do ..PrintLine("Could not delete extent of "_class)
				}
			}
		}
		Set key="" For {
			Set key=$order(classLoaded(key)) Quit:key=""
			Set ext=$zconvert($piece(key,".",*),"U")
			If ext="CLS" {
				Set sc=$$Delete^%apiOBJ(key,"-d",,1)
			} ElseIf $$IsCSPName^%occXMLExport(key) {
				Set sc=##class(%RoutineMgr).Delete(key)
			} ElseIf $lf($lb("MAC","INT","INC","OBJ","BAS"),ext) {
				Set sc=##class(%Routine).Delete(key,,1)
			} Else {
				Continue
			}
			If $$$ISERR(sc) {
				Do ..PrintLine("Could not delete "_key)
			}
		}
	}
	;
exit
	Set sc=..OnAfterTestSuite(dir, suite, testspec, .qstruct)
	If $$$ISERR(sc) Do ..LogStateStatus(sc,$classname()_":OnAfterTestSuite")
	Set status=..LogStateEnd($zh-zhsBegin)
	Do ..PrintLine("",0)
	Set ..CurrentDir=""
	;
	Quit status
]]></Implementation>
</Method>

<Method name="RunOneTestCase">
<FormalSpec>suite:%String,class:%String,test:%String=""</FormalSpec>
<Implementation><![CDATA[
	New
	New $namespace Set zhcDuration=0
	Set zhcBegin=$zh
	Do ..LogStateBegin(suite,class)
	Set testcase=$classmethod(class,"%New",$this)
	Set testcase.Debug=..Debug,debug=..Debug
	#; For test development: set CurrentDir based on ^UnitTestRoot and package name so it will be correct even in the context of DebugRunTestCase()
	If ""=..CurrentDir {
		Set root=..Root()
		Set tCurrentDir=..AddSubDirectoryNames(root,$G(suite)_"\")
		If ##class(%File).DirectoryExists(tCurrentDir) {
			Set ..CurrentDir=tCurrentDir
			Do ..PrintLine("Setting CurrentDir = '"_tCurrentDir_"'",2)
		} Else {
			Do ..PrintLine("Not Setting Manager.CurrentDir; Directory '"_tCurrentDir_"' does not exist",2)
		}
	}
	Set ^CacheTemp.UnitState=$lb(suite,class)
	Set sc=..Record(.state) If $$$ISERR(sc) Do ..LogStateStatus(sc,"Record") Goto exit
	Set sc=..OnBeforeTestCase(suite, class)
	If $$$ISERR(sc) Do ..LogStateStatus(sc,$classname()_":OnBeforeTestCase") Goto exit
	If debug {
		Set sc=testcase.OnBeforeAllTests()
	} Else {
		Try {
			Set sc=testcase.OnBeforeAllTests()
		} Catch exception {
			Set sc=exception.AsStatus()
		}
	}
	If $$$ISERR(sc) {
		Do ..LogStateStatus(sc,"OnBeforeAllTests")
		Goto exit
	}
	set tFoundMethod=0
	Set method="Tess" ; One before 'Test' which we are searching for
	For {
		Set method=$$$comMemberNext(class,$$$cCLASSmethod,method) Quit:method=""
		If $extract(method,1,4)]"Test" Quit
		If test'=""&&(method'=test) Continue
		If '$system.CLS.IsMthd(class,method) Continue
		Set ^CacheTemp.UnitState=$lb(suite,class,method)
		set tFoundMethod=1
		Do ..LogStateBegin(suite,class,method)
		Set success=0,zhmDuration=0
		If ..ReportVariableLeaks Do ..GetCurrentPublicVariableSet(.preTestVars)
		Set sc=..OnBeforeOneTest(suite, class, method)
		If $$$ISERR(sc) {
			Do ..LogStateStatus(sc,$classname()_":OnBeforeOneTest")
		} Else {
			If debug {
				Set sc=testcase.OnBeforeOneTest(method)
			} Else {
				Try {
					Set sc=testcase.OnBeforeOneTest(method)
				} Catch exception {
					Set sc=exception.AsStatus()
				}
			}
			If $$$ISERR(sc) || (testcase.SkipTest) {
				Do ..LogStateStatus(sc,"OnBeforeOneTest")
			} Else {
				Set zhmBegin=$zh,sc=$$$OK
				If debug {
					Do $method(testcase,method)
				} Else {
					Try {
						Do $method(testcase,method)
					} Catch exception {
						Set sc=exception.AsStatus()
					}
				}
				Set zhmDuration=$zh-zhmBegin
				If $$$ISERR(sc) {
					Do ..LogStateStatus(sc,method)
				} Else {
					Do ..LogMessage("Duration of execution: "_zhmDuration_" sec.")
				}
				If debug {
					Set sc=testcase.OnAfterOneTest(method)
				} Else {
					Try {
						Set sc=testcase.OnAfterOneTest(method)
					} Catch exception {
						Set sc=exception.AsStatus()
					}
				}
				If $$$ISERR(sc) Do ..LogStateStatus(sc,"OnAfterOneTest")
			}
		}
		Set sc=..OnAfterOneTest(suite, class, method)
		If $$$ISERR(sc) Do ..LogStateStatus(sc,$classname()_":OnAfterOneTest")
		Set testcase.SkipTest = 0
		Do ..LogStateEnd(zhmDuration)
		If ..ReportVariableLeaks {
			Do ..GetCurrentPublicVariableSet(.postTestVars)
			Do ..ValidateVariables(.preTestVars, .postTestVars)
		}
	}
	Set ^CacheTemp.UnitState=$lb(suite,class)
	If tFoundMethod=0,test'="" {
		Do ..LogStateStatus($$$ERROR($$$GeneralError,"TestMethod '"_test_"' does not exist in TestCase '"_class_"'."),"RunOneTestCase")
	}
	If debug {
		Set sc=testcase.OnAfterAllTests()
	} Else {
		Try {
			Set sc=testcase.OnAfterAllTests()
		} Catch exception {
			Set sc=exception.AsStatus()
		}
	}
	If $$$ISERR(sc) Do ..LogStateStatus(sc,"OnAfterAllTests")
exit
	Set sc=..OnAfterTestCase(suite, class)
	If $$$ISERR(sc) Do ..LogStateStatus(sc,$classname()_":OnAfterTestCase")
	Set zhcDuration=$zh-zhcBegin
	Set sc=..Cleanup(.state,1) If $$$ISERR(sc) Do ..LogStateStatus(sc,"Cleanup")
	Do ..LogStateEnd(zhcDuration)
]]></Implementation>
</Method>

<Method name="GetCurrentPublicVariableSet">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&GetCurrentPublicVariableSetset]]></FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
	Kill GetCurrentPublicVariableSetset
	Set %="%"
	For  {
		Set % = $ORDER(@%) QUIT:%=""
		If $L(%, "GetCurrentPublicVariableSet") = 1 Set GetCurrentPublicVariableSetset(%) = ""
	}
]]></Implementation>
</Method>

<Method name="SubtractVariableSet">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&c,&a,&b]]></FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
	Kill c
	Merge c = a
	Set var = ""
	For  {
		Set var = $o(b(var)) QUIT:var=""
		Kill c(var)
	}
]]></Implementation>
</Method>

<Method name="ValidateVariables">
<Internal>1</Internal>
<FormalSpec><![CDATA[&preTestVars,&postTestVars]]></FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
	Do ..SubtractVariableSet(.newVars, .postTestVars, .preTestVars)
	Set var = ""
	For  {
		Set var = $O(newVars(var)) QUIT:var=""
		If ..IsAllowedPublicVariable(var) CONTINUE
		Set qval = $$Quote^%qcr($g(@var))
		Do ..LogStateStatus($$$ERROR($$$GeneralError,"Unexpected new public variable introduced: " _ var _ ". $d("_var_") = " _ $d(@var) _ " $g("_var_") = " _ $e(qval,1,256) _ $select($l(qval) > 256:"...",1:"")),"RunOneTestCase")
	}
]]></Implementation>
</Method>

<Method name="IsAllowedPublicVariable">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>var</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
	RETURN:var="%SAX" 1
	RETURN:var="%objcn" 1
	RETURN:var="%objlasterror" 1
	RETURN:var="SQLCODE" 1
	RETURN:var="%msg" 1
	RETURN:var="%ROWCOUNT" 1
	RETURN:var="%ROWID" 1
	RETURN:var="%qrc" 1
	RETURN:var="%sqlcontext" 1
	RETURN:$e(var,1,$L("%SQLGateway"))="%SQLGateway" 1
	RETURN:var="%JDBCGateway" 1
	RETURN:var="%objsync" 1
	RETURN 0
]]></Implementation>
</Method>

<Method name="Record">
<FormalSpec><![CDATA[&State:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill State
	#; Check for any locks left by the test in this process
	Set rset=##class(%ResultSet).%New("%SYS.LockQuery:List"),locks=""
	Do rset.Execute("P"_$job)
	While rset.Next() {
		Set lock=rset.Data("LockString")
		If lock'="" Set State("lock",lock)=""
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="Cleanup">
<FormalSpec><![CDATA[&State:%String,kill=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#; Remove any public variables and close any open objects
	If kill Kill (State)
	Set sc=$$$OK
	If $tlevel {
		Set rc=$$$ERROR($$$GeneralError,"Transaction left open after test: "_$tlevel)
		Set sc=$$$ADDSC(sc,rc)
		While $tlevel { Tcommit }
	}
	If $zu(139) {
		Set rc=$$$ERROR($$$GeneralError,"A test left a transactions suspended")
		Set sc=$$$ADDSC(sc,rc)
		Do $zu(139,0)
	}
	If $$CURRENT^%SYS.NOJRN()'=1 {
		Set rc=$$$ERROR($$$GeneralError,"A test disabled journalling in this process")
		Set sc=$$$ADDSC(sc,rc)
		Do ENABLE^%SYS.NOJRN()
	}
	#; Check for any locks left by the test in this process
	Set rset=##class(%ResultSet).%New("%SYS.LockQuery:List"),locks=""
	Do rset.Execute("P"_$job)
	While rset.Next() {
		Set lock=rset.Data("LockString")
		If $data(State("lock",lock)) Continue
		Set locks=locks_lock_","
		If $length(locks)>512 Set locks=locks_"...," Quit
	}
	If locks'="" {
		Set rc=$$$ERROR($$$GeneralError,"Locks left after unit test run: "_$extract(locks,1,*-1))
		Set sc=$$$ADDSC(sc,rc)
	}
	Set $ECode="",$ZError="" Do resetProcessState^%SYS.cspServer2()
	#; Cleanup any $sortbegin there are active
	Set tmp=$sortend(,0)
	If tmp {
		Set rc=$$$ERROR($$$GeneralError,"Test left $sortbegin open without closing it")
		Set sc=$$$ADDSC(sc,rc)
	}
	If ##class(%SYS.NLS.Format).UseLocale() {
		Do ##class(%SYS.NLS.Format).UseLocale(0)
		Set rc=$$$ERROR($$$GeneralError,"Modified 'UseLocale' to 1 and did not restore it after (##class(%SYS.NLS.Format).UseLocale())")
		Set sc=$$$ADDSC(sc,rc)

	}
	Quit sc
]]></Implementation>
</Method>

<Method name="SaveResult">
<FormalSpec><![CDATA[duration,&userparam]]></FormalSpec>
<Implementation><![CDATA[
	If $g(^UnitTest.Result)="" Lock +^UnitTest.Result Set ^UnitTest.Result=$o(^UnitTest.Result(""),-1) Lock -^UnitTest.Result
	Set i%LogIndex=$i(^UnitTest.Result)
	Set userfields="",key="" for  {
		Set value=..UserFields.GetNext(.key) Quit:key=""  Set userfields=userfields_$lb($lb(key,value))
	}
	Set ^UnitTest.Result(i%LogIndex)=$listbuild($zdatetime($H,3),+$g(duration),$zu(110),$p($zu(86),"*",2),$zv,$znspace,..UserParam,userfields)
	Merge ^UnitTest.Result(i%LogIndex)=^||TempLog(i%TempLogIndex)
	; temporarily comment out the building of indices due to large amount of disk usage
	Do ##class(%UnitTest.Result.TestInstance).FileIndicesRecursive(i%LogIndex)
	Do ..OnAfterSaveResult(.userparam)
	Quit
]]></Implementation>
</Method>

<Method name="LogStateBegin">
<FormalSpec>testsuite,testcase,testmethod</FormalSpec>
<Implementation><![CDATA[
	If $g(testsuite)="" Set testsuite="(root)"
	Set i%TheStack=$g(i%TheStack)+1
	Set i%TheStack(i%TheStack,"suite")=$g(testsuite)
	Set i%TheStack(i%TheStack,"case")=$g(testcase)
	Set i%TheStack(i%TheStack,"method")=$g(testmethod)
	If $g(testmethod)'="" {
		Set ^||TempLog(i%TempLogIndex,testsuite,testcase,testmethod)=$lb(1)
		Do ..PrintLine(testmethod_"() begins ...",3)
	} Elseif $g(testcase)'="" {
		Set ^||TempLog(i%TempLogIndex,testsuite,testcase)=$lb(1)
		Do ..PrintLine(testcase_" begins ...",2)
	} Else {
		Set ^||TempLog(i%TempLogIndex,testsuite)=$lb(1)
		Do ..PrintLine(testsuite_" begins ...",1)
	}
	Quit
]]></Implementation>
</Method>

<Method name="LogStateEnd">
<Description>
Record the end of a test and also return the status of this </Description>
<FormalSpec>duration</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set suite=i%TheStack(i%TheStack,"suite")
	Set case=i%TheStack(i%TheStack,"case")
	Set method=i%TheStack(i%TheStack,"method")
	Kill i%TheStack(i%TheStack)
	Set i%TheStack=i%TheStack-1
	; status precedence order: failed, skipped, passed
	set sp(0)=3,sp(2)=2,sp(1)=1,sphighest=3
	If method'="" {
	 	Set status=$li(^||TempLog(i%TempLogIndex,suite,case,method),1) Quit:status=sphighest status
	 	Set altered=0,action="" For  Set action=$o(^||TempLog(i%TempLogIndex,suite,case,method,action)) Quit:action=""  Do  Quit:status=sphighest
	 	. Set one=$li(^||TempLog(i%TempLogIndex,suite,case,method,action),1) if sp(one)>sp(status) set status=one,altered=1
	 	If altered Set ^||TempLog(i%TempLogIndex,suite,case,method)=$lb(status,duration,"","There are "_..GetTestState(status)_" TestAsserts")
	 	Else       Set $li(^||TempLog(i%TempLogIndex,suite,case,method),2)=duration
	 	Do ..PrintLine($tr(method,"\","/")_" "_..GetTestState(status),3)
	} Elseif case'="" {
	 	Set status=$li(^||TempLog(i%TempLogIndex,suite,case),1) Quit:status=sphighest status
	 	Set altered=0,method="" For  Set method=$o(^||TempLog(i%TempLogIndex,suite,case,method)) Quit:method=""  Do  Quit:status=sphighest
	 	. Set one=$li(^||TempLog(i%TempLogIndex,suite,case,method),1) if sp(one)>sp(status) set status=one,altered=1
	 	If altered Set ^||TempLog(i%TempLogIndex,suite,case)=$lb(status,duration,"","There are "_..GetTestState(status)_" TestMethods")
		Else       Set $li(^||TempLog(i%TempLogIndex,suite,case),2)=duration
	 	Do ..PrintLine($tr(case,"\","/")_" "_..GetTestState(status),2)
	} Elseif suite'=""{
	 	Set status=$li(^||TempLog(i%TempLogIndex,suite),1) Quit:status=sphighest status
	 	Set altered=0,case="" For  Set case=$o(^||TempLog(i%TempLogIndex,suite,case)) Quit:case=""  Do  Quit:status=sphighest
	 	. Set one=$li(^||TempLog(i%TempLogIndex,suite,case),1) if sp(one)>sp(status) set status=one,altered=1
	 	If altered Set ^||TempLog(i%TempLogIndex,suite)=$lb(status,duration,"","There are "_..GetTestState(status)_" TestCases")
		Else       Set $li(^||TempLog(i%TempLogIndex,suite),2)=duration
	 	Do ..PrintLine($tr(suite,"\","/")_" "_..GetTestState(status),1)
	}
	Quit status
]]></Implementation>
</Method>

<Method name="GetTestState">
<ClassMethod>1</ClassMethod>
<FormalSpec>level</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	quit $s(level=1:"passed",level=2:"skipped",1:"failed")
]]></Implementation>
</Method>

<Method name="LogStateStatus">
<FormalSpec>status,action</FormalSpec>
<Implementation><![CDATA[
	If $$$ISOK(status) Quit
	Do $system.Status.DecomposeStatus(status,.errorarray,"-d") Set errortext=$g(errorarray(1))
	Set testsuite=i%TheStack(i%TheStack,"suite")
	Set testcase=i%TheStack(i%TheStack,"case")
	Set testmethod=i%TheStack(i%TheStack,"method")
	Set message="0:"_action_":"_errortext
	If testmethod'="" {
		Set ^||TempLog(i%TempLogIndex,testsuite,testcase,testmethod)=$lb(0,0,action,errortext)
	} Elseif testcase'="" {
		Set ^||TempLog(i%TempLogIndex,testsuite,testcase)=$lb(0,0,action,errortext)
	} Else {
		Set ^||TempLog(i%TempLogIndex,testsuite)=$lb(0,0,action,errortext)
	}
	If ..Display["error" {
		Do ..PrintErrorLine("LogStateStatus:"_message)
	} Else {
		Do ..PrintLine("LogStateStatus:"_message)
	}
	If '..Debug Quit
	Break  Quit
]]></Implementation>
</Method>

<Method name="LogAssert">
<FormalSpec>success,action,description,extra</FormalSpec>
<Implementation><![CDATA[
	Set testsuite=i%TheStack(i%TheStack,"suite")
	Set testcase=i%TheStack(i%TheStack,"case")
	Set testmethod=i%TheStack(i%TheStack,"method")
	If testmethod="" Quit
	Set next=$o(^||TempLog(i%TempLogIndex,testsuite,testcase,testmethod,""),-1)+1
	Set ^||TempLog(i%TempLogIndex,testsuite,testcase,testmethod,next)=$lb(success,action,description)
	Set line=action_":"_description_" ("_..GetTestState(success)_")"
	If 'success,..Display["error" {
		Do ..PrintErrorLine(line,.extra)
	} Else {
		Do ..PrintLine(line,4)
	}
]]></Implementation>
</Method>

<Method name="LogMessage">
<FormalSpec>message</FormalSpec>
<Implementation><![CDATA[
	Set testsuite=i%TheStack(i%TheStack,"suite")
	Set testcase=i%TheStack(i%TheStack,"case")
	Set testmethod=i%TheStack(i%TheStack,"method")
	If testmethod="" Quit
	Set next=$o(^||TempLog(i%TempLogIndex,testsuite,testcase,testmethod,""),-1)+1
	Set ^||TempLog(i%TempLogIndex,testsuite,testcase,testmethod,next)=$lb(1,"LogMessage",$g(message))
	Do ..PrintLine("LogMessage:"_$g(message),4)
]]></Implementation>
</Method>

<Method name="PrintLine">
<FormalSpec>text,level=0</FormalSpec>
<Implementation><![CDATA[
	If ..Display'["log" Quit
	Write !
	Write $j("",level*2)
	Write $g(text)
]]></Implementation>
</Method>

<Method name="PrintErrorLine">
<FormalSpec>text,extra</FormalSpec>
<Implementation><![CDATA[
	If ..Display'["error" Quit
	Write !,$get(text),"  <<==== **FAILED**",!
	Write i%TheStack(i%TheStack,"suite"),":"
	Write i%TheStack(i%TheStack,"case"),":"
	Write i%TheStack(i%TheStack,"method"),":"
	If $get(extra)'="" {
		Write !,extra
	}
]]></Implementation>
</Method>

<Method name="PrintURL">
<Implementation><![CDATA[
	Set s = ##class(%RoutineMgr).GetWebServerPort(.p, .h, .up, .url)
	if $E(url,$L(url))="/" {
		set url=$E(url,1,$L(url)-1)
	}
	If ($$$ISERR(s)) || ($G(url)="") Set url = "http://127.0.0.1:57772"
	set url=url_$$getDefaultApp^%SYS.cspServer2("%SYS")
	Do ..PrintLine("Use the following URL to view the result:")
	Do ..PrintLine(url_"/%25UnitTest.Portal.Indices.cls?Index="_i%LogIndex_"&$NAMESPACE="_$zconvert($namespace,"O","URL"))
	Quit
]]></Implementation>
</Method>

<Method name="IsSuccess">
<Description><![CDATA[
This method is obsolete, use method <b>GetTestStatus</b>]]></Description>
<FormalSpec>suite,case,method,action</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	quit ..GetTestStatus(.suite,.case,.method,.action)=1
]]></Implementation>
</Method>

<Method name="GetTestStatus">
<Description><![CDATA[
Returns result for a given <b>suite, case, method, and action</b>.]]></Description>
<FormalSpec>suite,case,method,action</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	; no need to recurse. LogStateEnd has already scanned and set the correct status
	If $d(action) Quit $li(^||TempLog(i%TempLogIndex,suite,case,method,action),1)
	If $d(method) Quit $li(^||TempLog(i%TempLogIndex,suite,case,method),1)
	If $d(case)   Quit $li(^||TempLog(i%TempLogIndex,suite,case),1)
	If $d(suite)  Quit $li(^||TempLog(i%TempLogIndex,suite),1)
	Quit 0
]]></Implementation>
</Method>

<Method name="%OnNew">
<FormalSpec>initvalue:%CacheString</FormalSpec>
<Private>1</Private>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	Set i%TempLogIndex=$i(^||TempLog)
	#; Record information we will reset when exiting to make sure we are not changing the environment
	Merge i%Environment("sql-sys")=^%SYS("sql","sys")
	#; We will restore this when restoring sql-sys settings in %OnClose
	#If $$$comMemberDefined("%SYSTEM.Context.SQL",$$$cCLASSproperty,"DisableStatCollection")
	Set i%Environment("stat-col")=$system.Context.SQL().DisableStatCollection
	Set $system.Context.SQL().DisableStatCollection=1
	#EndIf
	Set i%Environment("callererrorinfo")=$lb(^%oddENV($$$cENVcallererrorinfo))
	Set i%Environment("uselocale")=##class(%SYS.NLS.Format).UseLocale(0)
	ZKill ^%oddENV($$$cENVcallererrorinfo)
	Do ..Record(.state)
	Merge i%Environment("lockstate")=state
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnClose">
<Private>1</Private>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	Kill ^||TempLog(i%TempLogIndex)
	Merge lockstate=i%Environment("lockstate")
	If $ld(i%Environment("callererrorinfo"),1) {
		Set ^%oddENV($$$cENVcallererrorinfo)=$list(i%Environment("callererrorinfo"))
	} Else {
		ZKill ^%oddENV($$$cENVcallererrorinfo)
	}
	Do ##class(%SYS.NLS.Format).UseLocale(i%Environment("uselocale"))
	#If $$$comMemberDefined("%SYSTEM.Context.SQL",$$$cCLASSproperty,"DisableStatCollection")
	Set $system.Context.SQL().DisableStatCollection=i%Environment("stat-col")
	#EndIf
	Set sc=..Cleanup(.lockstate) If $$$ISERR(sc) Write "ERROR closing ",$classname(),! Do DisplayError^%apiOBJ(sc)
	Merge env=i%Environment("sql-sys")
	#; Look through these values one at a time rather than just doing a kill and merge in case other processes are running at this same time
	Set i=""
	For {
		Set i=$order(env(i)) Quit:i=""
		Set data=$data(env(i),val)
		If data#10=1 {
			If val'=$get(^%SYS("sql","sys",i)) Set ^%SYS("sql","sys",i)=val
		}
		If data\10=1 {
			Set j=""
			For {
				Set j=$order(env(i,j),1,val) Quit:j=""
				If val'=$get(^%SYS("sql","sys",i,j)) Set ^%SYS("sql","sys",i,j)=val
			}
		}
	}
	Set i=""
	For {
		Set i=$order(^%SYS("sql","sys",i)) Quit:i=""
		If '$data(env(i)) Kill ^%SYS("sql","sys",i) Continue
		Set j=""
		For {
			Set j=$order(^%SYS("sql","sys",i,j)) Quit:j=""
			If '$data(env(i,j)) Kill ^%SYS("sql","sys",i,j)
		}
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="Root">
<Description><![CDATA[
Returns the root directory of the unit test hierarchy, usually <b>^UnitTestRoot</b>.]]></Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set root=##class(%File).NormalizeDirectory($$$envSourceDir)_"internal/testing/unit_tests/"
	Set root=$g(^UnitTestRoot,root)
	Quit ##class(%File).NormalizeDirectory(root)
]]></Implementation>
</Method>

<Method name="AutoLoad">
<Description><![CDATA[
For each directory from <method>Root</method> down to <parameter>dir</parameter>, import the contents of sub-directory <parameter>sub</parameter>, 
returning classes in <parameter>classArray</parameter>.
This method is part of the implementation of the <b>/autoload</b> qualifier.]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[dir:%String,sub:%String,&classArray:%String,qstruct:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	s ret=$$$OK
	s root=..Root(),pwd=dir,prev="",dirlist=""
	s listonly=($$$qualifierGetValue(qstruct,"load")=0)
	; walk up the directory tree looking for /autoload directories
	f  q:prev=root!(pwd=prev)  d
	. s setup=##class(%File).SubDirectoryName(pwd,sub)
	. s:##class(%File).DirectoryExists(setup) dirlist=$lb(setup)_dirlist
	. s prev=pwd,pwd=##class(%File).ParentDirectoryName(pwd)
	; walk back down the directory tree loading /autoload directories
	Set fileset="",sep=""
	If $$$qualifierGetValue(qstruct,"loadxml") Set fileset="*.xml;*.XML",sep=";"
	If $$$qualifierGetValue(qstruct,"loadudl") Set fileset=fileset_sep_"*.cls;*.mac;*.int;*.inc;*.CLS;*.MAC;*.INT;*.INC"
	f i=1:1:$ll(dirlist) d
	. s status=$system.OBJ.ImportDir($lg(dirlist,i),fileset,.qstruct,,1,.classArray,listonly)
	. s:$$$ISOK(ret) ret=status
	q ret
]]></Implementation>
</Method>

<Method name="ConvertLogData">
<Description><![CDATA[
This method converts old format data in ^UnitTestLog to the new ^UnitTest.Result format.<br>
pLogIndex is the test instance index in ^UnitTestLog.<br>
pResultNamespace is the namespace for ^UnitTest.Result.<br>
pMachine, pConfiguration, pVersion and pUserParam are the new information ^UnitTest.Result collects 
but ^UnitTestLog does not. You can provide this information manually here when doing the conversion.<br>
pUserParam is used the same way as the userparam argument which is the 3rd argument to the RunTest method. 
The top node of pUserParam becomes UserParam and the first level subscripts and their values are used to populate the UserFields array.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pLogIndex,pResultNamespace="",pMachine="",pConfiguration="",pVersion="",pUserParam="",pKillLog=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	if pResultNamespace="" set pResultNamespace=$znspace
	lock +^|pResultNamespace|UnitTest.Result
	set tResultIndex=$o(^|pResultNamespace|UnitTest.Result(""),-1)+1
	lock -^|pResultNamespace|UnitTest.Result
	;
	write !,"Converting ^UnitTestLog("_pLogIndex_") to ^UnitTest.Result("_tResultIndex_") ... "
	;
	set iduration=0
	set suite="" for  {
		set suite=$o(^UnitTestLog(pLogIndex,suite),1,sdata) quit:suite=""
		set sduration=0
		set case="" for  {
			set case=$o(^UnitTestLog(pLogIndex,suite,case),1,cdata) quit:case=""
			set cduration=0
			set method="" for  {
				set method=$o(^UnitTestLog(pLogIndex,suite,case,method),1,mdata) quit:method=""
				set assert="" for  {
					set assert=$o(^UnitTestLog(pLogIndex,suite,case,method,assert),1,adata) quit:assert=""
					set status=$p(adata,":",1)
					set action=$p(adata,":",2)
					set message=$p(adata,":",3,999)
					set ^|pResultNamespace|UnitTest.Result(tResultIndex,suite,case,method,assert)=$lb(status,action,message)
				}
				set status=$p(mdata,":",1)
				set duration=+$p(adata,"1:LogMessage:Duration of execution: ",2)
				set action=$p($p(mdata,":",2),"()",1)
				set description=$p(mdata,":",3,999)
				set ^|pResultNamespace|UnitTest.Result(tResultIndex,suite,case,method)=$lb(status,duration,action,description)
				set cduration=cduration+duration
			}
			set status=$p(cdata,":",1)
			set action=$p($p(cdata,":",2),"()",1)
			set description=$p(cdata,":",3,999)
			set ^|pResultNamespace|UnitTest.Result(tResultIndex,suite,case)=$lb(status,cduration,action,description)
			set sduration=sduration+cduration
		}
		set status=$p(sdata,":",1)
		set action=$p($p(sdata,":",2),"()",1)
		set description=$p(sdata,":",3,999)
		set ^|pResultNamespace|UnitTest.Result(tResultIndex,suite)=$lb(status,sduration,action,description)
		set iduration=iduration+sduration
	}
	set datetime=$zdatetime(^UnitTestLog(pLogIndex),3)
	set userfieldslist="",key="" for  {
		set key=$o(pUserParam(key)) quit:key=""
		set userfieldslist=userfieldslist_$lb($lb(key,$g(pUserParam(key))))
	}
	set ^|pResultNamespace|UnitTest.Result(tResultIndex)=$lb(datetime,iduration,pMachine,pConfiguration,pVersion,$znspace,$g(pUserParam),userfieldslist)
	if pKillLog kill ^UnitTestLog(pLogIndex)
	;
	do ..ConvertStatus(tResultIndex,pResultNamespace)
	;
	quit $$$OK
]]></Implementation>
</Method>

<Method name="ConvertStatus">
<Description>
This method updates the status at each level recursively based on the status of the children
If pIndex is omitted, all the TestInstances will be converted.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pIndex,pNamespace</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If $g(pNamespace)="" Set pNamespace=$znspace
	If $g(pIndex)="" {
		Set tIndex="" For  {
			Set tIndex=$o(^|pNamespace|UnitTest.Result(tIndex)) Quit:tIndex=""
			Do ..ConvertStatus(tIndex,pNamespace)
		}
	} Else {
		Write !,"Converting Status for TestInstance "_pIndex_" ..."
		Do ..setRecursiveStatus(pNamespace,pIndex)
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="setRecursiveStatus">
<ClassMethod>1</ClassMethod>
<FormalSpec>pNamespace,pIndex,pSuite,pCase,pMethod</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	; status precedence order: failed, skipped, passed
	set sp(0)=3,sp(2)=2,sp(1)=1,sphighest=3,status=1
	If $g(pMethod)'="" {
		Set status=$li(^|pNamespace|UnitTest.Result(pIndex,pSuite,pCase,pMethod),1) Quit:status=sphighest status
		Set duration=$li(^|pNamespace|UnitTest.Result(pIndex,pSuite,pCase,pMethod),2)
		Set altered=0,action="" For  {
			Set action=$o(^|pNamespace|UnitTest.Result(pIndex,pSuite,pCase,pMethod,action)) Quit:action=""
			Set one=$li(^|pNamespace|UnitTest.Result(pIndex,pSuite,pCase,pMethod,action),1) if sp(one)>sp(status) set status=one,altered=1
			Quit:status=sphighest
		}
		If altered {
			Set ^|pNamespace|UnitTest.Result(pIndex,pSuite,pCase,pMethod)=$lb(status,duration,"","There are "_..GetTestState(status)_" TestAsserts")
			Write !,"  altered status for ",pIndex,":"_pSuite_":"_pCase_":"_pMethod_" to "_..GetTestState(status)
		}
		Quit status
	} Elseif $g(pCase)'="" {
		Set status=$li(^|pNamespace|UnitTest.Result(pIndex,pSuite,pCase),1) Quit:status=sphighest status
		Set duration=$li(^|pNamespace|UnitTest.Result(pIndex,pSuite,pCase),2)
		Set altered=0,tMethod="" For  {
			Set tMethod=$o(^|pNamespace|UnitTest.Result(pIndex,pSuite,pCase,tMethod)) Quit:tMethod=""
			Set one=..setRecursiveStatus(pNamespace,pIndex,pSuite,pCase,tMethod) if sp(one)>sp(status) set status=one,altered=1
		}
		If altered {
			Set ^|pNamespace|UnitTest.Result(pIndex,pSuite,pCase)=$lb(status,duration,"","There are "_..GetTestState(status)_" TestMethods")
			Write !,"  altered status for ",pIndex,":"_pSuite_":"_pCase_" to "_..GetTestState(status)
		}
		Quit status
	} Elseif $g(pSuite)'="" {
		Set status=$li(^|pNamespace|UnitTest.Result(pIndex,pSuite),1) Quit:status=sphighest status
		Set duration=$li(^|pNamespace|UnitTest.Result(pIndex,pSuite),2)
		Set altered=0,tCase="" For  {
			Set tCase=$o(^|pNamespace|UnitTest.Result(pIndex,pSuite,tCase)) Quit:tCase=""
			Set one=..setRecursiveStatus(pNamespace,pIndex,pSuite,tCase) if sp(one)>sp(status) set status=one,altered=1
		}
		If altered {
			Set ^|pNamespace|UnitTest.Result(pIndex,pSuite)=$lb(status,duration,"","There are "_..GetTestState(status)_" TestCases")
			Write !,"  altered status for ",pIndex,":"_pSuite_" to "_..GetTestState(status)
		}
		Quit status
	} Else {
		Set tSuite="" For  {
			Set tSuite=$o(^|pNamespace|UnitTest.Result(pIndex,tSuite)) Quit:tSuite=""
			Set one=..setRecursiveStatus(pNamespace,pIndex,tSuite) if sp(one)>sp(status) set status=one
		}
		Quit status
	}
	Quit 0
]]></Implementation>
</Method>

<Method name="CheckNameStructure">
<Description>
This method is used internally by Intersystems.
It checks unit test file names against internal source control requirements.
You should not make direct use of it within your applications.
There is no guarantee made about either the behavior or future operation of this method.</Description>
<Internal>1</Internal>
<FormalSpec>dir:%String</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
	try {
		s basenm=..Root()
		s rs=##class(%ResultSet).%New("%File:FileSet")
		Set fileset="",sep=""
		If ..LoadXML Set fileset="*.xml;*.XML",sep=";"
		If ..LoadUDL Set fileset=fileset_sep_"*.cls;*.CLS"
		s sc=rs.Execute(dir,fileset)
		if $$$ISERR(sc){
			d ..LogStateStatus(sc,"Source Control Naming Convention Check Failed")
			q
		}
		for {
			q:'rs.Next()
			s file=rs.Data("Name")
			//If Emacs-style *.xml~ backup files are present on a Windows system, they are found by the FileSet query.  Skip them here.
			continue:$case($zcvt($e(file,*-3,*),"l"),".xml":0,".cls":0,:1)
			s sc=$system.OBJ.Load(file,"-d",,.elmntlst,1)
			if $$$ISERR(sc) {
				d ..LogStateStatus(sc,"Source Control Naming Convention Check Failed")
				continue
			}
			s elmntcnt=0
			s hasclass=0
			s shortfile=$e(file,$l(basenm)+1,*-4)
			s shortfile=$tr(shortfile,"_\/]","%...")
			//Check to see if the file name corresponds to a syntactically valid class name - if it does, we want it to contain a class.
			s validfilename=$ZNAME(shortfile,4)
			s idx=$o(elmntlst(""))
			for {
				q:idx=""
				s elmntcnt=elmntcnt+1
				//If any of the elements in the file is a class, check that the class name matches the file name.
				if $zcvt($e(idx,*-3,*),"l")=".cls" {
					s hasclass=1
					s clsnm=$e(idx,1,*-4)
					if shortfile'=clsnm {
						s sc=$$$ERROR($$$GeneralError,"Expected "_file_" to contain a class named "_$tr(shortfile,"_","%")_" rather than "_clsnm)
						d ..LogStateStatus(sc,"Source Control Naming Convention Check Failed")
					}
				}
				s idx=$o(elmntlst(idx))
			}
			//Expect that a file with a file name that corresponds to a syntactically correct class name should contain a class.
			if validfilename,'hasclass {
				s sc=$$$ERROR($$$GeneralError,"Expected "_file_" to contain a class element because it corresponds to a valid class name")
				d ..LogStateStatus(sc,"Source Control Naming Convention Check Failed")
			}
			//Expect each file that contains a class to have exactly one element.
			if hasclass,elmntcnt'=1 {
				s sc=$$$ERROR($$$GeneralError,"More than one element, including at least one class, found in "_file)
				d ..LogStateStatus(sc,"Source Control Naming Convention Check Failed")
			}
		}
	}
	catch excpt {
		s sc=excpt.AsStatus()
		d ..LogStateStatus(sc,"Source Control Naming Convention Check Failed")
	}
]]></Implementation>
</Method>

<Method name="RecordNamespace">
<Description>
Internal method to log list of globals, routines in this namespace so we can cleanup after the tests</Description>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	New %gbl
	Set rtndb=$$GetGlobalSourceDatabase^%SYS.SECURITY($name(^ROUTINE("DemoRtn")))
	Set datadb=$$GetGlobalSourceDatabase^%SYS.SECURITY($name(^X))
	Set sc=$$GetGlobalDirectoryInfo^%SYS.DATABASE(datadb,$name(%gbl)) If $$$ISERR(sc) Quit sc
	#; Make sure we do not clean up the test results
	Set i%NSInfo("gbl","UnitTest.Result")="",i%NSInfo("gbl","UnitTest.ResultI")="",i%NSInfo("gbl","UnitTestRoot")=""
	#; Also leave the ^ERRORS global
	Set i%NSInfo("gbl","ERRORS")=""
	Set i=""
	For {
		Set i=$order(%gbl(i)) Quit:i=""
		If $data(@("^|"""_datadb_"""|"_i)) {
			Set i%NSInfo("gbl",i)=""
		}
	}
	Set i=""
	For {
		Set i=$order(^oddEXT(i)) Quit:i=""
		Set i%NSInfo("ext",i)=""
	}
	Merge i%NSInfo("rtn")=^|rtndb|rINDEX,i%NSInfo("cls")=^|rtndb|rINDEXCLASS
	Set i%NSInfo("$zs")=$zs
	
	#; Get list of existing PPGs
	#dim rset As %Library.ResultSet
	set rset=##class(%ResultSet).%New()
	set rset.ClassName="%SYS.ProcessQuery"
	set rset.QueryName="PPG"
	set sc=rset.Execute("*",-1,"N")
	if $$$ISERR(sc) Quit sc
	While rset.Next() {
		set ppg=rset.Data("key")
		Set i%NSInfo("ppg",ppg)=""
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="CleanNamespace">
<Description>
Internal method to clean the namespace after running a suite of tests</Description>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	New %gbl
	Set rtndb=$$GetGlobalSourceDatabase^%SYS.SECURITY($name(^ROUTINE("DemoRtn")))
	Set datadb=$$GetGlobalSourceDatabase^%SYS.SECURITY($name(^X))
	#; In case partition size was changed
	Set $zs=i%NSInfo("$zs")
	#; Remove routine/classes first
	Set cls=""
	For {
		Set cls=$order(^|rtndb|rINDEXCLASS(cls)) Quit:cls=""
		If '$data(i%NSInfo("cls",cls)) {
			Set name=$listget(^|rtndb|rINDEXCLASS(cls),2)
			Set remove(name)=""
		}
	}
	If $data(remove) {
		Do ..PrintLine("Removing classes left after test run:")
		Do Delete^%apiOBJ(.remove,"d")
	}
	Kill remove
	Set rtn="",first=1
	For {
		Set rtn=$order(^|rtndb|rINDEX(rtn)) Quit:rtn=""
		#; Assume unit test did not change type of rtn
		If '$data(i%NSInfo("rtn",rtn)) {
			For type="MAC","INT","MVI","BAS","INC","OBJ" {
				If '$data(^|rtndb|rINDEX(rtn,type)) Continue
				If '$data(i%NSInfo("rtn",rtn,type)) {
					If first {
						Set first=0
						Do ..PrintLine("Removing routines left after test run:")
					}
					Do ..PrintLine(rtn_"."_type,2)
					Set sc=$$Delete^%apiRTN(rtn_"."_type,0,0,0,0)
				}
			}
		}
	}
	If 'first Do ..PrintLine("")
	
	#; Now remove any new globals
	Set sc=$$GetGlobalDirectoryInfo^%SYS.DATABASE(datadb,$name(%gbl)) If $$$ISERR(sc) Quit sc
	Set i="",first=1
	For {
		Set i=$order(%gbl(i)) Quit:i=""
		If $extract(i,1,$length("DeepSee"))="DeepSee" Continue
		Set upper=$zconvert(i,"U")
		If $extract(upper)="Z"||($extract(upper,1,2)="%Z"),$extract(upper,1,3)'="ZEN",$extract(upper,1,4)'="%ZEN" Continue
		If '$data(i%NSInfo("gbl",i)) {
			If $data(@("^|"""_datadb_"""|"_i)) {
				If first {
					Set first=0
					Do ..PrintLine("Globals left after suite ran, killing them:")
				}
				Do ..PrintLine("^"_i,2)
			}
			Kill @("^|"""_datadb_"""|"_i)
		}
	}
	If 'first Do ..PrintLine("")
	#; Take care of PPG's
	#dim rset As %Library.ResultSet
	set rset=##class(%ResultSet).%New(),first=1
	set rset.ClassName="%SYS.ProcessQuery"
	set rset.QueryName="PPG"
	set sc=rset.Execute("*",-1,"N")
	if $$$ISERR(sc) Quit sc
	While rset.Next() {
		set ppg=rset.Data("key")
		If $data(i%NSInfo("ppg",ppg)) Continue
		If ppg="%ISC.WorkQueueMgr"||(ppg="TempLog")||(ppg="%ISCQueryTemp") Continue
		If first {
			Set first=0
			Do ..PrintLine("Removing PPGs left after suite ran:")
		}
		Do ..PrintLine("^||"_ppg,2)
		Kill @("^||"_ppg)
	}
	If $data(i%NSInfo("ext")) {
		Set i=""
		For {
			Set i=$order(^oddEXT(i)) Quit:i=""
			If '$data(i%NSInfo("ext",i)) {
				Kill ^oddEXT(i)
			}
		}
	}
	#; Purge all cached queries and unfreeze all frozen plan and clear SQL stats
	Do Purge^%SYS.SQLSRV()
	Do $SYSTEM.SQL.FreezePlans(0,1,,.Errors)
	do Purge^%SYS.PToolsDEP($NAMESPACE,"")			// MRP963  [DEPRECATED]
	do clearStatsSQL^%SYS.PTools($NAMESPACE,"")
	Quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
//  <dd>when globalName is null "", the file list is simply executed

]]></Content>
</UDLText>

<Method name="RunTestsFromFileList">
<Description><![CDATA[
Run tests based on a list in a file
<dl>
<dt>
<var>globalName</var>
<dd>globalName is the global in whose nodes test names and directory names will be stored
<dd>globalName must start with "^" or be null ""
<dd>when globalName starts with "^" a global of that name is loaded
</dt>
<dt>
<var>fileName</var>
<dd>fileName is a file whose lines contain the test names and/or directory names to be executed
</dt>
<dt><i>qualifiers</i> 
<dd>Any of the following command-line arguments can be combined as a single string, such as <b>/noload/norecursive</b>. All are optional.<br><br>
The first four (<b>debug</b>, <b>load</b>, <b>run</b>, and <b>recursive</b>) are negatable Booleans.  They can be turned on with <i>/arg</i> or off by adding <b>no</b> in the front, as <b>/noload</b> or adding <b>=0</b> to the end, as <b>/load=0</b>.<br><br> 

<b>/debug</b>: Run in debug mode, which causes a break if a test fails. Default is <b>/nodebug</b>. <br><br>
<b>/load</b>: Load use cases from the specified <i>testspec</i>. Default is <b>/load</b>. If <b>/load</b> and <b>/run</b> are both on, then all loaded classes, routines, and CSP files are deleted after the tests are run. To prevent them from being deleted at the end, load them with <b>DebugLoadTestSuite</b> and run them with <b>DebugRunTestCase</b>.<br><br>
<b>/run</b>: Run the test suite.  Use <b>/norun</b> if you only want to load, but not run, a suite into a namespace. Default is <b>/run</b>.<br><br>
<b>/recursive</b>: Recurse the specified directory when loading test classes. Default is <b>/recursive</b>.<br><br>
<b>/display=all</b>: Display extended information when loading exported test class definitions. <b>/display=none</b> displays limited information. Default is <b>/display=all</b>. <br><br>
<b>/autoload</b>: Automatically load sub-directories with the given name when loading test classes.
Default is <b>/autoload=_autoload</b>.
When this qualifier is set, classes are loaded from the given sub-directory of the current directory and its ancestors.
This makes it possible to use a class in multiple test suites without copying it to each of their directories.<br><br>
<b>/nodelete</b>: Do not delete loaded classes when the test is complete.<br><br>

<dt><i>userparam</i> 
<dd>An arbitrary argument passed in by the caller of the <b>UnitTest</b>.  The top node of this variable becomes the value for the <b>UserParam</b> property of the <b>Manager</b>.
The first level subscripts and their values are used to populate the <b>UserFields</b> array.
</dl>
<br><br>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>globalName:%String,fileName:%String,qualifiers,userparam</FormalSpec>
<Implementation><![CDATA[
	Set globalName=$g(globalName)
	QUIT:$e(globalName)'="^"&&($e(globalName)'="")
	s file = ##class(%FileCharacterStream).%New()
	s file.Filename = fileName
	
	if globalName="" {
		// just execute tests named in file, tests separated by line terminators
		while ('file.AtEnd) {
			s test = file.ReadLine()
			s test = $zstrip(test,"<>W")
			if ($L(test) > 0) && ($E(test,1) '= "#") {
				d ..RunTest(test, .qualifiers, $G(userparam))
			}
		}
	} else {
		// read tests in file into a global which is then executed
		while ('file.AtEnd) {
			s test = file.ReadLine()
			s test = $zstrip(test,"<>W")
			if ($L(test) > 0) && ($E(test,1) '= "#") {
				s @globalName@(test)=""
			}
		}
		d ..RunTest(globalName, .qualifiers, $G(userparam))
		
	}
	q
]]></Implementation>
</Method>

<Method name="OnAfterSaveResult">
<Description>
Called at the end of SaveResult() to perform any result aggregation tasks required by subtasks.</Description>
<FormalSpec><![CDATA[&userparam]]></FormalSpec>
</Method>

<Method name="OnBeforeAllTests">
<Description>
Called before any unit tests are run.
If an error status is returned, no unit tests are run.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[manager:test.testcoverage.ManagerBase,dir:%String,&qstruct,&userparam]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnAfterAllTests">
<Description>
Called after all unit tests are run.
If an error status is returned, it is logged.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[manager:test.testcoverage.ManagerBase,dir:%String,&qstruct,&userparam]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnBeforeAutoLoad">
<Description>
Called before autoload, which occurs before each test suite is run.
If an error status is returned, it is logged and the test suite is not run.</Description>
<FormalSpec><![CDATA[dir:%String,suite:%String,testspec:%String,&qstruct]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnBeforeTestSuite">
<Description>
Called a test suite is run.
If an error status is returned, it is logged and the test suite is not run.
This is called after autoload.</Description>
<FormalSpec><![CDATA[dir:%String,suite:%String,testspec:%String,&qstruct]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnAfterTestSuite">
<Description>
Called after a test suite is run.
If an error status is returned, it is logged.</Description>
<FormalSpec><![CDATA[dir:%String,suite:%String,testspec:%String,&qstruct]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnBeforeTestCase">
<Description><![CDATA[
Called before a test case (class extending <class>%UnitTest.TestCase</class>) is run.
If an error status is returned, it is logged and the test case is not run.]]></Description>
<FormalSpec>suite:%String,class:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnAfterTestCase">
<Description><![CDATA[
Called after a test case (class extending <class>%UnitTest.TestCase</class>) is run.
If an error status is returned, it is logged.]]></Description>
<FormalSpec>suite:%String,class:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnBeforeOneTest">
<Description><![CDATA[
Called before a test (method starting with "Test" in a class extending <class>%UnitTest.TestCase</class>) is run.
If an error status is returned, it is logged and the test is not run.]]></Description>
<FormalSpec>suite:%String,class:%String,method:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnAfterOneTest">
<Description><![CDATA[
Called after a test (method starting with "Test" in a class extending <class>%UnitTest.TestCase</class>) is run.
If an error status is returned, it is logged.]]></Description>
<FormalSpec>suite:%String,class:%String,method:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="test.testcoverage.Procedures">
<TimeChanged>65455,32452</TimeChanged>
<TimeCreated>65108,62300.981484</TimeCreated>

<Method name="BitValue">
<Description>
Wraps $Bit for exposure as an SQL stored procedure</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pSource:%Binary,pIndex:%Integer</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<SqlName>BIT_VALUE</SqlName>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[	Quit $Bit(pSource,pIndex)
]]></Implementation>
</Method>

<Method name="BitCount">
<Description>
Wraps $BitCount for exposure as an SQL stored procedure</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pSource:%Binary,pValue:%Boolean</FormalSpec>
<ReturnType>%Integer</ReturnType>
<SqlName>BIT_COUNT</SqlName>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
	If $Data(pValue) {
		Quit $BitCount(pSource, pValue)
	}
	Quit $BitCount(pSource)
]]></Implementation>
</Method>

<Method name="BitwiseAnd">
<Description><![CDATA[
Wrapper for $BitLogic(pArg1&pArg2) for exposure as an SQL stored procedure]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pArgs...</FormalSpec>
<ReturnType>%Binary</ReturnType>
<SqlName>BITWISE_AND</SqlName>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
	Set tResult = $Get(pArgs(1))
	For i=2:1:$Get(pArgs) {
		Set tResult = $BitLogic(tResult&pArgs(i))
	}
	Quit tResult
]]></Implementation>
</Method>

<Method name="BitwiseOr">
<Description>
Wrapper for $BitLogic(pArg1|pArg2) for exposure as an SQL stored procedure</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pArgs...</FormalSpec>
<ReturnType>%Binary</ReturnType>
<SqlName>BITWISE_OR</SqlName>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
	Set tResult = $Get(pArgs(1))
	For i=2:1:$Get(pArgs) {
		Set tResult = $BitLogic(tResult|pArgs(i))
	}
	Quit tResult
]]></Implementation>
</Method>

<Method name="BitwiseXor">
<Description>
Wrapper for $BitLogic(pArg1^pArg2) for exposure as an SQL stored procedure</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pArg1:%Binary,pArg2:%Binary</FormalSpec>
<ReturnType>%Binary</ReturnType>
<SqlName>BITWISE_XOR</SqlName>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[	Quit $BitLogic(pArg1^pArg2)
]]></Implementation>
</Method>

<Method name="BitwiseNot">
<Description>
Wrapper for $BitLogic(~pArg) for exposure as an SQL stored procedure</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pArg:%Binary</FormalSpec>
<ReturnType>%Binary</ReturnType>
<SqlName>BITWISE_NOT</SqlName>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[	Quit $BitLogic(~pArg)
]]></Implementation>
</Method>

<Method name="BitwiseOrList">
<Description>
Applies a bitwise OR to a $ListBuild list of bitstrings; input may be from the SQL %DLIST aggregate</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pSource:%List</FormalSpec>
<ReturnType>%Binary</ReturnType>
<SqlName>BITWISE_OR_LIST</SqlName>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
	Set tResult = ""
	Set tPointer = 0
	While $ListNext(pSource,tPointer,tItem) {
		Set tResult = $BitLogic(tResult|tItem)
	}
	Quit tResult
]]></Implementation>
</Method>

<Method name="BitwiseAndList">
<Description>
Applies a bitwise AND to a $ListBuild list of bitstrings; input may be from the SQL %DLIST aggregate</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pSource:%List</FormalSpec>
<ReturnType>%Binary</ReturnType>
<SqlName>BITWISE_AND_LIST</SqlName>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
	Set tResult = ""
	Set tPointer = 0
	While $ListNext(pSource,tPointer,tItem) {
		If (tResult = "") {
			Set tResult = tItem
		} Else {
			Set tResult = $BitLogic(tResult&tItem)
		}
	}
	Quit tResult
]]></Implementation>
</Method>

<Method name="ListToBit">
<Description>
Convert a $ListBuild list of integers into a $Bit with 1s in positions present in the list
Use in SQL with the %DLIST aggregate</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pSource:%List</FormalSpec>
<ReturnType>%Binary</ReturnType>
<SqlName>LIST_TO_BIT</SqlName>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
	Set tResult = ""
	Set tPointer = 0
	While $ListNext(pSource,tPointer,tBitPosition) {
		Set $Bit(tResult,tBitPosition) = 1
	}
	Quit tResult
]]></Implementation>
</Method>

<Query name="Sequence">
<Description><![CDATA[
Table-valued function returning a sequence of integers (column name "Counter") going from <var>pStart</var> to <var>pEnd</var> by <var>pIncrement</var>.]]></Description>
<Type>%Query</Type>
<FormalSpec>pStart:%Integer,pEnd:%Integer,pIncrement:%Integer=1</FormalSpec>
<SqlName>SEQUENCE</SqlName>
<SqlProc>1</SqlProc>
<Parameter name="ROWSPEC" value="Counter:%Integer"/>
</Query>

<Method name="SequenceExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,pStart:%Integer,pEnd:%Integer,pIncrement:%Integer=1]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set qHandle = pStart
	Set qHandle("inc") = pIncrement
	Set qHandle("end") = pEnd
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="SequenceClose">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>SequenceExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="SequenceFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>SequenceExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set Row = $ListBuild(qHandle)
	If ($Increment(qHandle,qHandle("inc")) > qHandle("end")) {
		Set AtEnd = 1
	}
	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="test.testcoverage.Report.AbstractReportGenerator">
<Description>
@API.Extensible</Description>
<Abstract>1</Abstract>
<TimeChanged>65455,32452</TimeChanged>
<TimeCreated>65108,62301.458085</TimeCreated>

<Method name="GenerateReport">
<Description>
@API.Method
@API.Overrideable</Description>
<Abstract>1</Abstract>
<ClassMethod>1</ClassMethod>
<FormalSpec>pRunIndex:%Integer,pOutputFileName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
</Method>
</Class>


<Class name="test.testcoverage.Report.Cobertura.ReportGenerator">
<IncludeCode>TestCoverage</IncludeCode>
<Super>test.testcoverage.Report.AbstractReportGenerator</Super>
<TimeChanged>65455,32452</TimeChanged>
<TimeCreated>65108,62301.461284</TimeCreated>

<Method name="GenerateReport">
<ClassMethod>1</ClassMethod>
<FormalSpec>pRunIndex:%Integer,pOutputFileName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tCoverage = ##class(test.testcoverage.Report.Cobertura.type.coverage).%New()
		Set tCoverage.version = ##class(test.testcoverage.Report.Cobertura.Schema).#VERSION
		Set tCoverage.timestamp = $zdatetime($ztimestamp,-2) * 1000
		
		// Summary statistics
		&sql(select
				ROUND(CoveredLines/ExecutableLines,4),
				ExecutableLines,
				CoveredLines
			into :tLineRate,:tLinesValid,:tLinesCovered
			from test_testcoverage_Data_Aggregate.ByRun where ExecutableLines > 0 and Run = :pRunIndex)
		If (SQLCODE < 0) {
			Throw ##class(%Exception.SQL).CreateFromSQLCODE(SQLCODE,%msg)
		}
		
		If (SQLCODE = 100) {
			Set tLineRate = 0
			Set tLinesCovered = 0
			Set tLinesValid = 0
		}
		
		Set tCoverage.linerate = tLineRate
		Set tCoverage.linescovered = tLinesCovered
		Set tCoverage.linesvalid = tLinesValid
		
		// For now:
		#define EMPTYBRANCHRATE ""
		#define EMPTYCOMPLEXITY ""
		Set tCoverage.branchescovered = 0
		Set tCoverage.branchesvalid = 0
		Set tCoverage.branchrate = $$$EMPTYBRANCHRATE
		Set tCoverage.complexity = $$$EMPTYCOMPLEXITY
		
		// Create directory for source code export
		Set tSourceDirectory = ##class(%Library.File).GetDirectory(pOutputFileName,1)_"source"
		$$$ThrowOnError(##class(test.testcoverage.Utils.File).CreateDirectoryChain(tSourceDirectory))
		
		Do tCoverage.sources.Insert(tSourceDirectory)
		
		// Package-level results
		Set tTestPath = $$$TestPathAllTests
		Set tResults = ##class(%SQL.Statement).%ExecDirect(,
			"SELECT ID from test_testcoverage_Data.Coverage "_
			"WHERE Run = ? and TestPath = ? and Ignore = 0 And Hash->Type in ('CLS','MAC')",pRunIndex,tTestPath)
		If (tResults.%SQLCODE < 0) {
			Throw ##class(%Exception.SQL).CreateFromSQLCODE(tResults.%SQLCODE,tResults.%Message)
		}
		While tResults.%Next(.tSC) {
			$$$ThrowOnError(tSC)
			Set tCoverageData = ##class(test.testcoverage.Data.Coverage).%OpenId(tResults.%Get("ID"),,.tSC)
			$$$ThrowOnError(tSC)
			Set tCodeUnit = tCoverageData.Hash
			Set tFileName = $Replace(tCodeUnit.Name,".","/")_"."_$ZConvert(tCodeUnit.Type,"L")
			Set tFullName = ##class(%Library.File).NormalizeFilename(tSourceDirectory_"/"_tFileName)
			Set tDirectory = ##class(%Library.File).GetDirectory(tFullName)
			$$$ThrowOnError(##class(test.testcoverage.Utils.File).CreateDirectoryChain(tDirectory))
			Set tStream = ##class(%Stream.FileCharacter).%New()
			$$$ThrowOnError(tStream.LinkToFile(tFullName))
			$$$ThrowOnError(tCoverageData.Hash.ExportToStream(tStream))
			$$$ThrowOnError(tStream.%Save())
			
			Set tCoveredLineCount = $BitCount($BitLogic(tCodeUnit.ExecutableLines&tCoverageData.CoveredLines),1)
			Set tValidLineCount = $BitCount(tCodeUnit.ExecutableLines,1)
			
			// Class
			Set tClass = ##class(test.testcoverage.Report.Cobertura.type.class).%New()
			Set tClass.name = tCodeUnit.Name
			Set tClass.filename = tFileName
			Set tClass.linerate = $Case(tValidLineCount,0:1,:tCoveredLineCount/tValidLineCount)
			Set tClass.branchrate = $$$EMPTYBRANCHRATE
			Set tClass.complexity = $$$EMPTYCOMPLEXITY
			Set tTotalMethodComplexity = 0
			
			// Lines
			Set tLineNumber = 0
			For {
				Set tLineNumber = $BitFind(tCodeUnit.ExecutableLines,1,tLineNumber+1)
				If (tLineNumber = 0) || (tLineNumber = "") {
					Quit
				}
				Set tLine = ##class(test.testcoverage.Report.Cobertura.type.line).%New()
				Set tLine.number = tLineNumber
				Set tLine.branch = "false"
				Set tLine.hits = +tCoverageData.RtnLine.GetAt(tLineNumber)
				Do tClass.lines.Insert(tLine)
			}
			
			// Methods
			Set tMethodKey = ""
			For {
				Set tSubUnit = tCodeUnit.SubUnits.GetNext(.tMethodKey)
				If (tMethodKey = "") {
					Quit
				}
				If tSubUnit.%IsA("test.testcoverage.Data.CodeSubUnit.Method") {
					Set tMethod = ##class(test.testcoverage.Report.Cobertura.type.method).%New()
					Set tMethod.name = $Piece(tSubUnit.DisplaySignature," ")_" "_tSubUnit.Name //ClassMethod/Method and method name only
					Set tMethod.signature = $c(0) // Interpretation is tied to Java, so we just use the method name (above).
					Set tExecutableMethodLines = $BitLogic(tCodeUnit.ExecutableLines&tSubUnit.Mask)
					Set tExecutableCount = $BitCount(tExecutableMethodLines,1)
					Set tMethod.linerate = $Case(tExecutableCount, 0:1,
						:$BitCount($BitLogic(tExecutableMethodLines&tCoverageData.CoveredLines),1) / tExecutableCount)
					Set tMethod.branchrate = $$$EMPTYBRANCHRATE
					Set tMethod.complexity = tSubUnit.Complexity
					Set tTotalMethodComplexity = tTotalMethodComplexity + tMethod.complexity
					Set tLineNumber = 0
					For {
						Set tLineNumber = $BitFind(tExecutableMethodLines,1,tLineNumber+1)
						If (tLineNumber = 0) || (tLineNumber = "") {
							Quit
						}
						Set tLine = ##class(test.testcoverage.Report.Cobertura.type.line).%New()
						Set tLine.number = tLineNumber
						Set tLine.branch = "false"
						Set tLine.hits = +tCoverageData.RtnLine.GetAt(tLineNumber)
						Do tMethod.lines.Insert(tLine)
					}
					Do tClass.methods.Insert(tMethod)
				}
			}
			
			Set tMethodCount = tClass.methods.Count()
			If (tMethodCount > 0) {
				Set tClass.complexity = tTotalMethodComplexity/tMethodCount
			}
			
			If (tCodeUnit.Type = "CLS") {
				Set tPackageSub = $Piece(tCodeUnit.Name,".",1,*-1)
				Set tMemberSub = $Piece(tCodeUnit.Name,".",*)
			} Else {
				Set tPackageSub = $c(0)
				Set tMemberSub = tCodeUnit.Name_"."_tCodeUnit.Type
			}
			
			Set tOldCoveredCount = 0
			Set tOldValidCount = 0
			If $Data(tPackages(tPackageSub),tOldCounts) {
				Set $ListBuild(tOldCoveredCount,tOldValidCount) = tOldCounts
			}
			Set tPackages(tPackageSub) = $ListBuild(tOldCoveredCount + tCoveredLineCount, tOldValidCount + tValidLineCount)
			Set tPackages(tPackageSub,tMemberSub) = tClass
		}
		$$$ThrowOnError(tSC)
		
		// Package-level aggregation
		Set tTotalComplexity = 0
		Set tPackageSub = ""
		For {
			Set tPackageSub = $Order(tPackages(tPackageSub),1,tCounts)
			If (tPackageSub = "") {
				Quit
			}
			Set tPackage = ##class(test.testcoverage.Report.Cobertura.type.package).%New()
			Set tPackage.name = tPackageSub
			Set tPackage.linerate = $Case($ListGet(tCounts,2), 0:1, :$ListGet(tCounts)/$ListGet(tCounts,2))
			Set tPackage.branchrate = $$$EMPTYBRANCHRATE
			Set tPackage.complexity = $$$EMPTYCOMPLEXITY
			Set tTotalClassComplexity = 0
			
			Set tMemberSub = ""
			For {
				Set tMemberSub = $Order(tPackages(tPackageSub,tMemberSub),1,tMember)
				If (tMemberSub = "") {
					Quit
				}
				Set tTotalClassComplexity = tTotalClassComplexity + tMember.complexity
				Do tPackage.classes.Insert(tMember)
			}
			
			Set tClassCount = tPackage.classes.Count()
			If (tClassCount > 0) {
				Set tPackage.complexity = tTotalClassComplexity/tClassCount
			}
			
			Set tTotalComplexity = tTotalComplexity + tPackage.complexity
			Do tCoverage.packages.Insert(tPackage)
		}
		
		// Coverage-level complexity aggregation
		Set tPackageCount = tCoverage.packages.Count()
		If (tPackageCount > 0) {
			Set tCoverage.complexity = tTotalComplexity/tPackageCount
		}
		
		// Actual XML export
		Set tStream = ##class(%Stream.FileCharacter).%New()
		Set tSC = tStream.LinkToFile(pOutputFileName)
		Do tStream.WriteLine("<?xml version=""1.0"" ?>")
		Do tStream.WriteLine("<!DOCTYPE coverage SYSTEM ""http://cobertura.sourceforge.net/xml/coverage-04.dtd"">")
		Do tStream.WriteLine()
		$$$ThrowOnError(tSC)
		Set tSC = tCoverage.XMLExportToStream(tStream,,",literal,indent")
		$$$ThrowOnError(tSC)
		
		$$$ThrowOnError(tStream.%Save())
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="test.testcoverage.Report.Cobertura.Schema">
<TimeChanged>65455,32452</TimeChanged>
<TimeCreated>65108,62301.470391</TimeCreated>

<Projection name="ClassGenerator">
<Type>test.testcoverage.Utils.Projection.SchemaGenerator</Type>
<Parameter name="PACKAGE" value="test.testcoverage.Report.Cobertura.type"/>
</Projection>

<Parameter name="VERSION">
<Default>2.1.1</Default>
</Parameter>

<XData name="XSD">
<Description>
Based on https://github.com/cobertura/cobertura/blob/master/cobertura/src/site/htdocs/xml/coverage-loose.dtd
Converted from DTD to XSD using Visual Studio's tool for such conversions, then edited to produce the correct
projection of list properties (most significantly, using "type" rather than "ref" in sequences representing collections)</Description>
<Data><![CDATA[
<?xml version="1.0" encoding="utf-8"?>
<xs:schema xmlns="http://www.intersystems.com/healthshare/tools/coverage" elementFormDefault="qualified" targetNamespace="http://www.intersystems.com/healthshare/tools/coverage" xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <xs:element name="coverage">
    <xs:complexType>
      <xs:sequence>
        <xs:element minOccurs="0" maxOccurs="1" name="sources" type="sources" />
        <xs:element name="packages" type="packages" />
      </xs:sequence>
      <xs:attribute name="line-rate" type="xs:string" />
      <xs:attribute name="branch-rate" type="xs:string" />
      <xs:attribute name="lines-covered" type="xs:string" />
      <xs:attribute name="lines-valid" type="xs:string" />
      <xs:attribute name="branches-covered" type="xs:string" />
      <xs:attribute name="branches-valid" type="xs:string" />
      <xs:attribute name="complexity" type="xs:string" />
      <xs:attribute name="version" type="xs:string" use="required" />
      <xs:attribute name="timestamp" type="xs:string" use="required" />
    </xs:complexType>
  </xs:element>
  <xs:complexType name="sources">
    <xs:sequence>
      <xs:element minOccurs="0" maxOccurs="unbounded" name="source" type="xs:string" />
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="packages">
    <xs:sequence>
      <xs:element minOccurs="0" maxOccurs="unbounded" name="package" type="package" />
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="classes">
    <xs:sequence>
      <xs:element minOccurs="0" maxOccurs="unbounded" name="class" type="class" />
    </xs:sequence>
  </xs:complexType>
  <xs:element name="package">
    <xs:complexType>
      <xs:sequence>
        <xs:element name="classes" type="classes" />
      </xs:sequence>
      <xs:attribute name="name" type="xs:string" use="required" />
      <xs:attribute name="line-rate" type="xs:string" />
      <xs:attribute name="branch-rate" type="xs:string" />
      <xs:attribute name="complexity" type="xs:string" />
    </xs:complexType>
  </xs:element>
  <xs:element name="class">
    <xs:complexType>
      <xs:sequence>
        <xs:element name="methods" type="methods" />
        <xs:element name="lines" type="lines" />
      </xs:sequence>
      <xs:attribute name="name" type="xs:string" use="required" />
      <xs:attribute name="filename" type="xs:string" use="required" />
      <xs:attribute name="line-rate" type="xs:string" />
      <xs:attribute name="branch-rate" type="xs:string" />
      <xs:attribute name="complexity" type="xs:string" />
    </xs:complexType>
  </xs:element>
  <xs:complexType name="methods">
    <xs:sequence>
      <xs:element minOccurs="0" maxOccurs="unbounded" name="method" type="method" />
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="lines">
    <xs:sequence>
      <xs:element minOccurs="0" maxOccurs="unbounded" name="line" type="line" />
    </xs:sequence>
  </xs:complexType>
  <xs:element name="method">
    <xs:complexType>
      <xs:sequence>
        <xs:element name="lines" type="lines" />
      </xs:sequence>
      <xs:attribute name="name" type="xs:string" use="required" />
      <xs:attribute name="signature" type="xs:string" use="required" />
      <xs:attribute name="line-rate" type="xs:string" />
      <xs:attribute name="branch-rate" type="xs:string" />
      <xs:attribute name="complexity" type="xs:string" />
    </xs:complexType>
  </xs:element>
  <xs:element name="line">
    <xs:complexType>
      <xs:sequence>
        <xs:element minOccurs="0" maxOccurs="unbounded" name="conditions" type="conditions" />
      </xs:sequence>
      <xs:attribute name="number" type="xs:string" use="required" />
      <xs:attribute name="hits" type="xs:string" />
      <xs:attribute default="false" name="branch" type="xs:string" />
      <xs:attribute name="condition-coverage" type="xs:string" />
    </xs:complexType>
  </xs:element>
  <xs:complexType name="conditions">
    <xs:sequence>
      <xs:element minOccurs="0" maxOccurs="unbounded" name="condition" type="condition" />
    </xs:sequence>
  </xs:complexType>
  <xs:element name="condition">
    <xs:complexType>
      <xs:attribute name="number" type="xs:string" use="required" />
      <xs:attribute name="type" type="xs:string" use="required" />
      <xs:attribute name="coverage" type="xs:string" use="required" />
    </xs:complexType>
  </xs:element>
</xs:schema>
]]></Data>
</XData>
</Class>


<Class name="test.testcoverage.UI.AggregateResultViewer">
<Super>test.testcoverage.UI.Template</Super>
<TimeChanged>65455,32452</TimeChanged>
<TimeCreated>65108,62301.507976</TimeCreated>

<Parameter name="PAGENAME">
<Description>
Displayed name of this page.</Description>
<Default>Unit Test Coverage - Aggregate Results</Default>
</Parameter>

<Parameter name="DOMAIN">
<Description>
Domain used for localization.</Description>
</Parameter>

<Property name="testIndex">
<Type>%ZEN.Datatype.string</Type>
<Parameter name="ZENURL" value="Index"/>
</Property>

<XData name="Contents">
<Description>
This XML block defines the contents of this page.</Description>
<XMLNamespace>http://www.intersystems.com/zen</XMLNamespace>
<Data><![CDATA[
<page xmlns="http://www.intersystems.com/zen" xmlns:tc="http://www.intersystems.com/zen/healthshare/test-coverage" title="Unit Test Coverage - Aggregate Results">
<vgroup width="80%" align="center">
<vgroup labelPosition="left" align="left" enclosingClass="box" layout="horizontal">
<tc:select id="testIndex" value="#(%page.testIndex)#" label="Test Index" sql="select distinct Run from test_testcoverage_Data_Aggregate.ByRun order by Run desc" onchange="zenPage.testFilterChanged(zenThis)" />
<spacer width="25%" />
<tc:testResultsLink id="testResultsLink" coverageRunId="#(%page.testIndex)#" />
</vgroup>
<vgroup labelPosition="left" align="left" enclosingClass="box" layout="none">
<altJSONSQLProvider id="aggregateDataProvider" maxRows="10000"
	sql="	select 'Overall' As &quot;Routine&quot;,
				ROUND(100*CoveredLines/ExecutableLines,2) &quot;Percent Coverage&quot;,
				ExecutableLines &quot;Executable Lines&quot;,
				CoveredLines As &quot;Lines Covered&quot;,
				ROUND(100*CoveredMethods/ExecutableMethods,2) &quot;Method Coverage&quot;,
				ExecutableMethods As &quot;Executable Methods&quot;,
				CoveredMethods As &quot;Methods Covered&quot;,
				'' as Info,
				1 as TopSortOrder
			from test_testcoverage_Data_Aggregate.ByRun where ExecutableLines > 0 and Run = ?
			union all
			select CodeUnit->Name||'.'||CodeUnit->Type,
				ROUND((CoveredLines/ExecutableLines)*100,2),
				ExecutableLines,
				CoveredLines,
				CASE ExecutableMethods WHEN 0 THEN NULL ELSE ROUND((CoveredMethods/ExecutableMethods)*100,2) END,
				ExecutableMethods,
				CoveredMethods,
				CodeUnit /* for link to detail */,
				2
			from test_testcoverage_Data_Aggregate.ByCodeUnit where ExecutableLines > 0 and Run = ?
			order by TopSortOrder,Routine">
<parameter paramName="1" value="#(%page.testIndex)#" />
<parameter paramName="2" value="#(%page.testIndex)#" />
</altJSONSQLProvider>

<tc:dataGrid id="aggregateDataGrid" controllerId="aggregateDataProvider" width="100%" ondrawcell="return zenPage.drawCell(value,row,col);">
<columnDescriptor caption="Code Unit" type="string" readOnly="true"/>

<columnDescriptor caption="% Lines" type="string" readOnly="true"/>
<columnDescriptor caption="# Lines" type="string" readOnly="true"/>
<columnDescriptor caption="# Covered" type="string" readOnly="true"/>

<columnDescriptor caption="% Methods" type="string" readOnly="true"/>
<columnDescriptor caption="# Methods" type="string" readOnly="true"/>
<columnDescriptor caption="# Covered" type="string" readOnly="true"/>

<columnDescriptor />
</tc:dataGrid>
</vgroup>
</vgroup>
</page>
]]></Data>
</XData>

<Method name="testFilterChanged">
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	zenPage.testIndex = zen('testIndex').getValue();
	zen('aggregateDataProvider').reloadContentsAsynch(function() {
		zen('aggregateDataProvider').raiseDataChange();
	});
	zen('testResultsLink').refreshContents(true);
]]></Implementation>
</Method>

<Method name="drawCell">
<FormalSpec>value,row,col</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if ((col == 2) || (col == 5)) {
		// Fix value to 2 decimal places
		var text = (value === '') ? '' : parseFloat(value).toFixed(2);
		return {
			content:'<strong>'+text+'</strong>',
			align:'right'
		};
	} else if (col == 8) { //Info
		var html = [];
		if (value != '') {
			var testIndex = encodeURIComponent(zenPage.testIndex);
			var codeUnit = encodeURIComponent(value);
			var url = 'test.testcoverage.UI.ResultDetailViewer.cls?testIndex='+testIndex+'&codeUnit='+codeUnit;
			html.push('<a target="_blank" href="'+url+'" class="elevated">');
			html.push('[detail]');
			html.push('</a>');
		}
		return {
			content:html.join('')
		};
	}
]]></Implementation>
</Method>
</Class>


<Class name="test.testcoverage.UI.Application">
<Description>
test.testcoverage.UI.Application</Description>
<Super>%ZEN.application</Super>
<TimeChanged>65455,32452</TimeChanged>
<TimeCreated>65108,62301.539489</TimeCreated>

<Parameter name="APPLICATIONNAME">
<Description>
This is the name of this application.</Description>
</Parameter>

<Parameter name="HOMEPAGE">
<Description>
This is the URL of the main starting page of this application.</Description>
</Parameter>

<Parameter name="JSINCLUDES">
<Description>
Comma-separated list of additional JS include files that should be
included for every page within the application.</Description>
<Type>STRING</Type>
<Default>jquery-2.0.3.min.js</Default>
</Parameter>

<XData name="Style">
<Description>
This Style block contains application-wide CSS style definitions.</Description>
<Data><![CDATA[
<style type="text/css">
/* For dataGrid links */
a.elevated {
	z-index: 2;
	position: relative;
}

/* body/box/pre.coverage styles derived from MIT-licensed work: */
/*
Copyright (c) 2018 by Ole Bertram (https://codepen.io/elomatreb/pen/hbgxp)

Permission is hereby granted, free of charge, to any person obtaining a copy of this software
and associated documentation files (the "Software"), to deal in the Software without restriction,
including without limitation the rights to use, copy, modify, merge, publish, distribute,
sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or
substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
body {
	background-color: #eee;
	color: #555;
}

/* Modified from pre.coverage */
.box {
	background-color: #fff;
	padding: 0.5em;
	margin-top: 2em;
	border-radius: .25em;
	box-shadow: 0.1em 0.1em 0.5em rgba(0, 0, 0, 0.45);
}

pre.coverage {
	font-family: monospace;
	background-color: #fff;
	margin-top: 2em;
	margin-left: 4em auto;
	margin-right: 4em auto;
	padding: 0.5em;
	border-radius: .25em;
	box-shadow: 0.1em 0.1em 0.5em rgba(0, 0, 0, 0.45);
	line-height: 0;
	counter-reset: line;
	max-width: 80vw;
	max-height: 75vh;
	overflow-x: auto;
}
pre.coverage span {
	white-space: pre;
	tab-size: 4;
	display: block;
	line-height: 1.5em;
	width: 100%;
}
pre.coverage span:before {
	counter-increment: line;
	content: counter(line);
	display: inline-block;
	border-right: 1px solid #ddd;
	padding: 0 .5em;
	margin-right: .5em;
	min-width: 3em;
	color: #888;
}

/* Classes for display of code coverage */
pre.coverage span.executable:before {
	background-color: #f66;
}

pre.coverage span.covered:before {
	background-color: #6f6;
}

pre.coverage span.hide:before {
	background-color: #fff;
}

</style>
]]></Data>
</XData>
</Class>


<Class name="test.testcoverage.UI.CodeMapExplorer">
<Super>%ZEN.Component.page</Super>
<TimeChanged>65455,32452</TimeChanged>
<TimeCreated>65108,62301.747129</TimeCreated>

<Property name="generatedHash">
<Type>%ZEN.Datatype.string</Type>
</Property>

<Property name="sourceHash">
<Type>%ZEN.Datatype.string</Type>
</Property>

<XData name="Contents">
<XMLNamespace>http://www.intersystems.com/zen</XMLNamespace>
<Data><![CDATA[
<page xmlns="http://www.intersystems.com/zen" xmlns:tc="http://www.intersystems.com/zen/healthshare/test-coverage" title="Unit Test Coverage - Code Map Explorer">
<!-- Generated-to-source mode -->
<hgroup labelPosition="left">
<tc:select id="fromCode" sql="select distinct FromHash,FromHash->Name||'.'||FromHash->Type from test_testcoverage_Data.CodeUnitMap" label="From" onchange="zenPage.setProperty('generatedHash',zenThis.getValue());zen('toCode').refreshContents();"/>
<tc:select id="toCode" sql="select distinct ToHash,ToHash->Name||'.'||ToHash->Type from test_testcoverage_Data.CodeUnitMap where FromHash = ?" label="To" onchange="zenPage.setProperty('sourceHash',zenThis.getValue());">
<parameter value="#(%page.generatedHash)#" />
</tc:select>
<button caption="Go" onclick="zen('codeTable').executeQuery();" />
</hgroup>
<tablePane id="codeTable" maxRows="1000" initialExecute="false" sql="
	select gen.element_key FromLine, gen.Lines FromCode, source.element_key ToLine, source.Lines ToCode from test_testcoverage_Data.CodeUnit_Lines gen
	left join test_testcoverage_Data.CodeUnitMap map
		on map.FromHash = gen.CodeUnit
		and map.FromLine = gen.element_key
		and map.ToHash = ?
	left join test_testcoverage_Data.CodeUnit_Lines source
		on map.ToHash = source.CodeUnit
		and map.ToLine = source.element_key
	where gen.CodeUnit = ?
">
<parameter value="#(%page.sourceHash)#" />
<parameter value="#(%page.generatedHash)#" />
<column header="#" colName="FromLine" />
<column header="Generated" colName="FromCode" />
<column header="#" colName="ToLine" />
<column header="Source" colName="ToCode" />
</tablePane>
</page>
]]></Data>
</XData>
</Class>


<Class name="test.testcoverage.UI.Component.dataGrid">
<Super>%ZEN.Component.dataGrid</Super>
<System>3</System>
<TimeChanged>65455,32452</TimeChanged>
<TimeCreated>65108,62301.761056</TimeCreated>

<Parameter name="NAMESPACE">
<Description>
This is the XML namespace for this component.</Description>
<Default>http://www.intersystems.com/zen/healthshare/test-coverage</Default>
</Parameter>

<Method name="gridKeyBlur">
<Description>
Focus taken from the grid's invisible edit control.
Overridden to avoid switching cell focus and consequently scrolling the grid (a major usability annoyance)</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[	this.hasFocus = false;
]]></Implementation>
</Method>
</Class>


<Class name="test.testcoverage.UI.Component.select">
<Description>
%ZEN.Component.select customized to behave in more expected ways with an SQL data source and parameters</Description>
<Super>%ZEN.Component.select</Super>
<System>3</System>
<TimeChanged>65455,32453</TimeChanged>
<TimeCreated>65108,62301.872193</TimeCreated>

<Parameter name="NAMESPACE">
<Description>
This is the XML namespace for this component.</Description>
<Default>http://www.intersystems.com/zen/healthshare/test-coverage</Default>
</Parameter>

<Property name="autoExecute">
<Description>
Set to true (default) to automatically reexecute the query when a parameter changes</Description>
<Type>%ZEN.Datatype.boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Method name="%DrawHTML">
<Description>
Overridden to allow zen expressions in initial value.</Description>
<Implementation><![CDATA[
	Set tSC = ..%BuildValueLists(.tValueList,.tDisplayList)

	If $$$ISERR(tSC) {
		Do ##class(%ZEN.Utils).%DisplayErrorHTML($this,tSC)
		Quit
	}

	#; <select> does not support readOnly
	#; so we use disabled for both
	Set disabled = $S(..disabled||..readOnly:"disabled",1:"")
	Set tValue = $$$ZENVAL(..value)

	&html<<select class="#(..controlClass)#" id="#(..%MakeId("control"))#" #(..%Name())# #(..%Attr("title",..title))# #(disabled)# #(..%Attr("size",..size))# #(..%Attr("style",..controlStyle))# #(..%Attr("tabindex",..tabIndex))# #(..%GetEventHandlers())#>>

	If (..showEmpty) {
		#; empty item for value of ""
		&html<<option #($S(""=..value:"selected=""1""",1:""))#>#($ZCVT(..emptyText,"O","HTML"))#</option>>
	}

	// Also replaced a bunch of $ListGets with $ListNext, which is faster.
	Set tDisplayPointer = 0
	Set tValuePointer = 0
	While $ListNext(tDisplayList,tDisplayPointer,tDisplayItem) && $ListNext(tValueList,tValuePointer,tValueItem) {
		Set tDisplayItem = $$$ZENVAL($Get(tDisplayItem))
		Set tValueItem = $$$ZENVAL($Get(tValueItem))
		&html<<option #($S(tValueItem=tValue:"selected=""1""",1:""))# value="#($ZCVT(tValueItem,"O","HTML"))#">#($ZCVT(tDisplayItem,"O","HTML"))#</option>>
	}

	&html<</select>>
]]></Implementation>
</Method>

<Method name="setProperty">
<Description>
Set the value of a named property.
Overridden to allow parameters to be set.</Description>
<FormalSpec>property,value,value2</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var el = this.findElement('control');

	switch(property) {
	case 'parameters':
		if ('' != value) {
			value = value - 1;
			if (this.parameters[value]) {
				if (this.parameters[value].value != value2) {
					this.parameters[value].value = value2;
					if (this.autoExecute) { this.triggerRefresh(); }
				}
			}
		}
		break;
	default:
		// dispatch
		return this.invokeSuper('setProperty',arguments);
	}
	return true;
]]></Implementation>
</Method>

<Method name="triggerRefresh">
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	this._refreshing = true;
	this.setDisabled(true);
	this.refreshContents();
]]></Implementation>
</Method>

<Method name="onRefreshContents">
<Description>
This client callback is called just from refreshContents
just after the new HTML is delivered from the server.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (this._refreshing == true) {
		this.setDisabled(false);
	}
]]></Implementation>
</Method>
</Class>


<Class name="test.testcoverage.UI.Component.testResultsLink">
<Super>%ZEN.Component.link</Super>
<System>3</System>
<TimeChanged>65455,32453</TimeChanged>
<TimeCreated>65108,62301.8673</TimeCreated>

<Parameter name="NAMESPACE">
<Description>
This is the XML namespace for this component.</Description>
<Default>http://www.intersystems.com/zen/healthshare/test-coverage</Default>
</Parameter>

<Property name="coverageRunId">
<Description><![CDATA[
ID of the instance of <class>test.testcoverage.Data.Run</class> for which the associated test results should be shown.]]></Description>
<Type>%ZEN.Datatype.string</Type>
<Parameter name="ZENEXPRESSION" value="1"/>
</Property>

<Property name="caption">
<Description><![CDATA[
Text to display for the link.<br>
This value is interpreted as text, not HTML.<br>
Overridden to add a default.]]></Description>
<Type>%ZEN.Datatype.caption</Type>
<InitialExpression>"View Test Results"</InitialExpression>
<Parameter name="ZENEXPRESSION" value="1"/>
</Property>

<Property name="target">
<Description>
Overridden to default to "_blank"</Description>
<Type>%ZEN.Datatype.string</Type>
<InitialExpression>"_blank"</InitialExpression>
</Property>

<Property name="disabled">
<Description><![CDATA[
Overridden to add ZENSETTING=0, which avoids invoking setProperty after this is
changed during a server-side operation;
this property is maintained automatically based on the presence and validity of
<property>coverageRunId</property>]]></Description>
<Type>%ZEN.Datatype.boolean</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="ZENSETTING" value="0"/>
</Property>

<Method name="%DrawHTML">
<Implementation><![CDATA[
	Try {
		Set tCoverageRunId = $$$ZENVAL(..coverageRunId)
		
		Set tResultsExist = 0
		If (tCoverageRunId '= "") {
			Set tCoverageRun = ##class(test.testcoverage.Data.Run).%OpenId(tCoverageRunId,,.tSC)
			$$$ThrowOnError(tSC)
			If $IsObject(tCoverageRun.TestResults) {
				Set tResultsExist = 1
				Set tQuery("$NAMESPACE") = $namespace
				Set tQuery("Index") = tCoverageRun.TestResults.%Id()
				Set ..href = ##class(%CSP.Page).Link("/csp/sys/%25UnitTest.Portal.Indices.zen",.tQuery)
			}
		}
		
		Set ..disabled = 'tResultsExist
		If 'tResultsExist {
			Set ..href = "#"
		}
		
		Do ##super()
	} Catch e {
		Do ##class(%ZEN.Utils).%DisplayErrorHTML($This,e.AsStatus())
	}
]]></Implementation>
</Method>
</Class>


<Class name="test.testcoverage.UI.ResultDetailViewer">
<Super>test.testcoverage.UI.Template</Super>
<TimeChanged>65455,32453</TimeChanged>
<TimeCreated>65108,62301.583345</TimeCreated>

<Parameter name="PAGENAME">
<Default>Unit Test Coverage - Detail</Default>
</Parameter>

<Property name="testIndex">
<Type>%ZEN.Datatype.string</Type>
<Parameter name="ZENURL" value="testIndex"/>
</Property>

<Property name="codeUnit">
<Type>%ZEN.Datatype.string</Type>
<Parameter name="ZENURL" value="codeUnit"/>
</Property>

<Property name="testPath">
<Type>%ZEN.Datatype.string</Type>
</Property>

<XData name="Contents">
<XMLNamespace>http://www.intersystems.com/zen</XMLNamespace>
<Data><![CDATA[
<page xmlns="http://www.intersystems.com/zen" xmlns:tc="http://www.intersystems.com/zen/healthshare/test-coverage" title="Unit Test Coverage - Class Viewer">

<vgroup width="80%" align="center">
<hgroup align="left" enclosingClass="box" cellAlign="even">
<vgroup labelPosition="left">
<tc:select id="testPath" label="Test Path" sql="select distinct %exact TestPath from test_testcoverage_Data.Coverage where Run = ? and Hash = ?" onchange="zenPage.testFilterChanged(zenThis)">
<parameter value="#(%page.testIndex)#" />
<parameter value="#(%page.codeUnit)#" />
</tc:select>
</vgroup>
<vgroup width="25%">
<pane paneName="TogglePane" labelPosition="left" />
</vgroup>
</hgroup>

<altJSONSQLProvider id="coverageDataProvider" maxRows="10000" queryClass="test.testcoverage.UI.Utils" queryName="ColoredText">
<parameter paramName="1" value="#(%page.testIndex)#" />
<parameter paramName="2" value="#(%page.codeUnit)#" />
<parameter paramName="3" value="#(%page.testPath)#" />
</altJSONSQLProvider>

<html id="coverageResults" align="left">
</html>

</vgroup>

</page>
]]></Data>
</XData>

<Method name="testFilterChanged">
<FormalSpec>pSrcComponent:%ZEN.Component.select</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var value = pSrcComponent.getValue();
	if (pSrcComponent.id == 'testPath') {
		zenPage.testPath = value;
	}
	
	this.showCodeCoverage();
]]></Implementation>
</Method>

<Method name="showCodeCoverage">
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	zen('coverageDataProvider').reloadContentsAsynch(function() {
		var code = zen('coverageDataProvider').getContentObject().children;
		document.getElementById('coverageResults').innerHTML = zenPage.buildCodeHTML(code);
	});
]]></Implementation>
</Method>

<Method name="onloadHandler">
<Description>
This client event, if present, is fired when the page is loaded.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[	zenPage.showCodeCoverage();
]]></Implementation>
</Method>
</Class>


<Class name="test.testcoverage.UI.SimpleResultViewer">
<Super>test.testcoverage.UI.Template</Super>
<TimeChanged>65455,32453</TimeChanged>
<TimeCreated>65108,62301.593164</TimeCreated>

<Parameter name="PAGENAME">
<Default>Unit Test Coverage - Class Viewer</Default>
</Parameter>

<Property name="testIndex">
<Type>%ZEN.Datatype.string</Type>
<Parameter name="ZENURL" value="testIndex"/>
</Property>

<Property name="codeUnit">
<Type>%ZEN.Datatype.string</Type>
<Parameter name="ZENURL" value="codeUnit"/>
</Property>

<Property name="testPath">
<Type>%ZEN.Datatype.string</Type>
</Property>

<XData name="Contents">
<XMLNamespace>http://www.intersystems.com/zen</XMLNamespace>
<Data><![CDATA[
<page xmlns="http://www.intersystems.com/zen" xmlns:tc="http://www.intersystems.com/zen/healthshare/test-coverage" title="Unit Test Coverage - Class Viewer">

<vgroup width="80%" align="center">
<hgroup align="left" enclosingClass="box" cellAlign="even">
<vgroup labelPosition="left">
<tc:select id="testIndex" label="Test Index" sql="select distinct Run from test_testcoverage_Data.Coverage order by Run desc" onchange="zenPage.testFilterChanged(zenThis)" />
<tc:select id="testPath" label="Test Path" sql="select distinct %exact TestPath from test_testcoverage_Data.Coverage where Run = ?" onchange="zenPage.testFilterChanged(zenThis)">
<parameter value="#(%page.testIndex)#" />
</tc:select>

<spacer height="25px" />

<tc:select id="codeCovered" label="Code Unit"
	sql="select distinct %exact Hash,Hash->Name||'.'||Hash->Type
			from test_testcoverage_Data.Coverage d,(select ? as Run, ? as TestPath) params
			where d.Run = params.Run
				and (params.TestPath is null or params.TestPath = d.TestPath)
			order by DECODE(Hash->Type,'CLS',1,'MAC',2,3),Hash->Name"
	onchange="zenPage.showCodeCoverage();">
<parameter value="#(%page.testIndex)#" />
<parameter value="#(%page.testPath)#" />
</tc:select>
</vgroup>
<vgroup width="25%">
<pane paneName="TogglePane" labelPosition="left" />
</vgroup>
</hgroup>

<altJSONSQLProvider id="coverageDataProvider" maxRows="10000" queryClass="test.testcoverage.UI.Utils" queryName="ColoredText">
<parameter paramName="1" value="#(%page.testIndex)#" />
<parameter paramName="2" value="#(%page.codeUnit)#" />
<parameter paramName="3" value="#(%page.testPath)#" />
</altJSONSQLProvider>

<html id="coverageResults" align="left">
</html>

</vgroup>

</page>
]]></Data>
</XData>

<Method name="testFilterChanged">
<FormalSpec>pSrcComponent:%ZEN.Component.select</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	zenPage[pSrcComponent.id] = pSrcComponent.getValue();
	
	if (pSrcComponent.id == 'testIndex') {
		zen('testPath').setValue('');
		zenPage.testPath = '';
	}
	
	zen('testPath').triggerRefresh();
	zen('codeCovered').triggerRefresh();

	if (zen('codeCovered').getValue() != '') {
		this.showCodeCoverage();
	}
]]></Implementation>
</Method>

<Method name="showCodeCoverage">
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	zenPage.codeUnit = zen('codeCovered').getValue();
	zen('coverageDataProvider').reloadContentsAsynch(function() {
		var code = zen('coverageDataProvider').getContentObject().children;
		document.getElementById('coverageResults').innerHTML = zenPage.buildCodeHTML(code);
	});
]]></Implementation>
</Method>
</Class>


<Class name="test.testcoverage.UI.Template">
<Abstract>1</Abstract>
<Super>%ZEN.Component.page</Super>
<TimeChanged>65455,32453</TimeChanged>
<TimeCreated>65108,62301.746319</TimeCreated>

<Parameter name="APPLICATION">
<Type>CLASSNAME</Type>
<Default>test.testcoverage.UI.Application</Default>
</Parameter>

<XData name="TogglePane">
<XMLNamespace>http://www.intersystems.com/zen</XMLNamespace>
<Data><![CDATA[
<pane xmlns="http://www.intersystems.com/zen">
<checkbox id="markCovered" label="Mark Covered Lines" onclick="zenPage.toggleCovered(zenThis.getValue())" value="1" />
</pane>
]]></Data>
</XData>

<Method name="toggleCovered">
<FormalSpec>pVisible</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[	$("pre.coverage span.covered").toggleClass("hide",!pVisible);
]]></Implementation>
</Method>

<Method name="buildCodeHTML">
<FormalSpec>codeLines</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var html = new Array();
	var showCovered = zen('markCovered').getValue()
	html.push('<pre class="coverage">\r\n');
	for (var i = 0; i < codeLines.length; i++) {
		var classes = new Array();
		if (codeLines[i].Executable) classes.push("executable");
		if (codeLines[i].Covered) {
			classes.push("covered");
			if (!showCovered) classes.push("hide");
		}
		var line = '<span class="'+classes.join(' ')+'">'+codeLines[i].ColoredHTML+'</span>\r\n';
		html.push(line);
	}
	html.push('</pre>');
	return html.join('');
]]></Implementation>
</Method>
</Class>


<Class name="test.testcoverage.UI.Utils">
<TimeChanged>65455,32453</TimeChanged>
<TimeCreated>65108,62301.575448</TimeCreated>

<Query name="ColoredText">
<Type>%Query</Type>
<FormalSpec>pTestIndex:%String,pCodeUnit:%String,pTestPath:%String=""</FormalSpec>
<SqlProc>1</SqlProc>
<Parameter name="ROWSPEC" value="PlainText:%String,ColoredHTML:%String,Covered:%Boolean,Executable:%Boolean,RawLine:%String"/>
</Query>

<Method name="ColoredTextExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,pTestIndex:%String,pCodeUnit:%String,pTestPath:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		If '##class(test.testcoverage.Data.CodeUnit).%ExistsId(pCodeUnit) {
			Set qHandle = ""
			Quit
		}
		
		Set tCodeUnit = ##class(test.testcoverage.Data.CodeUnit).%OpenId(pCodeUnit,,.tSC)
		$$$ThrowOnError(tSC)
		
		Set tSQL = "select CoveredLines from test_testcoverage_Data.Coverage where Run = ? and Hash = ?"
		Set tArgs($i(tArgs)) = pTestIndex
		Set tArgs($i(tArgs)) = pCodeUnit
		If (pTestPath '= "") {
			Set tSQL = tSQL_" and coverage.TestPath = ?"
			Set tArgs($i(tArgs)) = pTestPath
		}
		Set tResult = ##class(%SQL.Statement).%ExecDirect(,tSQL,tArgs...)
		If (tResult.%SQLCODE < 0) {
			Throw ##class(%Exception.SQL).CreateFromSQLCODE(tResult.%SQLCODE, tResult.%Message)
		}
		
		// Aggregate CoveredLines (bitwise OR)
		Set tCoveredLines = ""
		While tResult.%Next(.tSC) {
			$$$ThrowOnError(tSC)
			Set tNextCoveredLines = tResult.%Get("CoveredLines")
			Set tCoveredLines = $BitLogic(tCoveredLines|tNextCoveredLines)
		}
		$$$ThrowOnError(tSC)
		
		// Mask by only treating "executable" lines as covered
		Set tCoveredLines = $BitLogic(tCoveredLines&tCodeUnit.ExecutableLines)
		
		// Create code stream and stash line data
		Set tCodeStream = ##class(%GlobalCharacterStream).%New()
		For tLineNumber=1:1:tCodeUnit.Lines.Count() {
			Set tText = tCodeUnit.Lines.GetAt(tLineNumber)
			Do tCodeStream.WriteLine(tText)
			Set qHandle($i(qHandle)) = $ListBuild(tText,tText,$Bit(tCoveredLines,tLineNumber),$Bit(tCodeUnit.ExecutableLines,tLineNumber))
		}
		
		// Color the code stream.
		Set tColoredStream = ##class(%GlobalCharacterStream).%New()
		Set tColorer = ##class(%Library.SyntaxColor).%New()
		Set tLanguage = $Case($ZConvert(tCodeUnit.Type,"L"),"cls":"CLS","int":"MAC","inc":"INC",:"COS")
		Set tFlags = "PFE"_$Case(tLanguage,"CLS":"X",:"")
		Set tGood = tColorer.Color(tCodeStream,tColoredStream,tLanguage,tFlags,,,,.tColoringErrors,.tErrorEnv,.tColoringWarnings)
		If tGood {
			// TODO: Something with coloring/environment errors/warnings?
			
			// Extract colored lines (HTML) into qHandle subscripts
			
			// This code ensures that each line contains HTML that is valid in itself; for example, the output may have:
			// <FONT COLOR="#123456">foo<BR>ba<U>r<BR>ba</U>z</FONT>
			
			// This is normalized to three lines with:
			// <FONT COLOR="#123456">foo</FONT>
			// <FONT COLOR="#123456">bar</FONT>
			// <FONT COLOR="#123456">baz</FONT>
			
			// Care is taken to avoid leaving certain common tags (e.g., <U> to denote errors) unmatched on a given line.
			
			For tColoredLineIndex=1:1 {
				Set tColoredLine = tColoredStream.ReadLine(,.tSC)
				Set tOriginalColoredLine = tColoredLine
				$$$ThrowOnError(tSC)
				If (tColoredStream.AtEnd) {
					Quit
				}
				If $Extract(tColoredLine,1,7) = "</FONT>" {
					Set $Extract(tColoredLine,1,7) = ""
				} Else {
					// Extract last font color from previous line and prepend it (if found).
					Merge tPrevLine = qHandle(tColoredLineIndex - 1)
					If $Data(tPrevLine) {
						Set tPrevLine = $ListGet(tPrevLine,2)
						Set tIndex = 0
						Set tSearchIndex = 0
						Set tSearchString = "<FONT COLOR=""#"
						For {
							Set tNextIndex = $Find(tPrevLine,tSearchString,tSearchIndex)
							If tNextIndex = 0 {
								Quit
							}
							Set tSearchIndex = tNextIndex
							If ($Extract(tPrevLine,tSearchIndex+6,tSearchIndex+16) '= """ BGCOLOR=""") {
								// Avoid propagating coloring of errors to the next line (use the previous font from that line instead)
								Set tIndex = tSearchIndex
							}
						}
						If (tIndex '= 0) {
							// Last occurrence of '<FONT COLOR=""#' in previous line
							// (this may have been prepended itself!)
							Set tStartFont = tSearchString_$Extract(tPrevLine,tIndex,$Find(tPrevLine,">",tIndex+1)-1)
							Set tColoredLine = tStartFont_tColoredLine
						}
					}
				}
				
				// Strip all <U> and </U> if unmatched
				If $Length(tColoredLine,"</U>") '= $Length(tColoredLine,"<U>") {
					Set tColoredLine = $Replace(tColoredLine,"<U>","")
					Set tColoredLine = $Replace(tColoredLine,"</U>","")
				}
				
				// Ensure all <FONT> tags on line are closed
				Set tOpenedTags = $Length(tColoredLine,"<FONT")
				Set tClosedTags = $Length(tColoredLine,"</FONT>")
				If (tOpenedTags > tClosedTags) {
					// Add <FONT> as many times as it is missing.
					Set tColoredLine = tColoredLine_$Replace($Justify("",tOpenedTags-tClosedTags)," ","</FONT>")
				}
				
				// Remove line breaks
				Set tColoredLine = $Replace(tColoredLine,"<BR>","")
				Set $List(qHandle(tColoredLineIndex),2) = tColoredLine
				
				// For debugging purposes, also report the original HTML for each line.
				Set $List(qHandle(tColoredLineIndex),5) = tOriginalColoredLine
			}
		}
		
		Set qHandle = ""
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="ColoredTextFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>ColoredTextExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set qHandle = $Order(qHandle(qHandle),1,Row)
	If (qHandle = "") {
		Set AtEnd = 1
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="ColoredTextClose">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>ColoredTextExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="test.testcoverage.Utils.ComplexityParser">
<Super>%RegisteredObject</Super>
<TimeChanged>65455,32453</TimeChanged>
<TimeCreated>65108,62301.86602</TimeCreated>

<Property name="CodeStream">
<Type>%Stream.Object</Type>
<Private>1</Private>
</Property>

<Property name="Complexity">
<Type>%Integer</Type>
<InitialExpression>1</InitialExpression>
<Private>1</Private>
</Property>

<Property name="State">
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Method name="%OnNew">
<FormalSpec>pStream:%Stream.Object</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	Set ..CodeStream = pStream
	Set ..State = 1
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetComplexity">
<Description>
This method throws exceptions directly.</Description>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set tSC = ##class(%Library.SyntaxColorReader).FromCode(..CodeStream,"COS","A",.tSCReader)
	$$$ThrowOnError(tSC)
	Set tHasNextLine = tSCReader.NextLine(.tNextLineTokenList)
	While tHasNextLine {
		Set tLineTokenList = tNextLineTokenList
		Set tHasNextLine = tSCReader.NextLine(.tNextLineTokenList)
		Do ..ProcessTokenList(.tLineTokenList,'tHasNextLine)
	}
	Quit ..Complexity
]]></Implementation>
</Method>

<Method name="ProcessTokenList">
<FormalSpec>pTokenList:%List,pIsLastLine:%Boolean</FormalSpec>
<Implementation><![CDATA[
	Set tPointer = 0
	While $ListNext(pTokenList,tPointer,tToken) {
		Do ..ProcessToken(tToken, pIsLastLine)
	}
]]></Implementation>
</Method>

<Method name="ProcessToken">
<FormalSpec>pToken:%List,pIsLastLine:%Boolean</FormalSpec>
<Implementation><![CDATA[
	// Ironically, this is a very complex method.
	
	Set tLanguage = $ListGet(pToken,1)
	Set tType = $ListGet(pToken,2)
	Set tText = $ZConvert($ListGet(pToken,3),"L")
	
	// Skip white space.
	If (tType = "White Space") {
		Quit
	}
	
	Set tLastToken = $Get(..State("LastToken"))
	Set ..State("LastToken") = pToken
	
	If (tLanguage '= "COS") {
		// no-op
	} ElseIf (tType = "Operator") {
		// Interested in short-circuit logical operators only (because there is a different code path depending on the value of the first operand).
		If (tText = "||") || (tText = "&&") {
			Set ..Complexity = ..Complexity + 1
			Quit
		}
	} ElseIf (tType = "Command") {
		Set ..Complexity = ..Complexity + $Case(tText,
			"if":1,
			"elseif":1,
			"for":1,
			"while":1,
			"throw":1,
			"catch":1,
			"continue":1,
			"quit":'pIsLastLine,
			"return":'pIsLastLine,
			:0)
		Set ..State(..State,"Command") = tText
	} ElseIf (tType = "Delimiter") {
		If (tText = ":") {
			Set tFunction = $Get(..State(..State,"Function"))
			Set tLastText = $ListGet(tLastToken,3)
			If (tFunction = "$select") && (tLastText '= 1) {
				// Count all but trivial case. (Attempt to figure out if it's the trivial case is a bit lazy.)
				Set ..Complexity = ..Complexity + 1
			} ElseIf (tFunction = "$case") && (tLastText '= ",") {
				// Count all but default case.
				Set ..Complexity = ..Complexity + 1
			} ElseIf ($ListGet(tLastToken,2) = "Command") {
				// Postconditional
				Set ..Complexity = ..Complexity + 1
			}
		} ElseIf (tText = "(") {
			If ($ListGet(tLastToken,2) '= "Function") {
				Set ..State($Increment(..State)) = ""
			}
		} ElseIf (tText = ")") {
			Kill ..State(..State)
			Set ..State = ..State - 1
		} ElseIf (tText = ",") {
			// See if "," is used with if/elseif as a short-circuit and operator
			// ..State will have been incremented if it is in a method/function call
			Set tCommand = $Get(..State(..State,"Command"))
			If (tCommand = "if") || (tCommand = "elseif") {
				Set ..Complexity = ..Complexity + 1
			}
		}
	} ElseIf (tType = "Function") {
		Set ..State($Increment(..State),"Function") = tText
	}
]]></Implementation>
</Method>
</Class>


<Class name="test.testcoverage.Utils.File">
<Description>
We want to avoid depending on HSMOD.FileUtils to support use of the Test Coverage tool without the package manager (e.g., by QD)</Description>
<TimeChanged>65455,32453</TimeChanged>
<TimeCreated>65108,62301.850073</TimeCreated>

<Method name="CreateDirectoryChain">
<Description><![CDATA[
Create this directory and all the parent directories if they do not exist. This differs from
<method>CreateDirectory</method> as that method only creates one new directory where as
this will create the entire chain of directories. Returns true if it succeeds and false otherwise.
Pass <var>return</var> by reference to obtain the low level return value in case of errors]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	If '##class(%Library.File).CreateDirectoryChain(pName,.tReturn) {
		Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("Error creating directory chain %1: %2",pName,$zu(209,tReturn)))
	}
	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="test.testcoverage.Utils.LineByLineMonitor">
<Description>
Wrapper around %Monitor.System.LineByLine to ensure that the monitor is stopped when it should be, and also
to wrap the decision about whether to stop/start the monitor or to just clear counters.</Description>
<Super>%Monitor.System.LineByLine</Super>
<TimeChanged>65455,32453</TimeChanged>
<TimeCreated>65108,62301.875746</TimeCreated>

<Property name="Started">
<Description>
True if the line-by-line monitor has been started.</Description>
<Type>%Boolean</Type>
<Calculated>1</Calculated>
<Private>1</Private>
<ReadOnly>1</ReadOnly>
</Property>

<Method name="StartedGet">
<CodeMode>expression</CodeMode>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[$zu(84,8)
]]></Implementation>
</Method>

<Property name="Paused">
<Description>
True if the line-by-line monitor is paused</Description>
<Type>%Boolean</Type>
<Calculated>1</Calculated>
<Private>1</Private>
<ReadOnly>1</ReadOnly>
</Property>

<Method name="PausedGet">
<CodeMode>expression</CodeMode>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[..Started && '$zu(84,1)
]]></Implementation>
</Method>

<Property name="LastRoutineList">
<Type>%List</Type>
<Private>1</Private>
</Property>

<Property name="LastMetricList">
<Type>%List</Type>
<Private>1</Private>
</Property>

<Property name="LastProcessList">
<Type>%List</Type>
<Private>1</Private>
</Property>

<Method name="%OnClose">
<Description><![CDATA[
This callback method is invoked by the <METHOD>%Close</METHOD> method to 
provide notification that the current object is being closed.

<P>The return value of this method is ignored.]]></Description>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	If ..Started {
		Do ..Stop()
	}
	
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="CheckAvailableMemory">
<ClassMethod>1</ClassMethod>
<FormalSpec>pProcessCount:%Integer,pRoutineCount:%Integer,pRequireError:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set tRequiredPages = $zu(84,0,4,pProcessCount,0,pRoutineCount,0,0)
	Set tAvailablePages = $zu(84,0,5)
	If pRequireError || (tRequiredPages > tAvailablePages) {
		Set tSC = $$$ERROR($$$GeneralError,"Insufficient memory for line by line monitor - consider increasing gmheap. Contiguous memory required: "_(tRequiredPages*64)_" KB; reported available: "_(tAvailablePages*64)_" KB")
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="StartWithScope">
<Description>
Tracks current monitoring context and stops/starts or resets counters depending on whether it has changed</Description>
<FormalSpec>pRoutineList:%List,pMetricList:%List,pProcessList:%List</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tDifferentScope = (..LastRoutineList '= pRoutineList) || (..LastMetricList '= pMetricList) || (..LastProcessList '= pProcessList)
		If tDifferentScope && ..Started {
			// If we need to track different routines/metrics/processes, need to stop the monitor before restarting with the new context.
			Do ..Stop()
			Set ..LastRoutineList = pRoutineList
			Set ..LastMetricList = pMetricList
			Set ..LastProcessList = pProcessList
		}
		
		If '..Started {
			Set tSC = ..Start(pRoutineList, pMetricList, pProcessList)
			If $System.Status.Equals(tSC,$$$ERRORCODE($$$MonitorMemoryAlloc)) {
				// Construct a more helpful error message.
				Set tSC = $$$EMBEDSC(..CheckAvailableMemory($ListLength(pProcessList),$ListLength(pRoutineList),1),tSC)
			}
			$$$ThrowOnError(tSC)
		} Else {
			// If the monitor was already running, clear the counters.
			Set tSC = ..ClearCounters()
			$$$ThrowOnError(tSC)
			If ..Paused {
				$$$ThrowOnError(..Resume())
			}
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="ClearCounters">
<Description><![CDATA[
Clears all statistics, allowing collection to resume from 0 with the same settings and without needing to stop the monitor.
Based on <method>Pause</method> implementation, but with modern exception handling and code style.]]></Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set tLocked = 0
	Try {
		// See if PERFMON is running (vs. line-by-line)
		If ($zu(84,8) = 1) && ($zu(84,16) = -1) {
			$$$ThrowStatus($$$ERROR($$$MonitorInUse))
		}
		Lock +^%SYS("MON-HOLD"):3
		If '$Test {
			$$$ThrowStatus($$$ERROR($$$MonitorInUse))
		}
		Set tLocked = 1
		if ($zu(84,8) = 0) {
			// Monitor is off.
			$$$ThrowStatus($$$ERROR($$$MonitorNotRunning))
		}
		// Finally: actually clear the counters.
		Do $zu(84,2)
	} Catch e {
		Set tSC = e.AsStatus()
	}
	If tLocked {
		Lock -^%SYS("MON-HOLD")
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="IsRunning">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[$zu(84,8) && $zu(84,1)
]]></Implementation>
</Method>
</Class>


<Class name="test.testcoverage.Utils.Projection.SchemaGenerator">
<Super>%Projection.AbstractProjection</Super>
<TimeChanged>65455,32453</TimeChanged>
<TimeCreated>65108,62301.889467</TimeCreated>

<Parameter name="XDATA">
<Description>
Name of XData block with schema in class defining this projection. Defaults to XSD.</Description>
<Type>STRING</Type>
<Default>XSD</Default>
</Parameter>

<Parameter name="PACKAGE">
<Description>
Package in which to generate classes. Defaults to the current class's name.</Description>
<Type>STRING</Type>
</Parameter>

<Parameter name="DEFAULTSEQUENCE">
<Description><![CDATA[
See <class>%XML.Utils.SchemaReader</class> for description.]]></Description>
<Type>BOOLEAN</Type>
</Parameter>

<Parameter name="JAVA">
<Description><![CDATA[
See <class>%XML.Utils.SchemaReader</class> for description.]]></Description>
<Type>BOOLEAN</Type>
</Parameter>

<Parameter name="NOSEQUENCE">
<Description><![CDATA[
See <class>%XML.Utils.SchemaReader</class> for description.]]></Description>
<Type>BOOLEAN</Type>
</Parameter>

<Parameter name="POPULATE">
<Description><![CDATA[
See <class>%XML.Utils.SchemaReader</class> for description.]]></Description>
<Type>BOOLEAN</Type>
</Parameter>

<Parameter name="SQLCOLUMNS">
<Description><![CDATA[
See <class>%XML.Utils.SchemaReader</class> for description.]]></Description>
<Type>BOOLEAN</Type>
</Parameter>

<Parameter name="IGNORENULL">
<Description><![CDATA[
See <class>%XML.Utils.SchemaReader</class> for description.]]></Description>
<Type>BOOLEAN</Type>
</Parameter>

<Method name="CreateProjection">
<Description>
Generate classes based on the specified XData block.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[classname:%String,&parameters:%String,modified:%String,qstruct]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set tInitTLevel = $TLevel
	Try {
		Merge tParameters = parameters
		
		// Clear empty parameters
		Set tParameter = ""
		For {
			Set tParameter = $Order(parameters(tParameter),1,tValue)
			If (tParameter = "") {
				Quit
			}
			If (tValue = "") {
				Kill tParameters(tParameter)
			}
		}
		
		Set tXData = ##class(%Dictionary.XDataDefinition).IDKEYOpen(classname,parameters("XDATA"),,.tSC)
		$$$ThrowOnError(tSC)
		
		Set tTempFile = ##class(%Stream.FileCharacter).%New()
		Set tTempFile.RemoveOnClose = 1
		Set tSC = tTempFile.CopyFromAndSave(tXData.Data)
		$$$ThrowOnError(tSC)
		
		// If no package specified, generate under the class defining this projection.
		Set tPackage = $Get(parameters("PACKAGE"),classname)
		
		// Wrap deletion and regeneration of classes in a transaction.
		TSTART
		Set tSC = $System.OBJ.DeletePackage(tPackage)
		$$$ThrowOnError(tSC)
		
		Set tReader = ##class(%XML.Utils.SchemaReader).%New()
		Set tReader.CompileClasses = 0 // We'll queue this for later.
		Set tReader.MakePersistent = 0
		Set tReader.MakeNamespace = 1
		Set tSC = tReader.Process(tTempFile.Filename,tPackage,.tParameters)
		$$$ThrowOnError(tSC)
		TCOMMIT
		
		// Queue compilation of all classes in generated package
		Set tSC = $System.OBJ.GetPackageList(.tClasses,tPackage)
		$$$ThrowOnError(tSC)
		
		Set tClass = ""
		For {
			Set tClass = $Order(tClasses(tClass))
			If (tClass = "") {
				Quit
			}
			Do ..QueueClass(tClass)
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	While ($TLevel > tInitTLevel) {
		TROLLBACK 1
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="RemoveProjection">
<Description>
Cleanup is automatic when parent class is deleted.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[classname:%String,&parameters:%String,recompile:%Boolean,modified:%String,qstruct]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="test.testcoverage.Utils">
<IncludeCode>%occInclude</IncludeCode>
<IncludeGenerator>TestCoverage</IncludeGenerator>
<TimeChanged>65455,32453</TimeChanged>
<TimeCreated>65108,62301.070327</TimeCreated>

<Method name="Clear">
<Description>
Removes all data for test coverage, code snapshots. Does not enforce referential integrity (for the sake of speed).
@API.Method</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tClasses("test.testcoverage.Data.Aggregate.ByRun") = ""
		Set tClasses("test.testcoverage.Data.Aggregate.ByCodeUnit") = ""
		Set tClasses("test.testcoverage.Data.CodeSubUnit") = ""
		Set tClasses("test.testcoverage.Data.CodeUnitMap") = ""
		Set tClasses("test.testcoverage.Data.CodeUnit") = ""
		Set tClasses("test.testcoverage.Data.Coverage") = ""
		Set tClasses("test.testcoverage.Data.Run") = ""
		
		Set tClass = ""
		For {
			Set tClass = $Order(tClasses(tClass))
			If (tClass = "") {
				Quit
			}
			Set tOneSC = $ClassMethod(tClass,"%KillExtent")
			Set tSC = $$$ADDSC(tSC,tOneSC)
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="GrantSQLReadPermissions">
<Description>
Grants SQL SELECT permissions on all testcoverage tables for the specified username/role
@API.Method</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pUsernameOrRole:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tTableList = ..GetTestCoverageTableList()
		$$$ThrowOnError($System.SQL.GrantObjPriv("SELECT",$ListToString(tTableList),"TABLE",pUsernameOrRole))
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="RevokeSQLReadPermissions">
<Description>
Revokes SQL SELECT permissions on all testcoverage tables for the specified username/role
@API.Method</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pUsernameOrRole:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tTableList = ..GetTestCoverageTableList()
		$$$ThrowOnError($System.SQL.RevokeObjPriv("SELECT",$ListToString(tTableList),"TABLE",pUsernameOrRole))
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetTestCoverageTableList">
<ClassMethod>1</ClassMethod>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	&sql(select %DLIST(TABLE_SCHEMA || '.' || TABLE_NAME) into :tList from INFORMATION_SCHEMA.TABLES where TABLE_SCHEMA %STARTSWITH 'testcoverage')
	If (SQLCODE < 0) {
		Throw ##class(%Exception.SQL).CreateFromSQLCODE(SQLCODE,%msg)
	} ElseIf (SQLCODE = 100) {
		Set tList = ""
	}
	Quit tList
]]></Implementation>
</Method>

<Method name="Snapshot">
<Description><![CDATA[
Given <var>pIntRoutines</var>, a $ListBuild list of .INT routine names, creates snapshots of the current state of the code of each.
This is parallelized using <class>%SYSTEM.WorkMgr</class> for better performance.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pIntRoutines:%List</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		#dim tSnapshotQueue As %SYSTEM.WorkMgr
		Set tSnapshotQueue = $System.WorkMgr.Initialize(,.tSC)
		$$$ThrowOnError(tSC)
		
		Set tPointer = 0
		While $ListNext(pIntRoutines,tPointer,tIntRoutine) {
			Set tSC = tSnapshotQueue.Queue("##class(test.testcoverage.Data.CodeUnit).GetCurrentByName",tIntRoutine_".INT")
			$$$ThrowOnError(tSC)
		}
		
		Set tSC = tSnapshotQueue.WaitForComplete()
		$$$ThrowOnError(tSC)
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetTestPathAllTests">
<Description>
Returns the "TestPath" string used to represent coverage collected at the test coverage run level.
In deployed mode, test.testcoverage.inc does not exist, but dynamic SQL against persistent classes that include
it will try to include it in the generated class. This effectively makes the macro available as a method instead.</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<Implementation><![CDATA[
	Do %code.WriteLine(" Quit "_$$$QUOTE($$$TestPathAllTests))
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="AggregateCoverage">
<Description><![CDATA[
Aggregates coverage results for test coverage run <var>pTestIndex</var>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTestIndex:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set tInitTLevel = $TLevel
	Try {
		Set tRun = ##class(test.testcoverage.Data.Run).%OpenId(pTestIndex,,.tSC)
		$$$ThrowOnError(tSC)
		TSTART
		&sql(delete %NOLOCK %NOCHECK from test_testcoverage_Data_Aggregate.ByRun where Run = :pTestIndex)
		If (SQLCODE < 0) {
			Throw ##class(%Exception.SQL).CreateFromSQLCODE(SQLCODE,%msg)
		}
		&sql(delete %NOLOCK %NOCHECK from test_testcoverage_Data_Aggregate.ByCodeUnit where Run = :pTestIndex)
		If (SQLCODE < 0) {
			Throw ##class(%Exception.SQL).CreateFromSQLCODE(SQLCODE,%msg)
		}
		
		// Rollup: test.testcoverage.Data.Coverage at 'all tests' level
		Set tRollupTestPath = ..GetTestPathAllTests()
		Set tRollupCalculated = (tRun.Detail > 0)
		If tRollupCalculated {
			&sql(delete %NOLOCK %NOCHECK from test_testcoverage_Data.Coverage where Run = :pTestIndex and Calculated = 1)
			If (SQLCODE < 0) {
				Throw ##class(%Exception.SQL).CreateFromSQLCODE(SQLCODE,%msg)
			}
			&sql(
				insert %NOLOCK %NOCHECK into test_testcoverage_Data.Coverage (
						Run,TestPath,Hash,Calculated,Ignore,
						CoveredLines)
				select :pTestIndex,:tRollupTestPath,Hash,1,0,
						MAX(CoveredLines)
					from test_testcoverage_Data.Coverage
					where Run = :pTestIndex
						and Hash->Type in ('CLS','MAC')
						and Ignore = 0
						and Calculated = 0
					group by Hash
			)
			If (SQLCODE < 0) {
				Throw ##class(%Exception.SQL).CreateFromSQLCODE(SQLCODE,%msg)
			}
			
			// Copy any other metrics captured/requested as well.
			For i=1:1:tRun.Metrics.Count() {
				Set tMetric = tRun.Metrics.GetAt(i)
				Set tSQLStatement = "INSERT %NOLOCK %NOCHECK INTO test_testcoverage_Data.""Coverage_"_tMetric_""" "_
					"(Coverage,element_key,"""_tMetric_""") "_
					"SELECT target.ID,metric.element_key,SUM(metric."""_tMetric_""") "_
					"FROM test_testcoverage_Data.Coverage source "_
					"JOIN test_testcoverage_Data.""Coverage_"_tMetric_""" metric "_
					"	ON metric.Coverage = source.ID "_
					"JOIN test_testcoverage_Data.Coverage target "_
					"	ON target.Hash = source.Hash "_
					"	AND target.Run = source.Run "_
					"WHERE source.Run = ? "_
					"	AND source.Ignore = 0"_
					"	AND source.Calculated = 0"_
					"	AND target.TestPath = ?"_
					"GROUP BY target.ID,metric.element_key"
				
				#dim tResult As %SQL.StatementResult
				Set tResult = ##class(%SQL.Statement).%ExecDirect(,tSQLStatement,pTestIndex,tRollupTestPath)
				If (tResult.%SQLCODE < 0) {
					Throw ##class(%Exception.SQL).CreateFromSQLCODE(tResult.%SQLCODE,tResult.%Message)
				}
			}
		}
		
		// Aggregate by code unit
		&sql(
			insert %NOLOCK %NOCHECK into test_testcoverage_Data_Aggregate.ByCodeUnit (
					Run,
					CodeUnit,
					ExecutableLines,
					CoveredLines,
					ExecutableMethods,
					CoveredMethods,
					RtnLine,
					"Time",
					TotalTime)
			select :pTestIndex,
					CodeUnit,
					test_testcoverage.BIT_COUNT(ExecutableLines,1), -- Count of executable lines
					test_testcoverage.BIT_COUNT(CoveredLines,1), -- Count of lines that were covered
					
					-- Count of executable methods:
					-- These have at least one executable line
					NVL((select SUM(CASE
							test_testcoverage.BIT_COUNT(test_testcoverage.BITWISE_AND(
								method.Mask,ExecutableLines),1)
							WHEN 0 THEN 0
							ELSE 1 END)
						from test_testcoverage_Data_CodeSubUnit.Method method
						where method.Parent = CodeUnit),0) ExecutableMethods,
						
					-- Count of covered methods:
					-- These have at least one line that was covered
					NVL((select SUM(CASE
							test_testcoverage.BIT_COUNT(test_testcoverage.BITWISE_AND(
								method.Mask,CoveredLines),1)
							WHEN 0 THEN 0
							ELSE 1 END)
						from test_testcoverage_Data_CodeSubUnit.Method method
						where method.Parent = CodeUnit),0) CoveredMethods,
						
					-- Other metrics
					RtnLine, "Time", TotalTime
			from (
				select Hash CodeUnit,
					Hash->ExecutableLines ExecutableLines,
					test_testcoverage.BITWISE_AND(Hash->ExecutableLines,CoveredLines) CoveredLines,
					(select SUM(RtnLine)
						from test_testcoverage_Data.Coverage_RtnLine r
						where r.Coverage = coverage.ID) RtnLine,
					(select SUM("Time")
						from test_testcoverage_Data.Coverage_Time t
						where t.Coverage = coverage.ID) "Time",
					(select SUM(TotalTime)
						from test_testcoverage_Data.Coverage_TotalTime tt
						where tt.Coverage = coverage.ID) TotalTime
				from test_testcoverage_Data.Coverage coverage
				where Run = :pTestIndex
					and Calculated = :tRollupCalculated
					and Ignore = 0
					and Hash->Type in ('CLS','MAC')
					and TestPath = :tRollupTestPath -- This is guaranteed to exist, so optimize by using it rather than aggregating.
				
				-- Supported by index:
				-- Index MeaningfulCoverageData On (Run, Calculated, Ignore, Hash, TestPath) [ Data = CoveredLines, Unique ];
			)
			order by CodeUnit
		)
		If (SQLCODE < 0) {
			Throw ##class(%Exception.SQL).CreateFromSQLCODE(SQLCODE,%msg)
		}
		
		// Aggregate for full run
		&sql(
			insert %NOLOCK %NOCHECK into test_testcoverage_Data_Aggregate.ByRun
				(Run, ExecutableLines ,CoveredLines,
					ExecutableMethods, CoveredMethods,
					RtnLine, "Time", TotalTime)
			select Run, SUM(ExecutableLines), SUM(CoveredLines),
				SUM(ExecutableMethods), SUM(CoveredMethods),
				SUM(RtnLine), SUM("Time"), SUM(TotalTime)
			from test_testcoverage_Data_Aggregate.ByCodeUnit
			where Run = :pTestIndex
			group by Run
		)
		If (SQLCODE < 0) {
			Throw ##class(%Exception.SQL).CreateFromSQLCODE(SQLCODE,%msg)
		}
		TCOMMIT
	} Catch e {
		Set tSC = e.AsStatus()
	}
	While ($TLevel > tInitTLevel) {
		TROLLBACK 1
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetAggregateCoverage">
<Description><![CDATA[
Returns the test coverage measured for <var>pRunIndex</var>, as a percentage, or an empty string if no data was found.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pRunIndex:%Integer</FormalSpec>
<ReturnType>%Numeric</ReturnType>
<Implementation><![CDATA[
	Set tCoveragePercent = ""
	&sql(select ROUND((SUM(CoveredLines)/SUM(ExecutableLines))*100,2) into :tCoveragePercent
			from test_testcoverage_Data_Aggregate.ByRun where ExecutableLines > 0 and Run = :pRunIndex)
	If (SQLCODE < 0) {
		Throw ##class(%Exception.SQL).CreateFromSQLCODE(SQLCODE,%msg)
	} ElseIf (SQLCODE = 100) {
		Set tCoveragePercent = ""
	}
	Quit tCoveragePercent
]]></Implementation>
</Method>

<Method name="ShowAggregateCoverage">
<Description><![CDATA[
Displays aggregate coverage for <var>pRunIndex</var>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pRunIndex:%String</FormalSpec>
<Implementation><![CDATA[
	Set tCoveragePercent = ..GetAggregateCoverage(pRunIndex)
	If (tCoveragePercent = "") {
		Write !,"No code coverage found (!)"
	} Else {
		Write !,"Code coverage: ",tCoveragePercent,"%"
	}
	Write !
]]></Implementation>
</Method>

<Method name="GetClassLineExecutableFlags">
<Description><![CDATA[
For a class, <var>pClassName</var>, with code in <var>pDocumentText</var> as an integer-subscripted array of lines,
returns an array (<var>pExecutableFlags</var>) subscripted by line with boolean flags indicating whether the corresponding line is executable.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pClassName:%String,&pDocumentText,*pExecutableFlags]]></FormalSpec>
<Implementation><![CDATA[
	// Now process the class itself.
	Set tInMethod = 0
	Set tMethodStarted = 0
	For tDocLine=1:1:$Get(pDocumentText) {
		Set tLine = pDocumentText(tDocLine)
		If 'tInMethod {
			Set pExecutableFlags(tDocLine) = 0
		
			// Extract line offset of method in class
			Set tStart = $Extract(tLine,1,6)
			If (tStart = "ClassM") || (tStart = "Method") {
				Set tMethod = $Piece($Piece(tLine,"(")," ",2)
				Kill tMethodCode
				Set tInMethod = 1
			}
		} Else {
			If $Extract(tLine) = "{" {
				Set tMethodStarted = 1
				Set tMethodMap(tMethod) = tDocLine + 1
				Set pExecutableFlags(tDocLine) = 0
			} ElseIf $Extract(tLine) = "}" {
				Set tInMethod = 0
				Set tMethodStarted = 0
				Set pExecutableFlags(tDocLine) = 0
				
				Set tCodeMode = $$$defMemberKeyGet(pClassName,$$$cCLASSmethod,tMethod,$$$cMETHcodemode)
				If $Data(^rMAP(pClassName,"CLS","INT",tMethod)) || (tCodeMode = $$$cMETHCODEMODEGENERATOR) || (tCodeMode = $$$cMETHCODEMODEOBJECTGENERATOR) {
					Set tSourceStream = ##class(%Stream.GlobalCharacter).%New()
					Set tSourceStream.LineTerminator = $c(13,10)
					For tMethodLine=1:1:$Get(tMethodCode) {
						Do tSourceStream.WriteLine(tMethodCode(tMethodLine))
					}
					
					Set tSC = ##class(%Library.SyntaxColorReader).FromCode(tSourceStream,"COS","A",.tSCReader)
					$$$ThrowOnError(tSC)
					
					Set tOffset = tMethodMap(tMethod)
					Set tLine = 0
					While tSCReader.NextLine(.tLineTokenList) {
						If (tLine = 0) && (tCodeMode = $$$cMETHCODEMODEEXPRESSION) {
							// Simulate a normal method.
							Set tLineTokenList = $ListBuild($ListBuild("COS","Command","Quit"))_tLineTokenList
						}
						Set pExecutableFlags(tOffset + tLine) = ..LineIsExecutable(tLineTokenList,.tPreviousLineWasExecutable)
						If (tPreviousLineWasExecutable) {
							Set pExecutableFlags(tOffset + tLine - 1) = pExecutableFlags(tOffset + tLine-1) || tPreviousLineWasExecutable
						}
						Set tLine = tLine + 1
					}
				} Else {
					// Method is not executable.
					Set tOffset = tMethodMap(tMethod)
					For tMethodLine = 1:1:$Get(tMethodCode) {
						Set pExecutableFlags(tOffset + tMethodLine) = 0
					}
				}
			} ElseIf tMethodStarted {
				// Aggregate lines from the method body to look at later.
				Set tMethodCode($i(tMethodCode)) = tLine
			} 
		}
	}
]]></Implementation>
</Method>

<Method name="GetRoutineLineExecutableFlags">
<Description><![CDATA[
For a routine (.MAC/.INT) with code in <var>pDocumentText</var> as an integer-subscripted array of lines,
returns an array (<var>pExecutableFlags</var>) subscripted by line with boolean flags indicating whether the corresponding line is executable.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pDocumentText,*pExecutableFlags]]></FormalSpec>
<Implementation><![CDATA[
	Set tSourceStream = ##class(%Stream.GlobalCharacter).%New()
	Set tSourceStream.LineTerminator = $c(13,10)
	For tDocLine=1:1:$Get(pDocumentText) {
		Do tSourceStream.WriteLine(pDocumentText(tDocLine))
	}
	
	Set tSC = ##class(%Library.SyntaxColorReader).FromCode(tSourceStream,"COS","A",.tSCReader)
	$$$ThrowOnError(tSC)
	
	Set tLine = 1
	While tSCReader.NextLine(.tLineTokenList) {
		Set pExecutableFlags(tLine) = ..LineIsExecutable(tLineTokenList,.tPreviousLineWasExecutable)
		If (tPreviousLineWasExecutable) {
			Set pExecutableFlags(tLine-1) = 1
		}
		Set tLine = tLine + 1
	}
]]></Implementation>
</Method>

<Method name="LineIsExecutable">
<Description><![CDATA[
Given <var>pLineTokenList</var> with a list of tokens from a single line (from <class>%Library.SyntaxColorReader</class>),
returns 1 if the line is "executable" (meaning the line-by-line monitor will likely be able to detect whether it was executed) or not.
In certain edge cases, <var>pPreviousLineWasExecutable</var> may be set to 1 to correct the previous line's result.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pLineTokenList:%List,*pPreviousLineWasExecutable:%Boolean</FormalSpec>
<Private>1</Private>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set tExecutable = 0
	Set tPointer = 0
	Set pPreviousLineWasExecutable = 0
	While $ListNext(pLineTokenList,tPointer,tLineToken) {
		Set tExecutable = tExecutable || ..LineTokenIsExecutable(tLineToken, .tLineState, .pPreviousLineWasExecutable)
		If (tExecutable) {
			Quit
		}
	}
	Quit tExecutable
]]></Implementation>
</Method>

<Method name="LineTokenIsExecutable">
<Description><![CDATA[
Given <var>pLineToken</var> describing a single token on a given line (from <class>%Library.SyntaxColorReader</class>), and <var>pState</var> passed between calls,
returns 1 if the line is "executable" (meaning the line-by-line monitor will likely be able to detect whether it was executed) or not.
In certain edge cases, <var>pPreviousLineWasExecutable</var> may be set to 1 to correct the previous line's result.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pLineToken:%List,&pState,&pPreviousLineWasExecutable:%Boolean]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	If '$Data(pState) {
		Set pState("IsDim") = 0
		Set pState("PastWhiteSpace") = 0
		Set pState("DoCommand") = 0
	}
	Set tExecutable = 0
	Set tTokenType = $ListGet(pLineToken,2)
	Set tTokenName = $ListGet(pLineToken,3)
	Set tTokenLower = $ZConvert(tTokenName,"L")
	If (tTokenType = "Pre-Processor Command") {
		If (tTokenLower = "dim") {
			Set pState("IsDim") = 1
		}
	} ElseIf (tTokenType = "Command") {
		If pState("IsDim") {
			// Not executable unless there's an "="
		} Else {
			If (tTokenLower = "do") {
				// Special handling for do: is not executable if the line has just:
				// Do {
				// Will check later for non-whitespace/comment/brace tokens following "Do" on a given line
				Set pState("DoCommand") = 1
			} ElseIf (tTokenLower = "catch") {
				/*
				"Catch" is tricky.
				Given:
					}
					catch e {
				
				The line by line monitor will flag "}" as executed (if an exception was not thrown),
				but will never flag never "catch e {" as executed.
				
				Similarly,
					} catch e {
				gets credit as being run if no exception is thrown.
				*/
				 
				If pState("PastWhiteSpace") {
					Set tExecutable = 1
				} Else {
					Set pPreviousLineWasExecutable = 1
				}
			} ElseIf (tTokenLower '= "try") && (tTokenLower '[ "else") {
				Set tExecutable = 1
			}
		}
	} ElseIf (tTokenType = "Operator") {
		If pState("IsDim") {
			// #dim is executable if there is later an "Equals" operator
			If (tTokenName = "=") {
				Set tExecutable = 1
			}
		}
	} ElseIf (tTokenType = "Macro") {
		If (tTokenLower [ "throw") || (tTokenLower = "generate") {
			// $$$ThrowStatus / $$$ThrowOnError commonly appears as on lines with no explicit command.
			// Treat as executable.
			// $$$GENERATE(...) is also executable.
			Set tExecutable = 1
		}
	} ElseIf pState("DoCommand") && (tTokenType '= "White Space") && (tTokenType '= "Brace") && (tTokenType '= "Comment") {
		Set tExecutable = 1
	}
	If (tTokenType '= "White Space") {
		Set pState("PastWhiteSpace") = 1
	}
	Quit tExecutable
]]></Implementation>
</Method>

<Query name="LineByLineMonitorResult">
<Description>
Wrapper for %Monitor.System.LineByLine:Result to present metrics in a format more usable from SQL (as a table-valued function).</Description>
<Type>%Query</Type>
<FormalSpec>pRoutine:%String</FormalSpec>
<SqlProc>1</SqlProc>
<Parameter name="ROWSPEC" value="LineNumber:%Integer,LineCovered:%Boolean,RtnLine:%Integer,Time:%Numeric,TotalTime:%Numeric"/>
</Query>

<Method name="LineByLineMonitorResultExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,pRoutine:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit ##class(%Monitor.System.LineByLine).ResultExecute(.qHandle,pRoutine)
]]></Implementation>
</Method>

<Method name="LineByLineMonitorResultFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>ResultExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tLine = $Piece(qHandle,"^",2)
	Set tSC = ##class(%Monitor.System.LineByLine).ResultFetch(.qHandle,.Row,.AtEnd)
	If 'AtEnd {
		Set tCounters = $List(Row,1)
		Set tRtnLine = $ListGet(tCounters,1)
		Set tTime = $ListGet(tCounters,2)
		Set tTotalTime = $ListGet(tCounters,3)
		
		Set tRtnLines = $Case(tRtnLine,0:0,"":0,:tRtnLine)
		Set tLineCovered = (tRtnLines > 0)
		Set tTime = $Case(tTime,0:0,"":0,:tTime)
		Set tTotalTime = $Case(tTotalTime,0:0,"":0,:tTotalTime)
		Set Row = $ListBuild(tLine,tLineCovered,tRtnLines,tTime,tTotalTime)
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="LineByLineMonitorResultClose">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>ResultExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit ##class(%Monitor.System.LineByLine).ResultClose(.qHandle)
]]></Implementation>
</Method>
</Class>


<Class name="test.unittest.Service.ImpostoEhRouboTests">
<Super>test.unittest.UnitTestAbstract</Super>
<TimeChanged>65456,53594.374599</TimeChanged>
<TimeCreated>65455,32614.709614</TimeCreated>

<Property name="Service">
<Type>Service.ImpostoEhRoubo</Type>
<Private>1</Private>
</Property>

<Property name="ImpostoEhRouboServiceMock">
<Type>Service.ImpostoEhRoubo</Type>
<Private>1</Private>
</Property>

<Method name="InicializarMocks">
<Implementation><![CDATA[	Return $$$OK
]]></Implementation>
</Method>

<Method name="InicializarService">
<Implementation><![CDATA[
	Set ..Service = ##class(Service.ImpostoEhRoubo).%New(..InicializarMocks())
	
	Return $$$OK
]]></Implementation>
</Method>

<Method name="TestCalcularICMS">
<Implementation><![CDATA[
	Do ..ReplayAllMocks()
	
	Set imposto = ..Service.CalculaICMS(100)
	Do $$$AssertEquals(imposto, 20)
	
	Do ..VerifyAllMocks()
]]></Implementation>
</Method>

<Method name="TestCalculaIOFAbaixoDaFaixa">
<Implementation><![CDATA[
	Do ..ReplayAllMocks()
	
	Try{
		Do ..Service.CalculaIOF(-1)
	}
	Catch erro{
		Do $$$AssertEquals(erro.Name, "	O valor deve estar entre 0 e 99.999!!")
	}
	
	Do ..VerifyAllMocks()
]]></Implementation>
</Method>

<Method name="TestCalculaIOFDentroDaFaixa">
<Implementation><![CDATA[
	Do ..ReplayAllMocks()
	
	Set imposto = ..Service.CalculaIOF(100)
	Do $$$AssertEquals(imposto, 55)
	
	Do ..VerifyAllMocks()
]]></Implementation>
</Method>

<Method name="TestCalculaIOFAcimaDaFaixa">
<Implementation><![CDATA[
	Do ..ReplayAllMocks()
	
	Try{
		Do ..Service.CalculaIOF(1000000)
	}
	Catch erro{
		Do $$$AssertEquals(erro.Name, "	O valor deve estar entre 0 e 99.999!!")
	}
	
	Do ..VerifyAllMocks()
]]></Implementation>
</Method>

<Method name="TestCalculaIPIMenorQueMil">
<Implementation><![CDATA[
	Do ..ReplayAllMocks()
	
	Set imposto = ..Service.CalculaIPI(100)
	Do $$$AssertEquals(imposto, 337)
	
	Do ..VerifyAllMocks()
]]></Implementation>
</Method>

<Method name="TestCalculaIPIMenorQueDezMil">
<Implementation><![CDATA[
	Do ..ReplayAllMocks()
	
	Set imposto = ..Service.CalculaIPI(1000)
	Do $$$AssertEquals(imposto, 3310)
	
	Do ..VerifyAllMocks()
]]></Implementation>
</Method>

<Method name="TestCalculaIPIMenorQueCemMil">
<Implementation><![CDATA[
	Do ..ReplayAllMocks()
	
	Set imposto = ..Service.CalculaIPI(10000)
	Do $$$AssertEquals(imposto, 32600)
	
	Do ..VerifyAllMocks()
]]></Implementation>
</Method>

<Method name="TestCalculaIPIMaiorQueCemMil">
<Implementation><![CDATA[
	Do ..ReplayAllMocks()
	
	Set imposto = ..Service.CalculaIPI(100001)
	Do $$$AssertEquals(imposto, 319003.19)
	
	Do ..VerifyAllMocks()
]]></Implementation>
</Method>

<Method name="TestCalculaIPIInvalido">
<Implementation><![CDATA[
	Do ..ReplayAllMocks()
	
	Set imposto = ..Service.CalculaIPI("Teste valor Inválido")
	Do $$$AssertEquals(imposto, 0)
	
	Do ..VerifyAllMocks()
]]></Implementation>
</Method>
</Class>


<Class name="test.unittest.UnitTestAbstract">
<Description><![CDATA[
<h1>Diretrizes para criação de testes</h1>
<ol>
  <li>
     <h2>Organização das classes de teste</h2><br>
     Testes unitários e testes de integração devem estar pacotes separados. O motivo é que normalmente são executados em momentos 
   	 diferentes visto que testes de integração tendem a consumir mais tempo e recursos computacionais, portanto podem impactar em pipe DevOps. <br><br>
      <table style="border: 1px solid black;">
		  <tr>
              <th style="border: 1px solid black;">Tipo de teste</th>
              <th style="border: 1px solid black;">Pacote</th>
              <th style="border: 1px solid black;">Responsabilidade</th>
          </tr>
		  <tr>
              <td style="border: 1px solid black;">Teste unitário</td>
              <td style="border: 1px solid black;">test.unittest</td>
              <td style="border: 1px solid black;">Teste de objeto de negócio.</td>
          </tr>
		  <tr>
              <td rowspan="4" style="border: 1px solid black;">Teste de integração</td>
              <td style="border: 1px solid black;">
                  test.integrationtest<br>                
               </td>
              <td style="border: 1px solid black;">
                  Testes que envolvem sistemas externos.<br>
                  Exemplo: banco de dados ou bibliotecas externas
              </td>
          </tr>
		  <tr>
              <td style="border: 1px solid black;">
                  test.integrationtest.adapter<br>
              </td>
              <td style="border: 1px solid black;">
                  Interface com códigos/componentes complexos dos produtos que não podem ser adequados aos padrões Object Mother ou Builder: <br>
                  Exemplo: Componente OsProcedimento.
              </td>
          </tr>
		  <tr>
              <td style="border: 1px solid black;">
                  test.integrationtest.helper
               </td>
              <td style="border: 1px solid black;">
                  Códigos necessários para os testes e assertions que não existem nas classes do produto.<br>
                  Exemplo: Verificar se exame já existe para uma O.S.
              </td>
          </tr>
		  <tr>
              <td style="border: 1px solid black;">
                  test.integrationtest.mother
              </td>
              <td style="border: 1px solid black;">
                  Criação de cenários de teste com dados.<br>
                  Agrupam chamadas de builders com o propósito de não reptir mesma chamadas de builders em vários lugares.
              </td>
          </tr>
	  </table>
      <br><br>
  </li>

  <li>
      <h2>Design Pattners necessários para criação dos testes </h2>
      Ambos os tipos de testes utilizam os padrões <b>Builder</b> e <b>Object Mother</b>. É imprescindível o conhecimento destes padrões
      para entendimento e produção dos testes de maneira coesa.
  </li>
  <br>

  <li>
    <h2>Testes unitários</h2>
    <ol>
      <li>
        <h3>Classes controller</h3>
        Testes de controllers não devem depender da camada de negócio, portanto deve fazer mock dos objetos service.
      </li>
      <li>
       <h3>Classes service</h3>
        Testes de classes service não devem depender da camada de integração, portanto deve fazer mock de objetos dao.
        Também pode haver a necessidade de realizar mock de outros objetos da camada de negócio para teste de um service.
      </li>
      <li>
       <h3>Classes de negócio</h3>
       Testes de objetos de negócio não devem utilizar mock. Caso contrário a classe de negócio não está coesa.
      </li>
   </ol>
 </li>

 <li>
   <h2>Testes de integração</h2>
   <ol>
     <li>
       Todos os objetos que necessitam ser armazenados e possuam mapeamento objeto relacional devem ser persistidos por meio do seu respectivo builder ou object mother.
       Os cenários criados com objetos builder devem ser transferidos para objetos mother sempre que existir potencial para se repetir em diferentes casos de teste.
     </li><br>
     <li>Testes que envolvam componentes complexos com códigos muito acoplados devem utilizar o padrão Adapter. Isso significa que deve ser criada uma classe Adapter que 
      seja responsável por instanciar o componente complexo e orquestrar as respectivas chamadas de métodos ao componente. Assim a interface complexa oferecida pelo componente 
      fica encapsulada no adapter bem como eventuais alterações no componente terá o adapter como único ponto de impacto no que se refere aos testes.
     </li>
   </ol>
 </li>

 <li>
<h2>Comandos para uso geral</h2>
<ol>
  <li>Execução de todos os métodos da classe de testes: <code> d ##class(classeDeTeste).RunTests()</code></li><br>
  <li>Execução de um único método da classe de testes: <code> do ##class(classeDeTeste).RunTest("nomeDoMetodo")</code> </li><br>
  <li>
      Execucão dos testes via browser: <code>http://ip:porta/aplicacaoWebCache/classeDeTeste.cls</code>
      Ao pressionar F5 a partir do studio a página de testes é apresentada no browser.
  </li><br>
  <li>Execução de todos os testes unitários: <code>d ##class(test.unittest.UnitTestAbstract).RunTestsByPackage("test.unittest")</code> </li><br>
      <ul>
        <li>Execução dos testes do lis: <code>d ##class(test.unittest.UnitTestAbstract).RunTestsByPackage("test.unittest.s01")</code> </li><br>
        <li>Execução dos testes do controller: <code>d ##class(test.unittest.UnitTestAbstract).RunTestsByPackage("test.unittest.s04")</code> </li><br>
      </ul>
  <li>Execução de todos os testes de integração: <code>d ##class(test.unittest.UnitTestAbstract).RunTestsByPackage("test.integrationtest")</code> </li><br>
  <li>Recuperar dados da última execução de testes: <code>##class(test.unittest.UnitTestAbstract).GetLastResult(.date,.status,.duration,.html,.suite)</code><br>
      As variáveis por referência trazem valores importantes referente a última execução.</li><br>
  <li>Deletar todos os resultados de testes armazenados: <code>##class(test.unittest.UnitTestAbstract).PurgeLog()</code><br>
      <b>Importante: Esta operação não pode ser desfeita</b>.
       
  </li><br>
</ol>
 <li>


<h2>Exemplos de uso de mock</h2>

<b>Importante: </b> Classes abstratas também podem fazer uso de mock. <br><br>

<b>1 - Mock de objeto Dao</b>
<div class="sampleCode">
<pre>
Method TestRecebimentoMaloteValido()
{
	Set maloteDao = ..CreateMock()
	Do ..Expect(maloteDao.GetQuantidadeMalotesNaCaixa(1)).AndReturn(1)
	Do ..Expect(maloteDao.GetQuantidadeMalotesNaCaixaPorStatus(1,##class(s01.dto.malote.MaloteStatusEnum).#Recebido)).AndReturn(1)
	
	Set maloteService = ##class(s01.service.malote.MaloteService).%New(maloteDao)
	Do ..ReplayAllMocks()
	
	Do $$$AssertEquals(maloteService.IsRecebimentoMalotesValido(1),1)
	
	Do ..VerifyAllMocks()
}

Method TestRecebimentoMaloteInvalido()
{
	Set maloteDao = ..CreateMock()
	Do ..Expect(maloteDao.GetQuantidadeMalotesNaCaixa(1)).AndReturn(2)
	Do ..Expect(maloteDao.GetQuantidadeMalotesNaCaixaPorStatus(1,##class(s01.dto.malote.MaloteStatusEnum).#Recebido)).AndReturn(1)
	
	Set maloteService = ##class(s01.service.malote.MaloteService).%New(maloteDao)				
	Do ..ReplayAllMocks()
	
	
	Do $$$AssertNotTrue(maloteService.IsRecebimentoMalotesValido(1))
	
	Do ..VerifyAllMocks()
}
</pre>
</div>
<br><br>
<b>2 - Mock de objeto Service</b>
<div class="sampleCode">
<pre>
Method TestGetListaMalotesDasAmostras()
{ 	
	Set amostra = "004000555101"
	Set osRecipienteId = 50
	Set maloteId = 784
	
	Set amostraService = ..CreateMock()
	Do ..Expect(amostraService.GetOsRecipienteIdPorCodigoBarras(amostra)).AndReturn(osRecipienteId)
	
	Set maloteDao = ..CreateMock()
	Do ..Expect(maloteDao.GetMaloteDaAmostra(osRecipienteId)).AndReturn(maloteId)
	
			
	Set maloteService = ##class(s01.service.malote.MaloteService).%New(maloteDao, amostraService)
	Do ..ReplayAllMocks()
	Set encontrouNaLista = maloteService.GetListaMalotesDasAmostras($LB(amostra))
	
	
	Do $$$AssertEquals(encontrouNaLista,$LB(maloteId))
		
	Do ..VerifyAllMocks()
}
</pre>
</div>
<br><br><br>
]]></Description>
<Super>test.framework.CUnitTestBase</Super>
<TimeChanged>65455,32765</TimeChanged>
<TimeCreated>65055,37429.179959</TimeCreated>

<Method name="RunTest">
<Description>
Executa um metodo específico da classe de teste</Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<FormalSpec>pMethodName:%String</FormalSpec>
<Implementation><![CDATA[
   #dim strClassName As %String = ..%ClassName(1)
   D ##class(test.framework.InterSystems.CManager).DebugRunTestCase(strClassName,strClassName,"",pMethodName,.ret)
]]></Implementation>
</Method>

<Method name="PurgeLog">
<Description><![CDATA[
Deleta o resultado de todos os logs de teste que estejam no servidor.<br>
Dessa formao próximo id de retultado de teste gerado será = 1.<br>
Esta ação, uma vez executada, não pode ser desfeita.]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[	d ##class(test.framework.InterSystems.CManager).PurgeLog()
]]></Implementation>
</Method>

<Method name="RunTests">
<Description>
Executa todos os métodos de teste da classe de teste</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[   do ##super(1)
]]></Implementation>
</Method>

<Method name="RunTestsByPackage">
<Description>
Executa todos os tests dentro de determinado pacote recursivamente</Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<FormalSpec>pPackageName:%String(MAXLEN="")</FormalSpec>
<Implementation><![CDATA[	Do ##class(test.framework.Shift.CManager).RunTest(pPackageName)
]]></Implementation>
</Method>

<Method name="ApresentaExcecao">
<Description>
Adicionado para compatibilidade na migração da abstração</Description>
<FormalSpec>pException:%Exception.AbstractException</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
     Set manager=r%Manager
     Set retorno = 0
     Do manager.LogAssert(retorno,"ERRO NÃO ESPERADO", pException.DisplayString())
     If retorno||'..Debug Quit retorno
]]></Implementation>
</Method>

<Method name="MockSession">
<Description>
Adicionado para compatibilidade na migração da abstração</Description>
<Implementation><![CDATA[
    Set %session = ##class(%CSP.Session).%New("sessaoMockada",0)
    Set %session.Data("UsuarioId") = "1"
    Set %session.Data("UsuarioWebTipo") = "3"
    Set %session.Data("UsuarioWebId") = "636"
    Set %session.Data("ConfiguracaoWeb") = "UNICO"
]]></Implementation>
</Method>

<Method name="MockRequest">
<Description>
Adicionado para compatibilidade na migração da abstração</Description>
<Implementation><![CDATA[
    Set %request = ##class(%CSP.Request).%New()
    Do %request.InsertCgiEnv("REMOTE_ADDR","127.0.0.1")
    Do %request.InsertCgiEnv("SERVER_NAME","127.0.0.1")
    Do %request.InsertCgiEnv("SERVER_PORT","127.0.0.1")
]]></Implementation>
</Method>

<Method name="ValidarImplementacaoMetodosPadrao">
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
    Try{
		Set classeNome = %class.Name
		Do:('..ExisteMetodoPadrao(classeNome,"InicializarMocks")) ..ExibirAlertaMetodoNaoImplementado("InicializarMocks")
		Do:('..ExisteMetodoPadrao(classeNome,"InicializarService")) ..ExibirAlertaMetodoNaoImplementado("InicializarService")
    }Catch(ex){
	 	W !, ex.DisplayString()
	}
]]></Implementation>
</Method>

<Method name="ExisteMetodoPadrao">
<ClassMethod>1</ClassMethod>
<FormalSpec>pNomeClasse:%String,pNomeMetodo:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	Return ''$$$defMemberDefined(pNomeClasse, $$$cCLASSmethod, pNomeMetodo)
]]></Implementation>
</Method>

<Method name="ExibirAlertaMetodoNaoImplementado">
<ClassMethod>1</ClassMethod>
<FormalSpec>pNomeMetodo:%String</FormalSpec>
<Implementation><![CDATA[
	W !!, "##################################################################################################################"
	W !!, "	   Atenção: o método '"_pNomeMetodo_"' definido como padrão para classe de testes não foi implementado.          " ,!
	W !,  "##################################################################################################################" ,!
]]></Implementation>
</Method>

<Method name="OnBeforeOneTest">
<FormalSpec>testname:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..InicializarMocks()
	Do ..InicializarService()
	Return $$$OK
]]></Implementation>
</Method>

<Method name="InicializarMocks">
<Implementation><![CDATA[	Return $$$OK
]]></Implementation>
</Method>

<Method name="InicializarService">
<Implementation><![CDATA[	Return $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="test.unittest.s01.Service.ProcedimentoTests">
<Super>test.unittest.UnitTestAbstract</Super>
<TimeChanged>65455,43236.670308</TimeChanged>
<TimeCreated>65455,43236.670308</TimeCreated>
</Class>


<Class name="test.unittest.s01.Service.SetorTests">
<Super>test.unittest.UnitTestAbstract</Super>
<TimeChanged>65462,41064.191729</TimeChanged>
<TimeCreated>65455,43250.766274</TimeCreated>

<Property name="Service">
<Type>s01.Service.Setor</Type>
<Private>1</Private>
</Property>

<Property name="SetorDAOMock">
<Type>s01.DAO.Setor</Type>
<Private>1</Private>
</Property>

<Method name="InicializarMocks">
<Implementation><![CDATA[
	Set ..SetorDAOMock = ..CreateMock()
	Return $$$OK
]]></Implementation>
</Method>

<Method name="InicializarService">
<Implementation><![CDATA[
	Set ..Service = ##class(s01.Service.Setor).%New(..SetorDAOMock)
	Return $$$OK
]]></Implementation>
</Method>

<Method name="TestCadastrarAtivo">
<Implementation><![CDATA[
 	Do ..ReplayAllMocks()
 	Try{
 		Set setorDto = ##class(s01.DTO.Setor).%New()
 		Set setorDto.Descricao = "SetorAtivo"
 		Set setorDto.Status = "Ativo"
 		Set setorDao = ##class(s01.DAO.Setor).%New()
 		Return setorDao.Cadastrar(setorDto)
 	}
 	Catch erro{
 		Do $$$AssertEquals(erro.Name, "	O status não é válido!!")
 	}
 	Do ..VerifyAllMocks()
]]></Implementation>
</Method>

<Method name="TestCadastrarInativo">
<Implementation><![CDATA[
 	Do ..ReplayAllMocks()
 	Try{
 		Set setorDto = ##class(s01.DTO.Setor).%New()
		Set setorDto.Descricao = "SetorInativo"
 		Set setorDto.Status = "Inativo"
 		Set setorDao = ##class(s01.DAO.Setor).%New()

 		Return setorDao.Cadastrar(setorDto)
 	}
 	Catch erro{
 		Do $$$AssertEquals(erro.Name, "	O status não é válido!!")
 	}
 	Do ..VerifyAllMocks()
]]></Implementation>
</Method>

<Method name="TestCadastrarInvalido">
<Implementation><![CDATA[
 	Do ..ReplayAllMocks()
 	Try{
 		Set setorDto = ##class(s01.DTO.Setor).%New()
		Set setorDto.Descricao = "Invalido"
 		Set setorDto.Status = "Invalido"
 		Set setorDao = ##class(s01.DAO.Setor).%New()

 		Return setorDao.Cadastrar(setorDto)
 	}
 	Catch erro{
 		Do $$$AssertEquals(erro.Name, "	O status não é válido!!")
 	}
 	Do ..VerifyAllMocks()
]]></Implementation>
</Method>
</Class>
</Export>
